--ссылки--
------------------------------------------
https://docs.microsoft.com/en-us/dotnet/api/system.environment.specialfolder?view=net-5.0 Задает перечисляемые константы,
 используемые для получения путей каталогов к специальным системным папкам.

 https://stackoverflow.com/questions/3850019/running-two-projects-at-once-in-visual-studio закуск несолкьких проектов в студии одновременно
==========================================


--расписание на неделю--

пнд 
------------------------------------------
утро - развитие памяти Б= 15 мин,7.0 C# Эндрю, изучение паттернов
послеобеда - написание своей прогаммы БД и Ехел
вечер - книга с темой и/или метанит разное

вт
------------------------------------------
утро - развитие памяти Б= 15 мин, Arduino и/или REST и прочие побочные технологии
послеобеда - Arduino и/или REST и прочие побочные технологии
вечер -книга с темой и/или REST и прочие побочные технологии  

ср
------------------------------------------
утро - развитие памяти Б= 15 мин, 7.0 C# Эндрю, изучение паттернов
послеобеда - написание совей прогаммы БД и Ехел
вечер - книга с темой и/или метанит разное

чт
------------------------------------------
утро - развитие памяти Б= 15 мин, REST и прочие побочные технологии
послеобеда - REST и прочие побочные технологии
вечер -книга с темой и/или REST и прочие побочные технологии

пт
------------------------------------------
утро - развитие памяти Б= 15 мин, Arduino
послеобеда - Arduino
вечер - книга с темой и/или метанит разное и/или Arduino



--C#--
------------------------------------------------------------------------------------
--Стек и Куча--

------------------------------------------
Стек
------------------------------------------
последним пришёл — первым ушёл
Самый верхний элемент стека, который добавлен последним, извлекается самым первым. Поэтому такой стек является 
структурой типа LIFO, аналогией может служить магазин пистолета патроны при стрельбе извелкаются в 
обратном порядке тому в ктором они туда заряжались

для стека использетуеся маленкий обьем опаретивной памяти
стек выделяется для каждого потока те каждый поток в ропграмме имеет собственный стек
стек использетуеся для храниения перменных которые мы создаем для выполнения операций над этими перменными
для вызова методов которые мы используем в нашей программе те для того чтобы выполнять логику нашей программы
дефолтное значение которое выделяется под стек ограничивается - 1 МБ

стек нужен для организации логики нашей программы 
здесь опрделеяется очередность вызова метододв используемые по мере выполнения наше программы 

Куча(Heap)
------------------------------------------
первый зашел последний вышел

Склад опреативной памяти который мы используем по мере надобности он гораздо больше чем стек
если у нас 32 разрадный процеес то выделить под кучу можно до 1,5 ГБ опреативной памяти 
если у нас 64 разрадный процеес то выделить под кучу можно до 8 ТБ опреативной памяти 

более проблематично выделять и очищать данные в оперативной памяти под кучу нежели под стек 
очисткой кучи из памяти занимается сборщик мусора сборка мусора занимает опраделленно время и расходует ресурсы

==========================================

--значимые типы, (--value types) и --ссылочные типы (--reference types)--
------------------------------------------

типы обьектов задаются во мремя старта программы, в c# исопльзуется стаическая типизация,

значимые типы, (value types) -> стек
------------------------------------------
эти типы неявно унаследованы от System.ValueType
Структуры (struct)
Целочисленные типы (byte, sbyte, short, ushort, int, uint, long, ulong)
Типы с плавающей запятой (float, double)
Тип decimal
Тип bool
Тип char

Перечисления enum

пермеменные передаются по значению(копируются реальные данные) те она хранит реальные данные

когда создаем перменную значимого типа то мы как будто положили какотйо файл на рабочеий стол а не его ярлык поэтому 
мы не можем присвоить этой персенной значение null

если мы присваем одной такой перемено значени другой такой перменной мы копируем значение из одной переменной в другую,
как итог в стеке две перменнх с одинаковым результатом

переменные этого типа пракаращают свое сущетсование когда покидают контекст(область видимости) в котором они были 
определены

static void Main(string[] args)
    {
       int i = 1;
       GetInt(5);
       Console.WriteLine(i);//i == 1 
       Console.ReadLine();
    }

    static void GetInt(int i)//сюда копируеся значение из перменной i 
    {
        i = 5;//при выходе из области видимочти эта перменная как и ее значение удаляется
    }


ссылочные типы (reference types) -> куча
------------------------------------------
могут быть производными от любого другого типа кроме System.ValueType
неявно наследованы от object
Тип object
Тип string
Тип Array
Классы (class)
Интерфейсы (interface)
Делегаты (delegate)
------------------------------------------

копируется ссылка, оригинал и копия ссылаются на один и тот же обьект в управляемой куче, одни и те же данные 

ссылочные типы хранят свои данные в куче, но в стеке хранится ссылка на данные в управляемой куче 
когда создаем перменную ссылочного типа то в стеке у нас хранится ссылка(типа как ярлык на рабочем столе 
если удалить файл на ктороый ссылается этот ярлык то наш ярлык будет иметь значение null),
а в куче хранятся данные(типа как exe) 

Если переменным ссылочного типа не присваивается значение, то им дается значение по умолчанию - значение null.
Фактически оно говорит об отстутсвии значения как такового или что нету ссылки на данные в управляемой куче  
те когда мы обявли перменную ссылочного типа
{
   int[]a;  //a = null;
}
мы разместили на стеке некий ярлык ктороый храни ссылку на данные ктороы распологаются в куче - это и ест null 

если мы присваем одной такой перемено значени другой такой перменной мы копируем ссылки на эту перменную а не содержимое
(типа как еще один ярлык на рабочем столе который ведет по тому же пути что и первый), те две этих перменных теперь 
будут ссылаться на один и теже еданные 

static void Main(string[] args)
            {
                int[] arr1;//arr1 = null мы разместили на стеке некий ярлык ктороый храни 
                //ссылку на данные ктороы распологаются в управляемой куче но пока там ничего нет

                arr1 = new int[1];//new в управляемой куче создает место под массив и вернет ссылку на эту область
                //в памяти в перменную arr1

                ////////////////////////////////////////////
                //если сдесь сделать так то связь между ссылкой в стеке и реальными данными в куче будет разорвана 
                arr1 = null;
                ////////////////////////////////////////////

                arr1[0] = 1;
                GetInt(arr);
                Console. WriteLine(arr[0]);//arr1[0] == 5;
                Console.ReadLine();
            }

            static void GetInt(int[] arr)//сда копируется ССЫЛКА на массив arr1  
            {
                arr[0] = 5;//потому здесь мы отправляем значение по ССЫЛКЕ на массив arr1 цифру 5
            }
--

class Person
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Person p1 = new Person { Name = "Tom", Age = 23 };
            Person p2 = p1;//присваиваем двум обьектам один адрес в памяти присваивая p2 = p1

            p2.Name = "Alice";//В данном случае объекты p1 и p2 будут указывать на один и
            //тот же объект в памяти, поэтому изменения свойств в переменной p2 затронут
            //также и переменную p1, те изменив имя в обьектке класса Person p2 мы измним
            //его и в обьекте p1

            Console.WriteLine(p1.Name); // Alice

            Console.Read();
        }
    }
------------------------------------------
переменные этого типа пракаращают свое сущетсование когда обьект подвергается сборке мусора
если выйти из области видимости ссылочного типа удалится сслыка на этот тип но, память выделаная под этот тип все 
еще занята этим типом, пока не отработает сборщик мусора
------------------------------------------
Одно из отличий ссылочных типов от типов значений состоит в том, что переменные ссылочных типов могут принимать 
значение null. Например:

object o = null;
string s = null;

Если переменным ссылочного типа не присваивается значение, то им дается значение по умолчанию - значение null.
 Фактически оно говорит об отстутсвии значения как такового.



==========================================

--Инициализация переменной--
------------------------------------------
int i = 10;        //производим инициализацию перменной (задаем целочисленной переменной i значение 10)
char symbol = 'Z';   // инициализируем переменную symbol буквенным значением Z
float f = 15.7F;   // переменная f инициализируется числовым значением 15.7

int x = 5, y = 10, z = 12;    // инициализируем несколько переменных одного типа

Задать значение переменной можно, в частности, с помощью оператора присваивания. 
Кроме того, задать начальное значение переменной можно при ее объявлении. 
Для этого после имени переменной указывается знак равенства (=) и присваиваемое значение. 
Если две или более переменные одного и того же типа объявляются списком, разделяемым запятыми, 
то этим переменным можно задать, например, начальное значение.

Переменные, являющиеся полями класса или структуры, если не инициализированы явно,
по умолчанию обнуляются (null или 0 )в момент создания.

--обьявление-- --объявление перменной--
------------------------------------------
int i;//обьявление перменной 

Объявить можно переменную любого действительного типа. Важно подчеркнуть, что возможности 
переменной определяются ее типом. Например, переменную типа bool нельзя использовать для
хранения числовых значений с плавающей точкой. Кроме того, тип переменной нельзя изменять
 в течение срока ее существования. В частности, переменную типа int нельзя преобразовать
  в переменную типа char.

Все переменные в C# должны быть объявлены до их применения. Это нужно для того, чтобы 
уведомить компилятор о типе данных, хранящихся в переменной, прежде чем он попытается 
правильно скомпилировать любой оператор, в котором используется переменная. Это позволяет 
также осуществлять строгий контроль типов в C#.
инициализация перменной

==========================================

--Классы ссылки экземпляры--

------------------------------------------ 
поля или перменные класса определяют состояние класса, а методы поведение будущего обьекта

       обьект (new) это сущность времени выполнения программы, он запрашивает область памяти под выполнение класса,
        ссылка на обьект, облать в управляемой куче ктороая хранит в себе методы

       экземпляр область в памяти кторая хранит в себе нестатические поля

       ссылка - это первый байт в памяти из той области где начинается обьект или адрес в памяти первого байта блока 
       загловка

       задача конструктора без параметров(по муолчанию) проинициализировать все поля класса знаениями по мумолчанию

сильная ссылка MyClass class = new MyClass() - имеется перменная солжерэащся в себе ссылку, по этой ссылке мы можем 
обращатся к члену этого экземпляра/объекта class.Method()

 слабая ссылка new MyClass().Method можно обратится к члену экземпляра но только один раз тк каждый раз при обращении
 мы работаем с новым экземплярок класса MyClass

 ComCommunication Meter = new ComCommunication(); это вызов конструктора
------------------------------------------
класс может иметь модификатор доступа private но если класс вложенный по отношению к другому классу.
 А если класс определен в пространстве имен, то не может;

namespace numbers
{
  private class one//недопустимо
  {

  }
  class two
  {
    private class three//допустимо
    {

    }
    private class five : four//допустимо
    {

    }
  }
  class four internal 
  {

  }
}
 
------------------------------------------
так можно вызвать экземпляры класса без дополнительной функциональности
 class Counter
    {
        public int Value;
        public int Value2 { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Counter c1 = new Counter { Value = 23, Value2 = 2};//это аналогично нижней констркции
            c1.Value = 32;//ээто
            c1.Value2 = 3;//и это аналогично верхней конструкции

            Counter c2 = new Counter { Value = 45 };
            c2.Value = 54;
        }
    }

==========================================



--Структуры--struct--

------------------------------------------

Структуры синтаксически очень похожи на классы, Так же как и классы, структуры могут иметь поля,
методы и конструкторы. НО существует принципиальное отличие, которое заключается в том,
что класс – является ССЫЛОЧНЫМ типом (reference type), а структуры – ЗНАЧИМЫМ типом (value type)
Следовательно, классы всегда создаются в так называемой “куче” (heap), а структуры создаются в стеке (stack).
------------------------------------------

1) Переменные структуры хранят не ссылку на объект, а сам объект (у вас это не очевидно, хотя и можно догадаться). 
То есть это значимый тип, а не ссылочный.

2) Значит если одной структуре присвоить другую, то Скопируются Все Поля одной структуры в другую,
 а не ссылка, как было бы с классами.

3) Т.к. переменная хранит сами данные, а не ссылку на них, то доступ к полям осуществляется быстрее и есть 
некоторая экономия памяти.

4) Структуры не поддерживают наследование(именованое)

------------------------------------------
два правила старктур
Первое правило структуры: Всегда все переменные должны быть инициализированы.
В классах Вы можете инициализировать значение полей непосредственно при их объявлении.
 В структурах такого сделать нельзя, и поэтому данный код вызовет ошибку при компиляции. Поэтому:
Второе правило структуры: Нельзя инициализировать переменные в том месте, где они объявляются.

struct Time
   {
      //private int hours = 10; так делать НЕЛЬЗЯ 
      private int hours;//так делать можно
      private int minutes;//так делать можно
      private int seconds;//так делать можно    
...


------------------------------------------
 структуру тоже можно передать по ссылке, используя модификаторы out и ref.


------------------------------------------
Мы выяснили, что все встроенные типы значений задаются структурами, например, числовые типы int, long, float 
определены структурами System.Int32, System.Int64 и System.Single соответственно.
------------------------------------------
Структуры не могут содержать явных конструкторов без параметров


struct Time
   {
       public int hours, minutes, seconds;
       public string age;
       //public Time() так дельать НЕЛЬЗЯ
       //Структуры не могут содержать явных конструкторов без параметров
       //{
       //    this.hours = 50;
       //    this.minutes = 20;
       //    this.seconds = 30;
       //    this.age = "22";
       //}
       ...

struct Time
    {
        public int Hours, Minutes, Seconds;
        public string age;
        public Time(int hours, int minutes, int seconds, string age)//мождно делать так
        {
            Hours = hours;
            Minutes = minutes;
            Seconds = seconds;
            this.age = age;
        }
    ...
------------------------------------------
пример использовния структур возврат из метода

  struct Time
    {
        public int hours, minutes, seconds;

        public int height;
        public string age;

        public void Disp()
        {
            Console.WriteLine($"{hours} {minutes} {seconds}");
        }
    }

    class HA<T>
    {
        public T haha;
    }
    class Program
    {
        static void Main(string[] args)
        {
            Time t = geTime("10", "12", "19");
            t.Disp();//10 12 19

            Time tt = geTime("15", "20", "30");
            HA<Time> ha = new HA<Time>();
            ha.haha = tt;
            ha.haha.Disp();//15 20 30
        }

        static Time geTime(string h, string m, string s)//сдесь мы возвращаем из метода структура, 
        //так можно добится возвращения не одного знгачения а сразу несокльких входящих в стурктуру
        {
            return new Time()
            {
                hours = int.Parse(h),
                minutes = int.Parse(m),
                seconds = int.Parse(s)//если не присовить значение одному из полей структры 
                //оно будет иметь дефолтное значение, для значимой ерменной 0, для ссылочной null
            };
        }
    }

------------------------------------------
В отличие от классов, использование публичных полей в структурах в большинстве случаев не рекомендуется,
потому что не существует способа контролирования значений в них. Например, кто-либо может установить значение 
минут или секунд более 60.

struct Time
   {
      //private int hours = 10; так делать НЕЛЬЗЯ 
      private int hours, minutes, seconds;
      public Time(int hh, int mm, int ss)
      {
         hours = hh % 24;
         minutes = mm % 60;
         seconds = ss % 60;
      }
    //так делать нельзя тк Структуры не могут содержать явных конструкторов без параметров
            //public Time()
        //{
        //    hours = 7;
        //    minutes = 4;
        //    seconds = 0;
        //}
      public int Hours()
      {
         return hours;
      }
   }
   class Program
   {
      static void Main()
      {
         Time t = new Time(30,69,59);
         Console.WriteLine(t.Hours());
         Console.ReadKey();
      }
   }

В качестве альтернативы переменные типа структур можно создавать с применением ключевого слова new языка С#,
 что приводит к вызову стандартного конструктора структуры. По определению стандартный конструктор не принимает
  аргументов. Преимущество вызова стандартного конструктора структуры в том, что каждое поле данных
   автоматически получает свое стандартное значение:

struct Point {

// Поля структуры, 
public int X; public int Y;

public void Display () 
{
Console.WriteLine("X = {0},Y = {1}", X, Y);
...


Point pi = new Point () ;// Установить для всех полей стандартные значения, используя стандартный конструктор.
pi.Display();// Выводит X=0,Y=0
==========================================

--модификаторы доступа--
------------------------------------------
public: публичный, общедоступный класс или член класса. Такой член класса доступен из любого места в коде, а также из 
других программ и сборок.;

private: закрытый класс или член класса. Представляет полную противоположность модификатору public. 
Такой закрытый класс или член класса доступен только из кода в том же классе или контексте.

protected: такой член класса доступен из любого места в текущем классе или в производных классах.
При этом производные классы могут располагаться в других сборках.

internal: класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке,
 однако он недоступен для других программ и сборок (как в случае с модификатором public).

protected internal: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны 
из текущей сборки и из производных классов.

private protected: такой член класса доступен из любого места в текущем классе или в производных классах, которые 
определены в той же сборке.
------------------------------------------
класс может иметь модификатор доступа private, НО только если это класс вложенный по отношению к другому классу.
А если класс определен в пространстве имен, то не может;

namespace numbers
{
	private class one//недопустимо
	{

	}
	class two
	{
		private class three//допустимо
		{

		}
		private class five : four//допустимо
		{

		}
	}
	class four internal 
	{

	}
}
==========================================


--null  и операторы --

------------------------------------------
Если переменным ссылочного типа не присваивается значение, то им дается значение по умолчанию - значение null. 
Фактически оно говорит об отстутсвии значения как такового, это как яярлык на рабчем столе кторрый ссылаетя на 
несуществующий файл, или что нету ссылки на данные в управляемой куче  
те когда мы обявли перменную ссылочного типа
{
   int[]a;  //a = null;
}
мы разместили на стеке некий ярлык ктороый храни ссылку на данные ктороы распологаются в куче - это и ест null

Одно из отличий ссылочных типов от типов значений состоит в том, что переменные ссылочных типов могут принимать
 значение null. Например:

object o = null;
string s = null;

? для ссылочных типов
------------------------------------------

Action s = null;             

var handler = s;

if (s != null)//здесь происходит проверка на null
{
    s(…);
}

s?.Invoke();//эта запись аналогична вышенаписаной

------------------------------------------
    class User
{
    public Phone Phone { get; set; }
}
 
class Phone
{
    public Company Company { get; set; }
}
 
class Company
{
    public string Name { get; set; }
}            
В данном случае свойство Phone не определено, будет по умолчанию иметь значение null. 
Поэтому мы столкнемся с исключением NullReferenceException.
 Чтобы избежать этой ошибки мы могли бы использовать условную конструкцию для проверки на null

User user = new User();
 
if(user!=null)
{
    if(user.Phone!=null)
    {
        if (user.Phone.Company != null)
        {
            string companyName = user.Phone.Company.Name;
            Console.WriteLine(companyName);
        }
    }
}
//или сокращенно 
//эта записа аналогична вышенаписаной
  string companyName = user?.Phone?.Company?.Name;
    if (companyName != null)
    {
        Console.WriteLine(companyName);
    }
//или сокращенно 
//эта записа аналогична вышенаписаной
string companyName = user?.Phone?.Company?.Name;
        if (string.IsNullOrEmpty(companyName))
        {
            Console.WriteLine(companyName);
        }
------------------------------------------
null Строки

Из-за того, что строки это ссылочный тип, их идентификаторы тоже могут быть равны null. 
Мы часто хотим защитить свою программу от ошибок, связанных с null-строками. Это можно сделать
 с помощью методов IsNullOrEmpty(возвращает true если string пуста или string == null) 
 или string.IsNullOrWhiteSpace(string)(возвращает true если string пуста или string == null или string == "\t" или 
 string == " " те строка ). 
 Также можно просто проверить строку на равенство литералу null. 
 Достоинство этого метода в том, что она работает быстрее, если не требуется проверка на длину строки.

--nullable для значимых типов
------------------------------------------
Значение null по умолчанию могут принимать только объекты ссылочных типов. 
Однако в различных ситуациях бывает удобно, чтобы объекты числовых типов данных имели значение null,
то есть были бы не определены

Для этого надо использовать знак вопроса ? после типа значений. Например:
Nullable<int> z = null;//эта запись аналогична нижней
int? z = null;//делается для того чтобы значимые типа могли хранить null
//в случае если вдруг не пришлось присваивать null в эту перменную она останется 
//обычной int
bool? enabled = null;

int? i = null;//делается для того чтобы значимые типа могли хранить null
//в случае если вдруг не пришлось присваивать null в эту перменную она останется 
//обфчной int

дополнительные фнункиции которые поялвются при обявлении пременной nullable

Console.WriteLine(i == null);

Console.WriteLine(i.HasValue);//bool есть ли у этой перменной реальное занчение i == null будет возвращено false

Console.WriteLine(i.GetValueOrDefault());//GetValueOrDefault досутпен только в сулчае если перменная является nullable            
//если в преременной i было присвоено значние, то результатом этой операции будет это самое значение 
//если же нет то будет возрващено занчение default для того типа перменной к кторой проверяемая перменная относится
//в данном случае будет возвращено 0 

Console.WriteLine(i.GetValueOrDefault(3));//аналогично верхней записи за исключением того что вместа default
//в случае если проверямеая пременная ббудет i == null , то будет возраащено 3

Console.WriteLine(i??55);//если перменная i == null то он вернет занчение из правой части те 55
//если же значение i != null (например 10)то он вернет ээто значение те 10
//обычно используется этот метод
           
Console.WriteLine(i.Value);//реальные данные которые хранятся в поле i , если i == null то тут будет ошибка

Console.WriteLine(i); // есл сделать так то вместо ошикбки на консоль выведется путсая строка 

Оператор ?? возвращает левый операнд, если этот операнд не равен null. Иначе возвращается правый операнд.
object x = null;
object y = x ?? 100;  // равно 100, так как x равен null
работает только с переменным ссылочного типа

==========================================

--динамические структуры данных--
------------------------------------------

Array.Resize

==========================================


--Пространства имен, псевдонимы и статический импорт--

------------------------------------------
Пространства имен
------------------------------------------
Но чтобы задействовать классы из других пространств имен, эти пространства надо подключить с помощью директивы using, 
например using System;
Здесь подключается пространство имен System, в котором определен класс Console. Иначе нам бы пришлось писать полный 
путь к классу: System.Console.WriteLine("hello");

Пространства имен могут быть определены внутри других пространств
В этом случае для подключения пространства указывается его полный путь с учетом внешних пространств имен например 
using HelloApp.AccountSpace;

псевдонимы
------------------------------------------
Для различных классов мы можем использовать псевдонимы. Затем в программе вместо названия класса используется 
его псевдоним. 
Например, для вывода строки на экран применяется метод Console.WriteLine(). Но теперь зададим для класса Console 
псевдоним:

using printer = System.Console;
class Program
{
    static void Main(string[] args)
    { 
        printer.WriteLine("Hello from C#");
        printer.Read();
    }
}
Указываем, что псевдонимом для класса System.Console будет имя printer.
 Это выражение не имеет ничего общего с подключением пространств имен в начале файла, хотя и использует оператор using.
 
статический импорт
------------------------------------------
Выражение using static подключает в программу все статические методы и свойства, а также константы. 
И после этого мы можем не указывать название класса при вызове метода.

Также в C# имеется возможность импорта функциональности классов. Например, импортируем возможности класса Console:

using static System.Console;

            WriteLine("Hello from C# 8.0");//в этом случае можно опусттить вызов тсатического метода консаль

            Read();
    
==========================================


--конструктор-
------------------------------------------
Каждый раз, когда создается класс или структура, вызывается конструктор.
Класс или структура может иметь несколько конструкторов, принимающих различные аргументы. 
конструкторы позволяют программисту задавать значения по умолчанию, ограничивать число установок и писать код, 
который является гибким и удобным для чтения.

Каждый раз, когда создается класс или структура, вызывается конструктор. Конструкторы 
имеют имя, совпадающее с именем класса или структуры, и обычно инициализируют члены данных нового объекта.

public class Taxi
{
    public bool IsInitialized;

    public Taxi()//класс с именем Taxi определяется с помощью простого конструктора без параметров
    {
        IsInitialized = true;
    }
}

class TestTaxi
{
    static void Main()
    {
        Taxi t = new Taxi();//Конструктор Taxi вызывается оператором new сразу после того, как новому объекту будет выделена память.
        Console.WriteLine(t.IsInitialized);//true
    }
}
------------------------------------------
конструкторы с параметрами

Оба класса и structs могут определять конструкторы, принимающие параметры. 
Конструкторы, принимающие параметры, необходимо вызывать с помощью оператора new или base. Классы и structs могут определять 
также несколько конструкторов; для определения конструктора без параметров ни один их них не требуется. 

public class Employee
{
    public int Salary;

    public Employee() { }

    public Employee(int annualSalary)
    {
        Salary = annualSalary;
    }

    public Employee(int weeklySalary, int numberOfWeeks)
    {
        Salary = weeklySalary * numberOfWeeks;
    }
}

------------------------------------------
констуркторы с парметрами в случае наследования, слово base
Ключевое слово base используется для доступа к членам базового из производного класса

если в базовом классе не определен конструктор по умолчанию без параметров, 
а только конструкторы с параметрами (как в случае с базовым классом Person), 
то в производном классе мы обязательно должны вызвать один из этих конструкторов через ключевое слово base.

class Person

{
    public string Name { get; set; }
    public Person(string name)
    {
        Name = name;
    }
    public void DisplayName()
    {
        Console.WriteLine(Name);
    }
}

class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company) : base(name)//base задаем конструктор базового класса, 
    //вызываемый при создании экземпляров производного класса.
    {
        Company = company;
    }
}
------------------------------------------
закрытые конситуркторы 

Создание экземпляров класса можно запретить, сделав конструктор закрытым, следующим образом:

class NLog
{
    // Private Constructor:
    private NLog() { }

    public static double e = Math.E;  //2.71828...
}
------------------------------------------
констурктор по умолчанию

Если не предоставить конструктор для класса, C# создаст конструктор по умолчанию, который создает экземпляр объекта и задает 
переменным-членам значения по умолчанию. Если не предоставить конструктор для структуры, C# будет использовать неявный конструктор
без параметров, чтобы автоматически инициализировать каждое поле значением по умолчанию. 

------------------------------------------

------------------------------------------
при наследовании 



==========================================
--свойства get set свойства--
------------------------------------------
причин рассматривать использование сыойст помимо аргумента инкапсуляции и облегчения будущих изменений.
Инкапсуляция поведения, связанного с получением или настройкой свойства, - это позволяет добавить дополнительную функциональность (например, проверку) позже.

Скрытие внутреннего представления свойства при экспонировании свойства с использованием альтернативного представления.

Изоляция вашего открытого интерфейса от изменения - позволяя публичному интерфейсу оставаться постоянным, а реализация меняется, не затрагивая существующих потребителей.

Управление семантикой объекта управления временем жизни и памяти (удаление) - особенно важно в средах с неконтролируемой памятью (например, С++ или Objective-C).

Предоставление точки перехвата отладки при изменении свойства во время выполнения - отладка, когда и где свойство, измененное на конкретное значение, может быть довольно сложно без этого на некоторых языках.

Взаимодействие с библиотеками, которые предназначены для работы с атрибутами getter/seters - Mocking, Serialization и WPF, приходят на ум.

Предоставление наследникам возможности изменять семантику поведения объекта и подвергается переопределению методов getter/setter.

Разрешить использование getter/setter в качестве лямбда-выражений, а не значений.

Getters и seters могут разрешать разные уровни доступа - например, get может быть общедоступным, но набор может быть защищен.

        private int x;

        public void SetX(int x)
        {
            if (x > 5)
            {
                this.x = 5;
                return;
            }

            this.x = x;
        }
        public int GetX()
        {
            return X;
        }
//вышенпаисаное аналогично ниже написаному()
////////////////////////////////////////////////
        private int y;

        public int Y
        {
            get { return y; }//GetX()
            set//SetX(int x)
            {
                if (value > 5)
                {
                    y = 5;
                    return;
                }

                y = value;
            }
        }

------------------------------------------

Автосвойствам можно присвоить значения по умолчанию (инициализация автосвойств) и модификаторы доступа:
чтобы вызвать автосвойства нужно написать prop => тип перменной => Tab => имя переменной
    public string Name { get; set; } = "Tom";
    public int Age { get; set; } = 23;

     public string Name { private set; get;}
    public Person(string n)
------------------------------------------
1. Модификатор для блока set или get можно установить, если свойство имеет оба блока (и set, и get)

2. Только один блок set или get может иметь модификатор доступа, но не оба сразу

3. Модификатор доступа блока set или get должен быть более ограничивающим, чем модификатор доступа свойства. 
Например, если свойство имеет модификатор public, то блок set/get может иметь только модификаторы protected internal, 
internal, protected, private

Начну с 3,
Модификатор должен быть более ограничивающий потому, что: 1.Нет смысла делать такой же модификатор,
как у свойства потому что он уже есть и get-set им пользуются. 2. Невозможно и нельзя сделать модификатор более 
расширяющим, потому что это противоречит идеи инкапсуляции.

Теперь 2,
Как сказано - только 1 метод (get или set) может иметь модификатор, значит нужно понять, что не так в случае если оба 
имеют модификаторы, а вот что - допустим у нас свойство модификации public и мы поставили модификатор protected на оба:
 get, set и это означает, что эти методы будут доступны в текущем классе и классах-наследниках, 
 и проблема в том что если класс Program, в методе main мы создали объект от того класса, при вызове свойства Name 
 оно будет obsolete, иными словами функционал недоступен!, хотя оно же public, и тут возникает ошибка! 
 Поэтому опять таки исходя из идеи инкапсуляции public - должно быть доступно везде! А мы там поставили на оба protected,
  непорядок! Не должно быть так! Все что public - должно быть доступным везде и всюду!Поэтому из этого исходит пункт, 
  что только один может иметь модификацию, чтобы другой мог всегда быть использован!

Теперь 1,
Здесь мысль такая же, как и в предидущем пункте - Свойство должно быть доступно! 
Если поставить модификатор в случае когда есть только get или set (один из них), то получится опять нарушение
идеи инкапсуляции! Поэтому при присутствии второго, на который не будет вешаться модификатор, 
все будет соответствовать идеи!

------------------------------------------
Не лишним будет подчеркнуть, что внутри блоков get{ } и set { } можно указывать процедуры и функции. И это замечательно,
 ведь благодаря этому, на любое поле класса можно повесить процедуру, которая будет запускаться каждый раз,
  когда значение переменной где-то изменяется.
private bool fullyLoaded = false;
public bool onfullyLoaded
{
get { return fullyLoaded; }
set
{
fullyLoaded = value;
OnTestChanged();
}
}

void OnTestChanged()
{
//Ваш индусский код
}

сокращенная записаь свойства
------------------------------------------
private string name;
     
    // эквивалентно public string Name { get { return name; } }
    public string Name => name;

чтобы присовить значение readonly свойству нужно использовать конструктор класса

  public string Name { get; }// readonly свойство

 public human(string name)//рабоает как с любой  reaadonly перменной
        {
            Name = name;
        }

  human h = new human("Max");
  Console.WriteLine($"{h.Name}");//Max

==========================================


--static модификатор--
------------------------------------------

На уровне памяти для статических полей будет создаваться участок в памяти, который будет общим для всех объектов
(экземпляров) класса.


 static-методы не могут использовать ссылку this и напрямую (т.е. без указания конкретного объекта класса) 
 обращаться к нестатическим членам класса, а только через объект класса.

  public static bool ValidatePorts(this ComSettings view)//здесь создается объект класса через который и пойдет 
  //обращение к нестаическим членам класса
        {
        	//если вместо viev написать this выскочит исключение
            if (view.ChannelComMeter.SelectedItem == view.ChannelComSupply.SelectedItem)
            {
                return false;
            }

            return true;
        }

статический конструктор  необходимо создавать, если вам надо выполнять некоторые действия при первом создании 
объекта этого класса.
	Как правило, в статическом конструкторе инициализируются общие для всех объектов ресурсы.
	Приведу практический пример: есть класс, через который взаимодействуем с базой данных. И нам надо, 
	чтобы до создания первого объекта класса в базе данных уже были некоторые объекты. 
	В статическом конструкторе этого класса тогда можно проверить объекты в бд и добавить их при необходимости.

Статический конструктор вызывается перед доступом к любому члену класса.

class Account
    {
        // public static string name = "Ivan";
        public static string name;
        static Account()
        {
            name = "Ivan"; 
        }
    }
    
        static void Main(string[] args)
        {
            Console.WriteLine(Account.name);// Обращение к полю по имени класса и тут срабатывает конструктор
        }
    
    все объекты класса, в том числе и первый, создаются с помощью нестатического конструктора, 
    статический конструктор не создает объект касса, более того явным образом не вызывается. Он вызывается системой,
     когда вы создаете с помощью нестатического конструктора первый объект класса
==========================================

--перегрузка методов--
------------------------------------------

метод можно перегрузить этими способоами
Определить версию метода с другим количеством параметров
Определить версию метода с другим типами параметров
Определить версию метода, где порядок параметров будет иным
Изменить модификаторы параметров

И в языке C# мы можем создавать в классе несколько методов с одним и тем же именем, но разной сигнатурой. Что такое сигнатура? Сигнатура складывается из следующих аспектов:

Имя метода
Количество параметров
Типы параметров
Порядок параметров
Модификаторы параметров

Но названия параметров в сигнатуру НЕ входят. Например, возьмем следующий метод:

public int Sum(int x, int y) 
{ 
    return x + y;
}
У данного метода сигнатура будет выглядеть так: Sum(int, int)

И перегрузка метода как раз заключается в том, что методы имеют разную сигнатуру, в которой совпадает только название метода. То есть методы должны отличаться по:

Количеству параметров
Типу параметров
Порядку параметров
Модификаторам параметров

Здесь представлены четыре разных версии метода Add, то есть определены четыре перегрузки данного метода.
То есть мы можем представить сигнатуры данных методов следующим образом
class Calculator
{
    public void Add(int a, int b)
    {
        int result = a + b;
        Console.WriteLine($"Result is {result}");
    }
    public void Add(int a, int b, int c)
    {
        int result = a + b + c;
        Console.WriteLine($"Result is {result}");
    }
    public int Add(int a, int b, int c, int d)
    {
        int result = a + b + c + d;
        Console.WriteLine($"Result is {result}");
        return result;
    }
    public void Add(double a, double b)
    {
        double result = a + b;
        Console.WriteLine($"Result is {result}");
    }
}

==========================================

--перегрузка операторов--
------------------------------------------

Counter c1 = new Counter { Value = 23 };
Counter c2 = new Counter { Value = 45 };
операция сравнения, и операция сложения для объектов Counter не доступны. 
Эти операции могут использоваться для ряда примитивных типов. Например, по умолчанию мы можем складывать числовые 
значения, но как складывать объекты комплексных типов - классов и структур компилятор не знает. 
И для этого нам надо выполнить перегрузку нужных нам операторов.

bool result = c1 > c2;
Counter c3 = c1 + c2;

Перегрузка операторов заключается в определении в классе, для объектов которого мы хотим определить оператор,
 специального метода:Этот метод должен иметь модификаторы public static, так как перегружаемый оператор будет
  использоваться для всех объектов данного класса.
public static возвращаемый_тип operator оператор(параметры)
{  }


class Counter
{
    public int Value { get; set; }
         
    public static Counter operator +(Counter c1, Counter c2)
    {
        return new Counter { Value = c1.Value + c2.Value };
    }
   //Если мы переопределяем одну из этих операций сравнения, то мы также должны переопределить вторую из этих операций
    public static bool operator >(Counter c1, Counter c2)
    {
        return c1.Value > c2.Value;
    }
    public static bool operator <(Counter c1, Counter c2)
    {
        return c1.Value < c2.Value;
    }
}
 static void Main(string[] args)
  {
bool result = c1 > c2;
Counter c3 = c1 + c2;
  }      
------------------------------------------
Стоит отметить, что так как по сути определение оператора представляет собой метод, то этот метод мы также можем 
перегрузить, то есть создать для него еще одну версию.
 Например, добавим в класс Counter еще один оператор:

public static int operator +(Counter c1, int val)
{
    return c1.Value + val;
}
------------------------------------------
при перегрузке не должны изменяться те объекты, которые передаются в оператор через параметры.

public static Counter operator ++(Counter c1)
{
	//это неправильнео написание тк оператор не должен менять сови параметры
    c1.Value += 10;
    return c1;
}

И более корректная перегрузка оператора инкремента будет выглядеть так:

public static Counter operator ++(Counter c1)
{
    return new Counter { Value = c1.Value + 10 };
}

==========================================

--Const и Readonly--
------------------------------------------

const Константы
------------------------------------------
const неявно static и его Невозможно изменить где-либо.

Итак, если вы уверены, что значение константы не изменится, используйте const.
public const int CM_IN_A_METER = 100;

Константы по умолчанию статичны.
Они должны иметь значение во время компиляции (вы можете иметь, например, 3,14 * 2, но не можете вызывать методы)
Может быть объявлено внутри функций
Скопируются в каждую сборку, которая их использует (каждая сборка получает локальную копию значений)
Может использоваться в атрибутах;

readonly
------------------------------------------
Но если у вас есть константа, которая может измениться (например, точность w.r.t.).. или если у вас есть сомнения,
 используйте readonly.

public readonly float PI = 3.14;


Существует небольшая магия с readonly. Поле readonly может быть установлено несколько раз внутри конструктора (-ов).
 Даже если значение задано в двух разных цепных конструкторах, оно все же разрешено.

public class Sample {
    private readonly string ro;

    public Sample() {
        ro = "set";
    }

    public Sample(string value) : this() {
        ro = value; // this works even though it was set in the no-arg ctor
    }
}

Еще одно значение: значения readonly могут быть изменены с помощью "коварного" кода через отражение.

var fi = this.GetType().BaseType.GetField("_someField", BindingFlags.Instance | BindingFlags.NonPublic); 
fi.SetValue(this, 1);

Поля экземпляров Readonly
Должно быть установлено значение, по истечении времени конструктор
Оцениваются при создании экземпляра
------------------------------------------
Статические поля readonly
Оцениваются, когда выполнение кода попадает в ссылку на класс (когда создается новый экземпляр или выполняется 
    статический метод) должно быть оцененное значение к моменту завершения статического конструктора
Не рекомендуется помещать ThreadStaticAttribute в эти (статические конструкторы будут выполняться только в 
    одном потоке и будут 
	устанавливать значение для его потока; все остальные потоки будут иметь это значение неинициализированным)
==========================================

--индексаторы--

------------------------------------------
индексаторы позволяют индексировть обьекты и обращатся к даным по индексу. те мы можем работать с обьектами как 
с массивами. 
в таком виде индексатор используется если нужнро скажем написать массив с особеными свойствами

возвращаемый_тип this [Тип параметр1, ...]
{
    get{...}
    set{...}
}
------------------------------------------
 class Person
    {
        public string Name { get; set; }
    }
    class People
    {
        Person[] data = new Person[5];
        //индексатор
        public Person this[int index]// в отличии от свойств инджексатор не имеет названия вместо него идет ключевое 
        //слово this 
        {
            //объекты Person хранятся в классе в массиве data, для получения их по индексу в индексаторе определен 
            //блок get
            get
            {
                return data[index];
            }
            //получаем через параметр value переданный объект Person и сохраняем его в массив по индексу
            set
            {
                data[index] = value;
            }
        }
    }

People p = new People();

            //После этого мы можем работать с объектом People как с набором объектов Person
            p[0] = new Person { Name = "X4X" };
            p[1] = new Person { Name = "X3X" };

            Console.WriteLine(p[0]?.Name);
            Console.WriteLine(p[1]?.Name);

------------------------------------------
Также индексатор может принимать несколько параметров.

 class Matrix
    {
        private int[,] numbers = new int[,] {
            { 1, 9, 4 },
            { 8, 3, 6 }, 
            { 3, 4, 6 }};// хранилище определено в виде двухмерного массива или матрицы
        public int this[int i, int j]  
        {
            get
            {
                return numbers[i, j];
            }
            set
            {
                numbers[i, j] = value;
            }
        }
    }


    class Program
    {


        static void Main(string[] args)
        {
          Matrix mt = new Matrix();
          mt[0, 2] = 99;
          Console.WriteLine(mt[0, 1]);
          Console.WriteLine(mt[0,2]);
        }

------------------------------------------
Как и в свойствах, в индексаторах можно опускать блок get или set, если в них нет необходимости.

 private int[,] numbers = new int[,] { { 1, 2, 4}, { 2, 3, 6 }, { 3, 4, 8 } };
    public int this[int i, int j]
    {
        get// делаем индексатор доступным только для чтения
        {
            return numbers[i,j];
        }
    }
------------------------------------------
перегрузка индексаторов
Подобно методам индексаторы можно перегружать. В этом случае также индексаторы должны отличаться по количеству, 
типу или порядку используемых параметров.

 class Person
    {
        public string Name;
        public int Age;
    }
    class People
    {
        Person[] data;
        public People()
        {
            data = new Person[5];
        }
        public Person this[int index]//перывая версия получает и устанавливает объект Person по индексу
        {
            get
            {
                return data[index];
            }
            set
            {
                data[index] = value;
            }
        }
        public Person this[string name]// вторая - только получае объект Person по его имени
        {
            get
            {
                Person person = null;
                foreach (var p in data)
                {
                    if (p?.Name.ToLower() == name.ToLower())
                    {
                        person = p;
                        break;
                    }
                }
                return person;
            }
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            People people = new People();

            people[0] = new Person { Name = "Tom" };//использование set из первая версия
            people[1] = new Person { Name = "Bob" };//использование set из первая версия
            Console.WriteLine(people[0].Name);//использование get из первая версия

            Console.WriteLine(people["bob"]?.Name);//использование get из второй версия
        }
    }

==========================================

--ref--out--in--
------------------------------------------
передача по значению 
При передаче по значению метод получает не саму переменную, а ее копию

class Program
{
    static void Main(string[] args)
    {
        int a = 5;
        Console.WriteLine($"Начальное значение переменной a = {a}");
 
        
        
        IncrementVal(a);//Передача переменных по значению
        //После выполнения этого кода по-прежнему a = 5, так как мы передали лишь ее копию

        Console.WriteLine($"Переменная a после передачи по значению равна = {a}");
        Console.ReadKey();
    }
    // передача по значению
    static void IncrementVal(int x)
    {
        x++;
        Console.WriteLine($"IncrementVal: {x}");
    }
}

------------------------------------------
--ref передача по ссылке 
А при передаче параметра по ссылке метод получает адрес переменной в памяти


class Program
{
    static void Main(string[] args)
    {
        int a = 5;//после отработвашего метода IncrementRef значитне этой прменоной изменится на 10 
        //тк мы предали значние в метод поссылке
        int y = 4;//после отработвашего метода IncrementRef значитне этой прменоной изменится на 10 
        //тк мы предали значние в метод поссылке
        Console.WriteLine($"Начальное значение переменной a  = {a}");//тут будет 5 
        Console.WriteLine($"Начальное значение переменной a  = {y}");//тут будет 4

        EdtionVal(a, y)//Передача переменных по значению
        //После выполнения этого кода a = 5, так как мы передали в метод НЕ САМУ переменную а только ее КОПИЮ

        Console.WriteLine($"Переменная a после передачи ссылке равна = {a}");//после отработвашего метода 
        //EdtionVal значитне этой прменоной вне этого метода НЕ изменится те будет равно 5
        Console.WriteLine($"Переменная a после передачи ссылке равна = {y}");//после отработвашего метода 
        //EdtionVal значитне этой прменоной вне этого метода НЕ изменится те будет равно 4

         IncrementRef(ref a, ref y);;//Передача переменных по ссылке
        //После выполнения этого кода a = 6, так как мы передали в метод САМУ переменную

        Console.WriteLine($"Переменная a после передачи ссылке равна = {a}");//после отработвашего метода 
        //IncrementRef значитне этой прменоной изменится на 6 тк мы предали значние в метод поссылке
        Console.WriteLine($"Переменная a после передачи ссылке равна = {y}");//после отработвашего метода 
        //IncrementRef значитне этой прменоной изменится на 6 тк мы предали значние в метод поссылке
        Console.ReadKey();
    }

еще один вариант ref 

    // передача по ссылке
    static void IncrementRef(ref int x, ref y)
    {
        x++;//после того как отработает метод в мейне значние здесь изменится на 5 
        //и потом прибавится еще 1 те будет 6
        y += x;//тут будет 10
        Console.WriteLine(y);//тут будет 10
        Console.WriteLine($"IncrementRef: {x}");//тут будет 6
    }
     static void EdtionVal( int x, ref y)
    {
        x++;//после того как отработает метод в мейне значние здесь изменится на 5 
        //и потом прибавится еще 1 те будет 6
        y += x;//тут будет 10
        Console.WriteLine(y);//тут будет 10
        Console.WriteLine($"IncrementRef: {x}");//тут будет 6
    }
}

------------------------------------------
--out определение выходного параметра те результат возвращается не через оператор return, а через выходной параметр.

out передает парметр по ссылке те меняет САМУ переменную НО Не передает её значение!

Но параметры могут быть также выходными .методы, использующие такие параметры, обязательно должны присваивать 
им определенное значение. 

Использования подобных параметров состоит в том, что по сути мы можем вернуть из метода не один вариант,
а несколько.

если исползуется out мы обязаны в методе используешем этот вид перменных измениьт их иначе проект не скомпилируется

------------------------------------------
хорошим примером исопльзовани out является шаблон Try (например, float.TryParse).

public bool GetResult(string input, out float str)
{
    if (float.TryParse(input.Replace(".", ","), out str))
    {
        return true;
    }

    return false;
}

if (el.GetResult("12,5", out i))
{
    Console.WriteLine(i);//12,5
}
------------------------------------------
static void Main(string[] args)
    {
        int widthFigure = 10;
        int heightFigure = 5;
        int areaFigure = GetData(widthFigure, heightFigure);//здесь мы взовращаем одно занчение те число int
        Console.WriteLine(areaFigure);//значние будет 50

        int areaGihureTwo = 500; //значние здесь неважно тк оно пеопределится в методое GetDataTwo
        GetDataTwo(widthFigure, heightFigure,out int perimeterFigure, out areaFigure);//на выходе получаем 
        //наши перменнные perimeterFigure и areaFigure со значенимяи измененыыми в методе GetDataTwo

        Console.WriteLine($"perimeter figure {perimeterFigure}, area figure {areaFigure}");//вывод: 
        //perimeter figure 30, area figure 50
        Console.ReadLine();
    }
    static int GetData(int width,  int height)//в этом случае метод венет только одно значение 
    {
        return width * height;
    }
   
    static void GetDataTwo(int width, int height,out int perimeter,out int area) //если мы хотим вернунть несолкько значений
        //из метода то необходимо использовать out 
    {
        perimeter = (width + height) * 2;//если используется out необходим задать ему в метод значение

        area = width * height;//можно исользоватся сколько угдно выходныхх зщначний

        //return width * height; от такого возвращаемого значения можно избаавится и например
        //написать вмето него так
    }
}

-- 

static void Main(string[] args)
{
      int widthFigure = 10;
        int heightFigure = 5;
        string perimeter = "hjhj";//значние здесь неважно тк оно пеопределится при исользовании ref и out 
        string areas = "ghh";//значние здесь неважно тк оно пеопределится при исользовании ref и out 

        Console.WriteLine(perimeter + " " + areas);//вывод: hjhj ghh

        GetData(ref perimeter, ref areas);
        Console.WriteLine(perimeter + " " + areas);//вывод: 1000 2000

    GetDataTwo(widthFigure, heightFigure, out perimeter, out areas); //на выходе получаем 
        //наши перменнные perimeter и areas со значенимяи измененыыми в методе GetDataTwo
        Console.WriteLine($"perimeter figure {perimeter}, area figure {areas}");//вывод: perimeter figure 30, area figure 50

    Console.ReadLine();
    }

    static void GetData(ref string perimeter, ref string areas)
    {
        perimeter = "1000";
        areas = "2000";
    }

    static void GetDataTwo(int width, int height, out string perimeter, out string area)
    {
        var perim = (width + height) * 2;
        perimeter = perim.ToString();

        var areas = width * height;
        area = areas.ToString();
    }
}
------------------------------------------
--in входные параметры.
это так же пердача параметра по ссылке однако внутри метода его значение параметра нельзя будет изменить

static void GetData(in int x, int y, out int area, out int perim)
{
    // x = x + 10; нельзя изменить значение параметра x
    y = y + 10;
    area = x * y;
    perim = (x + y) * 2;
}

Почему параметр in передается по ссылке, обычно по ссылке мы передаем чтобы изменить значение 
в самой перменной а тут это сделать нельзя? 

Бывает, надо использовать ссылку при этом не меняя значение параметра. Сейчас объясню почему:
Когда ты передаёшь переменную в функцию НЕ по ссылке, она копируется, то есть занимает дополнительную память и дополнительно 
нагружает систему. Конечно, когда ты передаёшь малые объекты как число 5 или строку "я Ваня", такой способ передачи параметров 
мало на что повлияет. Но когда ты работаешь с большими объёмами данных (например, 3д объекты) которые не хочешь изменять 
по самым разным причинам, ты передаёшь только адрес к значению, тем самым лишний раз не напрягая программу и компьютер.
==========================================



--кортежи (tuple)--
------------------------------------------
Кортежи предоставляют удобный способ для работы с набором значений это как бы папка с несколькими файлами в ней
Кортежи - это значения, поэтому они копируются по значению, а не по ссылке.
Анонимные типы и кортежи используются, когда нет значения дизайна, и все, что вам нужно, - это легкий объект передачи данных (DTO) для перемещения информации.

кортежи исопльзуются:

Для представления одного набора данных. Например, кортеж может представлять запись базы данных, 
а ее компоненты могут представлять отдельные поля записи.

Для обеспечения простого доступа к набору данных и его манипуляции.

Для получения нескольких значений из метода без использования out параметров (в C#) или ByRef параметров (в Visual Basic).

Передача нескольких значений в метод через один параметр. Например, Thread.Start(Object) метод имеет один параметр, который 
позволяет указать одно значение для метода, выполняемого потоком во время запуска. При указании Tuple<T1,T2,T3> 
объекта в качестве аргумента метода можно указать подпрограммы запуска потока с тремя элементами данных.

------------------------------------------
var tuple = (5, 10);
В данном случае определен кортеж tuple, который имеет два значения: 
5 и 10. В дальнейшем мы можем обращаться к каждому из этих значений через поля с 
названиями Item[порядковый_номер_поля_в_кортеже]

 var tuple = (5, 10);
    Console.WriteLine(tuple.Item1); // 5
    Console.WriteLine(tuple.Item2); // 10
    tuple.Item1 += 26;
    Console.WriteLine(tuple.Item1); // 31
    Console.Read();
------------------------------------------
типы данных в кортежах
можно использовать в котряжах как один тип данных 
(int, int) tuple = (5, 10);
Console.WriteLine(tuple.Item1);
Console.WriteLine(tuple.Item2);

так и несколько  

(string, int, double) person = ("Tom", 25, 81.23);
Console.WriteLine(person.Item1);//Tom
Console.WriteLine(person.Item2);//25
Console.WriteLine(person.Item3);//81.23

(double, int) t1 = (4.5, 3);
Console.WriteLine(t1.Item1);
Console.WriteLine(t1.Item2);

в случае если у перменных кортежа есь названиея нет необходисмости писатьть имя кортежу, 
достаточно обращатся к нему через его внутренние перменные:
var (name, age) = ("Tom", 23);
Console.WriteLine(name);// Tom
Console.WriteLine(age);// 23

------------------------------------------
названия полей кортежа
в случае если у перменных кортежа есь названиея нет необходисмости писатьть имя кортежу, 
достаточно обращатся к нему через его внутренние перменные:
Мы также можем дать названия полям кортежа
var tuple = (count:5, sum:10);
Console.WriteLine(tuple.count);//5
Console.WriteLine(tuple.sum); //10

(double Sum, int Count) d = (4.5, 3);
Console.WriteLine(d.Sum);
Console.WriteLine(d.Count);
------------------------------------------
возврат кортежа из метода

static void Main(string[] args)
{
    var tuple = GetValues();//присваиваем кортежу tuple результат работы метода - наш кортеж result
    Console.WriteLine(tuple.Item1); // 1
    Console.WriteLine(tuple.Item2); // 3
     
    Console.Read();
}

private static (int, int) GetValues()//создаем ворзващаемое значение ктореж из двух чисел
{
    var result = (1, 3);//инницииализируем кортеж
    return result;//возвращаем кортеж
}
--

private static (int sum, int count) GetNamedValues(int[] numbers)//создаем ворзващаемое значение ктореж из двух чисел с названиями полей кортежа
            //, а в аргумент записиываем массив из чисел
        {
            var result = (sum: 0, count: 0);//присваиваем занчениие нашему кортежу через обращение к его именам
           
            for (int i = 0; i < numbers.Length; i++)//перебиарем список 
            {
                result.sum += numbers[i];//в перменнную кортежа result.sum кладем резуолтат сложения всех занчений
                result.count++;// в перменную count кладем количество сложений
            }
            return result;//возарвщаем наш кортеж 
        }

static void Main(string[] args)
        {
            var tuple = GetNamedValues(new [] { 1, 2, 3, 4, 5, 6, 7 });//присваиваем кортежу tuple результат работы мтеода с именоваными пременными  (int sum, int count)
            //,а в аргумент записываем список
            Console.WriteLine(tuple.count);//обращаемся к членам кортежа через их имя и получаем значение
            Console.WriteLine(tuple.sum);
            Console.Read();
        }
        
------------------------------------------
передача в метод кортежа ввиде свойства

private static (string name, int age) GetTuple((string n, int a) tuple, int x)//создаем ворзващаемое значение ктореж из двух чисел с названиями полей кортежа
            //, а в аргумент записиываем еще один кортеж и число 
        {
            var result = (name: tuple.n, age: tuple.a + x);//заполняем наш возрварщаемый тупл занчениями из тупла аргумента, 
            return result;//result
        }

static void Main(string[] args)
        {
            var (name, age) = GetTuple(("Tom", 23), 12);
            Console.WriteLine(name);    //обращение к кортежу идет через возварщаемый тип те name а не n, Tom
            Console.WriteLine(age);     //обращение к кортежу идет через возварщаемый тип те age а не a, 35
            Console.Read();
        }
------------------------------------------
отличие кортежа от анонимного типа

Кортеж не является анонимным, это именованный тип. Вы можете использовать его как возвращаемый тип или аргумент метода. 
Этот код действителен:

 Tuple<int, string> GetTuple()
            {
                return Tuple.Create(1, "Bob");
            }
            Console.WriteLine(GetTuple());//(1, "Bob")
Вы не можете сделать это с анонимным типом, вам придется возвращать System.Object. Как правило,
 вам нужно использовать Reflection для этих объектов (или dynamic в .NET 4), чтобы получить значения отдельных свойств.


Кроме того, как упоминает Брайан, имена свойств в Tuple фиксированы - они всегда Item1, Item2, Item3 и т.д., 
тогда как с анонимным типом вы выбираете имена, Если вы пишете:

var x = new { ID = 1, Name = "Bob" }

Тогда анонимный тип имеет свойства ID и Name. Но если вы пишете:


Tuple.Create(1, "Bob")

Тогда полученный набор имеет свойства Item1 и Item2.            


==========================================

--анонимные типы--
------------------------------------------
Анонимные типы позволяют создать объект с некоторым набором свойств без определения класса. 
Анонимный тип определяется с помощью ключевого слова var и инициализатора объектов:
var user = new { Name = "Tom", Age = 34 };
          Console.WriteLine(user.Name);//"Tom"

В данном случае user - это объект анонимного типа, у которого определены два свойства Name и Age.
 И мы также можем использовать его свойства, как и у обычных объектов классов. Однако тут есть ограничение - 
 свойства анонимных типов доступны только для чтения.

Следует учитывать, что свойства анонимного объекта доступны для установки только в инициализаторе. 
Вне инициализатора присвоить им значение мы не можем.
 var student = new { Name = "Alice", Age = 21 };
student.Age = 32;   // ! Ошибка

Иногда возникает задача использовать один тип в одном узком контексте или даже один раз.
 Создание класса для подобного типа может быть избыточным. Если нам захочется добавить свойство, 
 то мы сразу же на месте анонимного объекта это можем сделать. В случае с классом придется изменять еще и класс,
  который может больше нигде не использоваться. Типичная ситуация - получение результата выборки из базы данных: 
  объекты используются только для получения выборки, часто больше нигде не используются, и классы для них создавать 
  было бы излишне. А вот анонимный объект прекрасно подходит для временного хранения выборки.
==========================================

--инкапсуляция--
------------------------------------------




==========================================

--наследование--
------------------------------------------
После двоеточия мы указываем базовый класс для данного класса. Для класса Employee базовым является Person, 
и поэтому класс Employee наследует все те же свойства, методы, поля, которые есть в классе Person. Единственное, 
что не передается при наследовании, это конструкторы базового класса.

class Person
{
    public string Name { get; set; }
    public Person(string name)
    {
        Name = name;
    }
    public void DisplayName()
    {
        Console.WriteLine(Name);
    }
}

class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company) : base(name)
    {
        Company = company;
    }
}

class Program
{
    static void Main(string[] args)
    {
        Person p1 = new Person("Bill");
        Employee p2 = new Employee("Tom", "Microsoft");
        p1.DisplayName();//Bill
        p2.DisplayName();//Tom функционал из Person Name из Employee
        Console.ReadKey();
    }
}

------------------------------------------

delegate void AccountHandler(string message);
    class Person
    {
        public event AccountHandler _notify;
        private string name;
        string tempName;
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value != name)
                {
                    name = value;
                    DisplayTo();
                }
                
            }
        }

        public void DisplayTo()
        {
            _notify?.Invoke(name);
        }

    }
    class Employee : Person//этот класс будет реализовывать тот же функционал, что и класс Person
                           //Таким образом, наследование реализует отношение is-a (является),
                           //объект класса Employee также является объектом класса Person:
    {

    }
    class Program
    {
        static void Main(string[] args)
        {

            Person p = new Person();
            p._notify += Display;
            p.Name = "flfl";
            p = new Employee();//И поскольку объект Employee является также и объектом Person,
                               //то мы можем так определить переменную: Person p = new Employee().
            p._notify += Display;//но так как новый экземпляр всегода
            //создается с дефолтными значениями
            //нам нажно переподключится к ивенту
            p.Name = "Josh";
            Console.Read();
        }

        static void Display(string name)
        {
            Console.WriteLine(name);
        }
    }

------------------------------------------
class one{}
class two : one{}
class three
one newone = new two();//в этом случае выделяется память под объект two, и поскольку two является наследником от one,
 //то такое использование является допустимым. это апкаст
  //Затем мы можем использовать созданный объект как one и как two, но чтобы использовать его как two,
   //надо будет выполнить явное преобразование к two в виде даункаста

------------------------------------------
По умолчанию все классы наследуются от базового класса Object, даже если мы явным образом не устанавливаем наследование. 
Поэтому выше определенные классы Person и Employee кроме своих собственных методов, также будут иметь и методы класса 
Object: ToString(), Equals(), GetHashCode() и GetType().
------------------------------------------
Все классы по умолчанию могут наследоваться. Однако здесь есть ряд ограничений:
Не поддерживается множественное наследование, класс может наследоваться только от одного класса.
При создании производного класса надо учитывать тип доступа к базовому классу - тип доступа к производному классу
 должен быть таким же, как и у базового класса, или более строгим. То есть, если базовый класс у нас имеет тип доступа
  internal, то производный класс может иметь тип доступа internal или private, но не public.
Однако следует также учитывать, что если базовый и производный класс находятся в разных сборках (проектах), 
то в этом случае производый класс может наследовать только от класса, который имеет модификатор public.
Если класс объявлен с модификатором sealed, то от этого класса нельзя наследовать и создавать производные классы. 
Например, следующий класс не допускает создание наследников:
sealed class Admin//модификатор по умолчанию - internal
{

}
------------------------------------------
Доступ к членам базового класса из класса-наследника

class Person
    {
       
        private string name;
       
        public string Name
        {
            get...

class Employee : Person
{
    public void Display()
    {
        Console.WriteLine(_name);//не скомпирилуется тк k _name доступ имеет только класс Person
    }
}            
--------
class Employee : Person
{
    public void Display()
    {
        Console.WriteLine(Name);// общедоступное свойство Name, которое мы можем использовать
    }
}

------------------------------------------
Таким образом, производный класс может иметь доступ только к тем членам базового класса, 
которые определены с модификаторами private protected (если базовый и производный класс
 находятся в одной сборке), public, internal (если базовый и производный класс находятся в одной сборке), 
protected и protected internal.
------------------------------------------
порядок вызовов констуркторов

При вызове конструктора класса сначала отрабатывают конструкторы базовых классов и только затем конструкторы производных.

class Person
{
    string name;
    int age;
 
    public Person(string name)//сперва отработает этот конструктор 
    {
       //1
    }
    public Person(string name, int age) : this(name)//далее этот тк через this он вызывает первй конструктор
    {
    	//2
    }
}
class Employee : Person
{
    string company;
 
    public Employee(string name, int age, string company) : base(name, age)//и потом уже этот тк он вызывает через 
    //base контсркутор 2 ктороый в свою очередь через this вызывает кнстр 1
    {
      //3
    }
}

Employee tom = new Employee("Tom", 22, "Microsoft");//в случае создания обьекта Employee мы получим 
//вышенапиисаный порядок вызово конструкторов
------------------------------------------
Ключевое слово base

С помощью ключевого слова base мы можем обратиться к базовому классу. В нашем случае в конструкторе 
класса Employee нам надо установить имя и компанию. Но имя мы передаем на установку в конструктор базового класса, 
то есть в конструктор класса Person, с помощью выражения base(name).

class Person
{
    public string Name { get;  set; }
 
    public Person(string name)//вот это конструктора мы вызваем из ксласса Employee через выржаение base
    {
        Name = name;
    }
 
    public void Display()
    {
        Console.WriteLine(Name);
    }
}
 
class Employee : Person
{
    public string Company { get; set; }
 
    public Employee(string name, string company)
        : base(name)//С помощью ключевого слова base мы можем обратиться к базовому классу Person.
        //Класс Person имеет конструктор, который устанавливает свойство Name. 
        //Поскольку класс Employee наследует и устанавливает то же свойство Name, 
        //то логично было бы не писать по сто раз код установки, а вызвать соответствующий код класса Person. 
    {
        Company = company;
    }
}

Person p = new Person("Bill");
   
Employee emp = new Employee ("Tom", "Microsoft");//имя мы передаем на установку в конструктор базового класса,
// то есть в конструктор класса Person, с помощью выражения base(name)
------------------------------------------

если в базовом классе не определен конструктор по умолчанию без параметров, 
а только конструкторы с параметрами (как в случае с базовым классом Person), 
то в производном классе мы обязательно должны вызвать один из этих конструкторов через ключевое слово base.

==========================================



--преобразование типов--

------------------------------------------
Восходящие преобразования. Upcasting

восходящее преобразование от производного к базовому, перход от конкретизации к обощенности. Это позволяет работать с обьектами
имеющими один и тот же базовый класс не отвлекаясь на их индивидуальные особенности, предпологается работа с ними используя их 
общий фунционал заложеный в них через базовый класс.

пременной обьекта класса родителя Person person , присваиваешь пременную обьекта класса потомока Employee employee
и ты автоматом выполняешь некое преобразование. 
вот оно и называется как раз "восходящим" или "Upcasting" тк ты  потомка employee преобразуешь в класс предок person 
который находится вверху иерархии классов и они типа таким образом обе эих перменных те перменная потомка и перменная
родителя с присвоеной в нее переменноой потомка начинают указыать на один класс в куче, но перменной класса родителя
будет доступна только та часть кода которая в ней собтвенно есть те дополнительные функции и поля из потомка ей недоступны

В данном случае переменной person, которая представляет тип Person, присваивается ссылка на объект Employee.
 Но чтобы сохранить ссылку на объект одного класса в переменную другого класса, необходимо выполнить 
 преобразование типов - в данном случае от типа Employee к типу Person.

 class Person
    {
        public string Name { get; set; }
        public Person(string name)
        {
            Name = name;
        }
        public void Display()
        {
            Console.WriteLine($"Person {Name}");
        }
    }

    class Employee : Person
    {
        public string Company { get; set; }
        public Employee(string name, string company) : base(name)
        {
            Company = company;
        }

    }

    class Client : Person
    {
        public string Bank { get; set; }
        public Client(string name, string bank) : base(name)
        {
            Bank = bank;
        }
    }

    class Program
    {
       
        static void Main(string[] args)
        {
            Employee employee = new Employee("Tom", "Microsoft");
            
            Person person = employee;   // преобразование от Employee к Person
            // В итоге переменные employee и person будут указывать на одно и то же место в памяти(Employee),
            // но переменной person будет доступна только та часть, которая представляет функционал типа Person.
            // Это назыывается  восходящие преобразования

            if (employee is Person person)//это аналогично вышенаписаной констркуции (Person person = employee) 
            //но здесь дополнительно идет проверка на возможность преобразования выражения в указанный тип и, 
            //если это возможно, приводит переменную к переменной этого типа.
        	{
        	//varname назначается только в пределах инструкции if
            Console.WriteLine(person.Name);
            Console.WriteLine(person.Company);//это выдаст ошибку тк поле Company принадлежит к классу Employee
            //а ссылочная перменная обьект person, указывает сейчас на класс Person, те поля и методы обьекта
            //employee перменной person недоступны
        	}
			
            Person person1 = new Client("Bob", "ContosoBank");//Здесь переменная person1, которая представляет
            //тип Person, хранит ссылку на объект Client, поэтому также выполняется восходящее неявное преобразование
            //от производного класса Client к базовому типу Person.
 			
            Console.ReadKey();

            Так как тип object -базовый для всех остальных типов, то преобразование к нему будет 
            производиться автоматически.

            object person2 = new Employee("Tom", "Microsoft");  // от Employee к object
            object person3 = new Client("Bob", "ContosoBank");  // от Client к object
            object person4 = new Person("Sam"); // от Person к object
        }
    }

//это...
    Employee employee = new Employee("Tom", "Microsoft");
    Person person = employee;

//...аналогично нижеследуеще записи толоко без создание отдельной перменной employee
    Person person = new Employee("Tom", "Microsoft");
------------------------------------------
Нисходящие преобразования. Downcasting

нисходящие преобразования или downcasting - от базового типа к производному.
Но автоматически такие преобразования не проходят, ведь не каждый человек (объект Person) является сотрудником 
предприятия (объектом Employee)тк у сотрудника предприятия есть дополнительные методы свойства поля и тд. неописанные
в обьекте Person. Поэтому для нисходящего преобразования необходимо применить явное преобразования,
указав в скобках тип, к которому нужно выполнить преобразование:

Employee employee = new Employee("Tom", "Microsoft");
Person person = employee;   // преобразование от Employee к Person
//переменная person хранит ссылку на объект Employee
//сперва апкаст а потом уже даункасат 
//Потому, что объект создан и занимает в памяти 20 байт. И он никак не может кастнуться в объект который 
//должен занимать 20 Мб.

Employee employee2 = person;// так нельзя, нужно явное преобразование 

Employee employee1 = (Employee)person;//после апкаста можно уже производить явное преобразование от
// Person к Employee

Console.WriteLine(employee1.Name +" "+ employee1.Company);

object obj = new Employee("Bill", "Microsoft");
// чтобы обратиться к возможностям типа Employee,явно приводим объект к типу Employee
Employee emp = (Employee)obj;//В этом случае переменной obj присвоена ссылка на объект Employee, 
//поэтому мы можем преобразовать объект obj к любому типу который располагается в иерархии классов между 
//типом object и Employee.

Если нам надо обратиться к каким-то отдельным свойствам или методам объекта, то нам необязательно присваивать 
преобразованный объект переменной :

// Объект Employee также представляет тип object
object obj = new Employee("Bill", "Microsoft");
 
// преобразование к типу Person для вызова метода Display
((Person)obj).Display();
// либо так
((Employee)obj).Display();
 
// преобразование к типу Employee, чтобы получить свойство Company
string comp = ((Employee)obj).Company;


------------------------------------------
--is--
по сути отличие is от as в том что is возращает bool, а as в случае неудачи вернет null

is в случае с апкастом

Employee employee = new Employee("Tom", "Microsoft");
            
            Person person = employee;   // преобразование от Employee к Person
            // В итоге переменные employee и person будут указывать на одно и то же место в памяти(Employee),
            // но переменной person будет доступна только та часть, которая представляет функционал типа Person.
            // Это назыывается  восходящие преобразования

            if (employee is Person person)//это аналогично вышенпаисной констркуции (Person person = employee) 
            //но здесь дополнительно идет проверка на возможность преобразования выражения в указанный тип и, 
            //если это возможно, приводит переменную к переменной этого типа. если это не возможно
            // такая проверка вернет значение false, и преобразование не сработает.
            {
            //varname назначается только в пределах инструкции if
            Console.WriteLine(person.Name);
            Console.WriteLine(person.Company);//это выдаст ошибку тк поле Company принадлежит к классу Employee
            //а ссылочная перменная обьект person, указывает сейчас на класс Person, те поля и методы обьекта
            //employee перменной person недоступны
            }


еще одна проверка допустимости преобразования с помощью ключевого слова is в случае с даункастом

class Person
    {
        public string Name { get; set; }
        public Person(string name)
        {
            Name = name;
        }
        public void Display()
        {
            Console.WriteLine($"Person {Name}");
        }
    }

    class Employee : Person
    {
        public string Company { get; set; }
        public Employee(string name, string company) : base(name)
        {
            Company = company;
        }

    }

    Person person = new Person("Tom");

    if(person is Employee)//Выражение person is Employee проверяет, является ли переменная person объектом типа Employee.
    // Но так как в данном случае явно не является, то такая проверка вернет значение false, и преобразование не сработает.
    //здесь неудачная попытка произвести даункаст если мы перед эти сделаем так  (сперва апкаст) 
    //Person person = new Employee("Mix", "Apple"); то это преобразование сработает
    {
        Employee emp = (Employee)person;
        Console.WriteLine(emp.Company);
    }
    else
    {
        Console.WriteLine("Преобразование не допустимо");
    }       

------------------------------------------
--as--

as в случае с даункастом

Структура - это тип значения(стурктура является значимым типом), ,
поэтому ее нельзя использовать с as оператором,
тк as Оператор должен иметь возможность присвоить значение NULL если терпит неудачу.
Это возможно только со ссылочным типом или типом значения, допускающим значение NULL.


as в случае с апкастом

Employee employee = new Employee("Tom", "Microsoft");

            var emp = p3 as Person; //это бесмыленно потому что никогда не станет null
            //для этого лучше исопльзовать is

            if (emp == null)
            {
                Console.WriteLine("Преобразование прошло неудачно");
            }
            else
            {
                Console.WriteLine(emp.Name);
            }


as в случае с даункастом

Person person = new Person("Tom");

Employee emp = person as Employee;//пытается преобразовать выражение к определенному типу в
// случае неудачного преобразования выражение будет содержать значение null здесь неудачная попытка произвести
// даункаст если мы перед эти сделаем так (сперва апкаст)Person person = new Employee("Mix", "Apple"); 
  //то это преобразование сработает

if (emp == null)
{
    Console.WriteLine("Преобразование прошло неудачно");
}
else
{
    Console.WriteLine(emp.Company);
}

______________________________  
class Person
    {
        public string Name { get; set; }

        public Person(string name)
        {
            Name = name;
        }

        public virtual string Display() //методы и свойства, которые мы хотим сделать доступными для переопределения,
            // в базовом классе помечается модификатором virtual. Такие методы и свойства называют виртуальными.
        {
            return Name;
        }

        public string SS()
        {
            return "SS in Person";
        }
    }

    class Employee : Person
    {
        public string Company { get; set; }

        public Employee(string name, string company) : base(name)
        {
            Company = company;
        }

        //методы можно перопрделть а можно оставлять как есть в этом случае объекты Employee будут использовать реализацию 
        //метода Display из класса Person те из базового класса, те если мы УДАЛИМ отсюда метод Display, будет исопльзован 
        //ОРИГИНАЛЬНЫЙ Display из класса Person
        public override string Display() //А чтобы переопределить метод в классе-наследнике, этот метод определяется 
            //с модификатором override. 

            //Переопределенный метод в классе-наследнике должен иметь тот же набор параметров, что и виртуальный метод в базовом классе.
        {
            if (Name == "Tom")
            {
                Name = "Max";
                return Name + $" {Company}";
            }

            return base.Display() + $" {Company}";
        }

        public string SS()
        {
            return "SS in Emplouee";
        }
    }

    class EmployeeTwo : Employee
    {
        public int Age { get; set; }

        public EmployeeTwo(string name, string company, int age) : base(name, company)
        {
            Age = age;
        }

        public override string Display() //Виртуальные методы базового класса определяют интерфейс всей иерархии, 
            //то есть в любом производном классе, который не является прямым наследником от базового класса, можно 
            //переопределить виртуальные методы.
            //Например, мы можем определить класс Manager, который будет производным от Employee, и в нем также переопределить 
            //метод Display.
        {
            return base.Display() + $" {Age}";
        }


    }

    class Program
    {
        static void Main(string[] args)
        {
            Person p1 = new Person("Bill");
            Console.WriteLine(p1.Display()); //Bill
            // вызов метода Display из класса Perso
            Employee p2 = new Employee("Tom", "Microsoft");
            Console.WriteLine(p2.Display()); //Max Microsoft
            // вызов метода Display из класса Person
            if (p2 is Person p)
            {
                Console.WriteLine(p.Display()); //"Tom", "Microsoft" тк метод виртуальный то при апкасте будет
                //исопльзоватся его верисия из класса потомка Employee p2
                Console.WriteLine(p.SS()); //это обычный метод поэтому будет исполльзоватся из класса родителя Person p1
            }


            Person pers = p2;

            Employee emp = (Employee) pers;


            Person person = new Person("Tom");
            //пытается преобразовать выражение к определенному типу в
            // случае неудачного преобразования выражение будет содержать значение null 
            EmployeeTwo p3 = new EmployeeTwo("Tommi", "Microsoftuuuss", 20);
            Console.WriteLine(p3.Display()); //Tommi Microsoftuuuss 20

            Console.ReadKey();
        }
    }




==========================================
--лоакльаные функции--
------------------------------------------
Локальные функции представляют функции, определенные внутри других методов. Определим и используем локальную функцию:

  static void Main(string[] args)
        {
            var result = GetResult(new int[] {-3, -2, -1, 0, 1, 2, 3});
            Console.WriteLine(result); // 6
            Console.Read();
        }

        static int GetResult(int[] numbers)
        {
            int limit = 0;

            // локальная функция
           

            int result = 0;
            for (int i = 0; i < numbers.Length; i++)
            {
                if (IsMoreThan(numbers[i]))// не имеет значения, определены локальные функции до своего вызова или после.
                {
                    result += numbers[i];
                }
                else if(IsStaticMoreThan(numbers[i]))
                {
                    result = 0;
                }
            }

            bool IsMoreThan(int number) //Здесь в методе GetResult определена локальная функция IsMoreThan(), которая может быть вызвана только внутри этого метода,
                // и не может имет можиффикатор доступа
            {
                if (result > 0)
                {
                    return number > limit; //Локальная функция задает еще одну область видимости, где мы можем определять переменные и выполнять над ними действия.
                    //В то же время ей доступны все переменные, которые определены в том же методе. и  вне его
                }

                return false;
            }
            static bool IsStaticMoreThan(int number)//можно определять  статические локальные функции не могут братьт перменные из тела мтеода в котором назодятся
            {
                int limit = 0;
                //if (result == 0)//вызовет ошибку потому что они не могут обращаться к переменным окружения, то есть метода, в котором статическая функция определена
                //{
                //    return number < limit;
                //}
                return number > limit;
            }

            //string IsMoreThan(string str) //нельзя определить в оном мтеоде несолкько локальных функций с одинаковы именем даже если у них отличается 
            //возрващаемое значение и список параметров
            //{
            //    return str;
            //}

            return result;
        }
==========================================


--
------------------------------------------


==========================================



--преобразование типов перегрузка--
------------------------------------------

public static implicit|explicit operator Тип_в_который_надо_преобразовать(исходный_тип param)// explicit если 
//преобразование явное и implicit если преобразование неявное
{
    // логика преобразования
}
Какие операции преобразования делать явными,а какие неявные,не столь важно, это решает разработчик по своему усмотрению.
------------------------------------------
class Counter
{
public int Seconds { get; set; }

    public static explicit operator int(Counter counter)//преобразует объект Counter к типу int, то есть получает 
    //из Counter число.
    {
        return counter.Seconds;
    }

     public static implicit operator Counter(int x)//преобразует число объект типа int к типу Counter. 

    {
        return new Counter { Seconds = x };// тут создается новый объект Counter, у которого устанавливается 
        //свойство Seconds.
    }
}


    static void Main(string[] args)
    {
        Counter counter1 = new Counter { Seconds = 23 };

        int x = (int)counter1;//преобразует объект Counter к типу int x, то есть получает из Counter число.explicit
        //и это преобразование явное
    {
        Console.WriteLine(x);   

        Counter counter2 = x;//преобразует число x объект типа int к типу Counter. implicit и это преобразование неявное
        Console.WriteLine(counter2.Seconds);  // 23
    }

если для преобразования потребуется более сложная логика, то просто так написать не получится. Например,
 во втором примере при преобразовании от типа Counter к типу Timer сложность преобразования возрастает,
 соотвественно лучше один раз определить оператор, чем по сто раз писать один и тот же набор операций. 
 А в случае преобразований с более сложной логикой это тем более актуально

class Timer
{
    public int Hours { get; set; }
    public int Minutes { get; set; }    
    public int Seconds { get; set; }
}
class Counter
{
    public int Seconds { get; set; }
 
    public static implicit operator Counter(int x)
    {
        return new Counter { Seconds = x };
    }
    public static explicit operator int(Counter counter)
    {
        return counter.Seconds;
    }
    public static explicit operator Counter(Timer timer)
    {
        int h = timer.Hours * 3600;
        int m = timer.Minutes * 60;
        return new Counter { Seconds = h + m + timer.Seconds };
    }
    public static implicit operator Timer(Counter counter)
    {
        int h = counter.Seconds / 3600;
        int m = (counter.Seconds % 3600) / 60;
        int s = counter.Seconds % 60;
        return new Timer { Hours = h, Minutes = m, Seconds = s };
    }
}

static void Main(string[] args)
{
    Counter counter1 = new Counter { Seconds = 115 };
 
    Timer timer = counter1;
    Console.WriteLine($"{timer.Hours}:{timer.Minutes}:{timer.Seconds}"); // 0:1:55
 
    Counter counter2 = (Counter)timer;
    Console.WriteLine(counter2.Seconds);  //115
     
    Console.ReadKey();
}
==========================================


--виртуальные и переопределенные (virtual, override) методы и свойства--
------------------------------------------
виратуальный метод или свойства могу находится в обычном классе родителе, могут иметь свою функциональность,
при этом могут быть (а могут и не быть, тогда их функционал будет просто использован из класса родителя)  
перпоределнными в потмках, вызыватся через экземпляр класса в котором они обьявлены.

виртуальный метод можно переопределить, абстрактный - нужно.

простой пример это у класса Human есть метод Display вывода на экран поля Name , а в классе наследнике Employee 
этот метод перопределяется для вывода на экран Name из класса Human + Company из класса Employee(те приобретает 
доп функциональность)

модификатор доступа должен быть одинаковым
------------------------------------------
пример ипсользования вриитуальнных методов а так же апкаст(upcasting) и даункаст (downcasting)
class Person
{
    public string Name { get; set; }
    public Person(string name)
    {
        Name = name;
    }
    public virtual string Display()//методы и свойства, которые мы хотим сделать доступными для переопределения,
    // в базовом классе помечается модификатором virtual. Такие методы и свойства называют виртуальными.
    {
        return Name;
    }

     public string SS()
        {
            return "SS in Person";
        }
}
class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company) : base(name)
    {
        Company = company;
    }

    //методы можно перопрделть а можно оставлять как есть в этом случае объекты Employee будут использовать реализацию 
    //метода Display из класса Person те из базового класса, те если мы УДАЛИМ отсюда метод Display, будет исопльзован 
    //ОРИГИНАЛЬНЫЙ Display из класса Person
    public override string Display()//А чтобы переопределить метод в классе-наследнике, этот метод определяется 
    //с модификатором override. 

    //Переопределенный метод в классе-наследнике должен иметь тот же набор параметров, что и виртуальный метод в базовом классе.
    {
        if (Name =="Tom")
        {
            Name = "Max";
            return Name + $" {Company}";
        }
        return base.Display() + $" {Company}";
    }
    public string SS()
        {
            return "SS in Emplouee";
        }
}

class EmployeeTwo : Employee
{
    public int Age { get; set; }
    public EmployeeTwo(string name, string company, int age) : base(name, company)
    {
        Age = age;
    }

    public override string Display()//Виртуальные методы базового класса определяют интерфейс всей иерархии, 
    //то есть в любом производном классе, который не является прямым наследником от базового класса, можно 
    //переопределить виртуальные методы.
    //Например, мы можем определить класс Manager, который будет производным от Employee, и в нем также переопределить 
    //метод Display.
    {
        return base.Display() + $" {Age}";
    }
}
class Program
{
    static void Main(string[] args)
    {
        Person p1 = new Person("Bill");
        Console.WriteLine(p1.Display());//Bill
        // вызов метода Display из класса Person

        Employee p2 = new Employee("Tom", "Microsoft");
        Console.WriteLine(p2.Display());//Max Microsoft
        // вызов метода Display из класса Person

        if (p2 is Person p)
            {
                Console.WriteLine(p.Display()); //"Max", "Microsoft" тк метод виртуальный то при апкасте будет
                //исопльзоватся его верисия из класса потомка Employee p2
                Console.WriteLine(p.SS()); //это обычный метод поэтому будет исполльзоватся из класса родителя Person p1
            }

            Person pers = p2;
            Employee emp = (Employee) pers;

            Console.WriteLine(emp.Display());//"Max", "Microsoft" тк метод виртуальный то при даункасте  будет
            //исопльзоватся его верисия из класса потомка Employee p2
            Console.WriteLine(emp.SS());//это обычный метод поэтому будет исполльзоватся из класса родителя Person p1


        EmployeeTwo p3 = new EmployeeTwo("Tommi", "Microsoftuuuss", 20);
        Console.WriteLine(p3.Display());//Tommi Microsoftuuuss 20

        Console.ReadKey();
    }
}

Также можно запретить переопределение методов и свойств. В этом случае их надо объявлять с модификатором sealed

 public override sealed string Display();//производится только в произодном классе в класс родителе смысл делать 
 //нет тк проще убраьт virtual

------------------------------------------
виртуальные свойства

так же монжно перопрделть свойства, модификатор доступа должен быть одинаковым

class Credit
{
    public virtual decimal Sum { get; set; }//свойства, которые мы хотим сделать доступными для переопределения,
    // в базовом классе помечается модификатором virtual. Такие методы и свойства называют виртуальными.
}
class LongCredit : Credit
{
    private decimal sum;
    public override decimal Sum//А чтобы переопределить свойство в классе-наследнике, этот свойство определяется 
    //с модификатором override. 
    //Переопределенный свойство в классе-наследнике должен иметь тот же набор параметров, 
    //что и виртуальный свойство в базовом классе.
    {
        get
        {
            return sum;
        }
        set
        {
            if (value > 1000)
            {
                sum = value;
            }
        }
    }
}
class Program
{
    static void Main(string[] args)
    {
        LongCredit credit = new LongCredit { Sum = 6000 };
        credit.Sum = 490;
        Console.WriteLine(credit.Sum);
        Console.ReadKey();
    }
}

==========================================



--сокрытие (new void method)--
------------------------------------------
Это когда скрываем в производном классе функциноал базового класса
определение в классе-наследнике метода или свойства,которые соответствует по имени и набору параметров методу или
свойству базового класса. по сути создается еще один метод с таким же названием не взяаный с пердыдущим, используется
для разрешения конфликат имен без использования преопределения

Для сокрытия членов класса применяется ключевое слово new. 

Если вы работаете с экземпляром класса-наследника через его родительский класс, то в случае, если вы будете вызывать
 переопределенный виртуальный метод (override), то будет вызвана его реализация из наследника, а если перекрытый (new), 
 то будет вызван метод базового класса

class Main
    {
        public virtual void First()
        {
            Console.WriteLine("First from Main");
        }

        public void Second()
        {
            Console.WriteLine("Second from Main");
        }
    }

    class Child : Main
    {
        public override void First()//Модификатор override расширяет реализацию для наследуемого члена.
        {
            Console.WriteLine("First from Child");
        }

        public new void Second()//Модификатор new создает новый член с таким же именем и приводит к скрытию исходного члена. 
        {
            Console.WriteLine("Second from Child");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Main main = new Child();//Если вы работаете с экземпляром класса-наследника через его родительский класс

            main.First(); // то в случае, если вы будете вызывать
 //переопределенный виртуальный метод (override) - выведет метод First у Child
            main.Second(); // а если перекрытый (new), 
 //то будет вызван метод базового класса - выведет метод Second у Main
        }
    }

------------------------------------------
 class Person
    {

        public string FirstName { get; set; }
        public string LastName { get; set; }

        public Person(string firstName, string lastName)
        {
            FirstName = firstName;
            LastName = lastName;
        }

        public void Display()
        {
            Console.WriteLine($"{FirstName} {LastName}");
        }

        public void DisplayIs()
        {
            Console.WriteLine($"{FirstName} {LastName} AZazain");
        }
    }

    class Employee : Person
    {
        public string Company { get; set; }

        public Employee(string firstName, string lastName, string company)
            : base(firstName, lastName)
        {
            Company = company;
        }

        public new void Display() //этотт метод скрывает рализацию из класса Persone при этом неважно является ли метод
        // в классе родителя виртуальным или нет, если используется  var kek = (Employee) bob то мы получаем на выходе 
        //метод из Employee а не методж из класса Person это полезно использовать когжа нпример метод Display в 
        //базовом классе не является виртуальным,мы не можем его переопределить, и тут нам поможет именно такая
        // конструкция какnew void Display()
        {
            Console.WriteLine($"{FirstName} {LastName} работает в {Company}");
        }

        public void DisplayCompany()
        {
            Console.WriteLine($"{Company}");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Person bob = new Person("Bob", "Robertson");
            bob.Display(); // Bob Robertson

            bob = new Employee("Max", "Robertson", "okla"); //сперва апкаст а потом уже даункасат 
            //Потому, что объект создан и занимает в памяти 20 байт. И о не как не может кастнуться в объект
            // который должен занимать 20 .переменной bob будет доступна только та часть, которая представляет 
            //функционал типа Person.Это назыывается  восходящие преобразования
            bob.Display(); //Max Robertson 
            bob.DisplayIs();//Max Robertson AZazain

            bob.DisplayCompany(); // выдаст ошибку оптому что Person недоступен функционал типа Employee.

            var kek = (Employee) bob; //здесь происходит даункаст 
            kek.Display(); //Max Robertson работает в okla здесь используется сокрытый метод Display тк кек 
            //это обьект класса Employee 

            Employee tom = new Employee("Tom", "Smith", "Microsoft");//используется сокрытый метод Display 
            //тк кек это обьект класса Employee 
            tom.Display(); // Tom Smith работает в Microsoft
            Console.ReadKey();
        }
    }

------------------------------------------
аналогично можно реализовтаь сокрытие свойств 
class Person
{
    protected string name;
    public string Name
    {
        get { return name; }
        set { name = value; }
    }
}
class Employee : Person
{
    public new string Name
    {
        get { return "Employee " + base.Name; }
        set { name = value; }
    }
}
------------------------------------------
а так же переменные и константы
class ExampleBase
{
    public readonly int x = 10;
    public const int G = 5;
}
class ExampleDerived : ExampleBase
{
    public new readonly int x = 20;
    public new const int G = 15;
}

==========================================



--Абстрактные классы и члены классов--abstract class--
------------------------------------------
а вот абстрактные класс может иметь как обыкновенные переменные и методы и конструкторы (со стандартным наполнением 
и объявлением) так и абстрактные методы и переменные (но тогда у них не должно  быть тела функциональности, 
они должны быть обязательно переопределены в потомках, а так же класс в которм есть хоть один абстрактный член 
должен быть сам абстрактным), и вот  эти абстракты не могут быть вызваны в отличии от вируталов через экземпляры. 
Аабстрактные классы как бы обьеднияют классы наследники какимито общими свойствами.

виртуальный метод можно переопределить, абстрактный - нужно.

например есть фигура геометрическая по сути она без оперделения круга там или квадрат она не может сущетсвовать, 
и вот только когда мы преопределяем класс фигуры с полями типа Площадь и Периметр в какомнибудь там круге или 
треугольнике только там она начинает сущетсовать как бы

 при определении абстрактных классов используется ключевое слово abstract и мы не можем использовать конструктор
  абстрактного класса для создания его объекта
abstract class Human
{
	...

Human h = new Human();//выдсат ошибку
------------------------------------------
абстрактные класы следует использовать:

Если надо определить общий функционал для родственных объектов

Если мы проектируем довольно большую функциональную единицу, которая содержит много базового функционал

Если нужно, чтобы все производные классы на всех уровнях наследования имели некоторую общую реализацию. При использовании абстрактных классов, 
если мы захотим изменить базовый функционал во всех наследниках, то достаточно поменять его в абстрактном базовом классе.

Если же нам вдруг надо будет поменять название или параметры метода интерфейса, то придется вносить изменения и также во всех классы, 
которые данный интерфейс реализуют.

--
Если классы относятся к единой системе классификации, то ВЫБИРАЕТСЯ абстрактный класс. 
Допустим, у нас есть система транспортных средств: легковой автомобиль, автобус, трамвай, поезд и т.д.
Поскольку данные объекты являются родственными, мы можем выделить у них общие признаки

public abstract class Vehicle
{
    public abstract void Move();//Абстрактный класс Vehicle определяет абстрактный метод перемещения Move()
}
 
public class Car : Vehicle
{
    public override void Move()
    {
        Console.WriteLine("Машина едет");//а классы-наследники его реализуют.
}
 
public class Bus : Vehicle
{
    public override void Move()
    {
        Console.WriteLine("Автобус едет");//а классы-наследники его реализуют.

    }
}
 
public class Tram : Vehicle
{
    public override void Move()
    {
        Console.WriteLine("Трамвай едет");//а классы-наследники его реализуют.
    }
}

а может быть аткая ситуация что система транпорта не ограничитивается вышеперчимлеными тр средставми, например добавит сюда самолеты лодки,
лошадей ,дирижабль они связаны только тем что являются транс. средством и дложны реализоват абстрактный метод Move() выполняющий пермешение.
Эти обьекты малосвязаны мкжду собой потому для определеня общих функционаов лучше использовать интерфейс, к тому же неткорые модели могут 
сущетвовать в рамках прарельных классификаций. например лошадь не только средство передвиэжения но и может быть классом в структуре классов
живтогного мира.
------------------------------------------
эти классы используются для того чтобы определять общую функциональность например, имя и метод вывода на консоль имени

abstract class Person
{
    public string Name { get; set; }
 
    public Person(string name)
    {
        Name = name;//тут инициализировать некоторые общие для производных классов 
        //переменные и свойства, как в случае со свойством Name
    }
 
    public void Display()
    {
        Console.WriteLine(Name);
    }
    public abstract void DisplayIs();//определим абстрактный класс 
}
 
class Client : Person
{
    public int Sum { get; set; }    // сумма на счету
 
    public Client(string name, int sum)
        : base(name)
    {
        Sum = sum;
    }

     public override void DisplayIs()//переопреедлим асбтакртный класс из родителя, 
     //если этого не сделать компилятор выдаст ошибку 
        {
            Console.WriteLine($"{Name} имеет счет на сумму {Sum}");
        }
}
 
class Employee : Person
{
    public string Position { get; set; } // должность
 
    public Employee(string name, string position) 
        : base(name)
    {
            Position = position;
    }

     public override void DisplayIs()//переопреедлим асбтакртный класс из родителя, 
     //если этого не сделать компилятор выдаст ошибку 
        {
            Console.WriteLine($"{Position} {Name}");
        }
}

//И хотя в примере конструктор класса Person не вызывается, тем не менее производные классы Client и Employee 
//могут обращаться к нему.
 Client client = new Client("Tom", 500);
Employee employee = new Employee("Bob", "Apple");
client.Display();//Tom
employee.Display();//Bob
Person person = new Person ("Bill");//выдсат ошибку
------------------------------------------
абстрактные члены классов не имеют никакого функционала

Методы
Свойства
Индексаторы
События

abstract class Person
{
    public string Name { get; set; }
 
    public Person(string name)
    {
        Name = name;
    }
}

class Client : Person
{
    public int Sum { get; set; }    // сумма на счету
 
    public Client(string name, int sum)
        : base(name)
    {
        Sum = sum;
    }
    public override void Display()
    {
        Console.WriteLine($"{Name} имеет счет на сумму {Sum}");
    }
}

------------------------------------------
Следует отметить использование абстрактных свойств. Их определение похоже на определение автосвойств

abstract class Person
{
    public abstract string Name { get; set; }
}

class Client : Person
{
    private string name;
 
    public override string Name
    {
        get { return "Mr/Ms. " + name; }
        set { name = value; }
    }

    //или

    public override string Name { get; set; }
}
------------------------------------------
если нужно отказаться от реализации абстрактных членов в классе потомке нужно сделать его тоже абстрактным
abstract class Person
{
    public abstract string Name { get; set; }
}
 
abstract class Manager : Person
{

}
------------------------------------------
Xрестоматийным примером является система геометрических фигур. В реальности не существует геометрической фигуры как 
таковой.
 Есть круг, прямоугольник, квадрат, но просто фигуры нет. Однако же и круг, и прямоугольник имеют 
 что-то общее и являются фигурами
// абстрактный класс фигуры
abstract class Figure
{
    // абстрактный метод для получения периметра
    public abstract float Perimeter();
    // абстрактный метод для получения площади
    public abstract float Area();
}
// производный класс прямоугольника
class Rectangle : Figure
{
    public float Width { get; set; }
    public float Height { get; set; }
 
    public Rectangle(float width, float height)
    {
        this.Width = width;
        this.Height = height;
    }
    // переопределение получения периметра
    public override float Perimeter()
    {
        return Width * 2 + Height * 2;
    }
    // переопрелеление получения площади
    public override float Area()
    {
        return Width * Height;
    }
}

==========================================



--System.Object и его методы--
------------------------------------------
 мы можем переопределить метод ToString()

(string)obj производит явное преобразование obj в string. obj должен уже быть, string чтобы это удалось.

obj.ToString()получает строковое представление obj путем вызова ToString() метода. 
Это в отличии от явного приведения никогда не вызывовет исключения (если obj != null).

class Clock
    {
        public int Hours { get; set; }
        public int Minutes { get; set; }
        public int Seconds { get; set; }

        public override string ToString()//используется ключевое слово override для перопределения ToString
        {
            return $"{Hours}:{Minutes}:{Seconds}";
        }
    }
class Program
    {
        private static void Main(string[] args)
        {
            Clock clock = new Clock { Hours = 15, Minutes = 34, Seconds = 53 };
            Console.WriteLine(clock.ToString()); // выведет 15:34:53
             
            Console.Read();
        }
    }

------------------------------------------
Метод GetHashCode позволяет возвратить некоторое числовое значение(уникальное для каждого обекта), которое будет 
соответствовать данному объекту или его хэш-код. По данному числу, например, можно сравнивать объекты. 

 public string Name { get; set; }
 
    public override int GetHashCode()
    {
        return Name.GetHashCode();
    }

перопределние GetHashCode
 class human
    {
        public string Name { get; }

        public human(string name)
        {
            Name = name;
        }

        public override int GetHashCode()//перопределяем получение хашкода на проеку хешкода только имени 
        {
            return Name.GetHashCode();
        }
    }

human h = new human("Max");
human g = new human("Max");
Console.WriteLine($"client {h.GetHashCode()} ,clientone {g.GetHashCode()}" );//client 1627628113, 
//clientone 1627628113 hash коды одинаковые 

//тк мы проверяе хеш только имени
------------------------------------------
Метод GetType позволяет получить тип данного объекта

Person person = new Person { Name = "Tom" };
Console.WriteLine(person.GetType());   
В отличие от методов ToString, Equals, GetHashCode метод GetType не переопределяется.;
------------------------------------------
С помощью ключевого слова typeof мы получаем тип класса и сравниваем его с типом объекта. 
И если этот объект представляет тип Client, то выполняем определенные действия.

object person = new Person { Name = "Tom" };
if (person.GetType() == typeof(Person))
    Console.WriteLine("Это реально класс Person");

------------------------------------------
Equals(Object)  
Определяет, равен ли указанный объект текущему объекту.

Метод Equals принимает в качестве параметра объект любого типа, который мы затем приводим к текущему, 
если они являются объектами одного класса. Затем сравниваем по именам. Если имена равны, возвращаем true, что будет говорить,
 что объекты равны. Однако при необходимости реализацию метода можно сделать более сложной, например, сравнивать
 по нескольким свойствам при их наличии.
 
Метод Equals позволяет сравнить два объекта ПО ЗНАЧЕНИЮ а НЕ поссылке на равенство:

class Person
{
    public string Name { get; set; }
    public override bool Equals(object obj)
    {
        if (obj.GetType() != this.GetType()) return false;
 
        Person person = (Person)obj;
        return (this.Name == person.Name);
    }
}

Person person1 = new Person { Name = "Tom" };
Person person2 = new Person { Name = "Bob" };
Person person3 = new Person { Name = "Tom" };
bool p1Ep2 = person1.Equals(person2);   // false
bool p1Ep3 = person1.Equals(person3);   // true

------------------------------------------
Для типов значений == и Equals не имеет разницы, отличается ReferenceEquals, выдающий false, к примеру, для двух
 переменных типа int, равных 0 (потому, что сравнивает не значения, а ссылки). 
Для ссылочных типов эквивалентны  все три способа ==, Equals и ReferenceEquals,
сравнивать значения аналогично типам значений возможно только с помощью переопределения, как и описано в примере

 public class Money
{
   public decimal Amount { get; set; }
   public string Unit { get; set; }

   public Money(decimal amount, string unit)
   {
     Amount = amount;
     Unit = unit;
   }

  public override bool Equals(object obj)
   {
     if (obj == null)
       return false;
     Money m = obj as Money; // возвращает null если объект нельзя привести к типу Money
     if (m as Money == null)
       return false;

     return m.Amount == this.Amount && m.Unit == this.Unit;//сравнивает значения Amoun и Unit
     //из новосодданного нами обьекта класса моне и из сществуюещего обьека в ктором находися
     //переопреледяемый метод Equals
   }
}
class Program
{
   static void Main(string[] args)
   {
     Money m1 = new Money(100, "RUR");
     Money m2 = new Money(100, "RUR");
     Money m3 = new Money(100, "USD");
     Money m4 = m1;
     Console.WriteLine(m1.Equals(m2)); // true
     Console.WriteLine(m1.Equals(m3)); // false
     Console.WriteLine(m1 == m2); // false
     Console.WriteLine(m1 == m4); // true
     Console.ReadLine();
   }
}

------------------------------------------
ReferenceEquals сравниаает обьект не по занчению а по ссылке 
namespace TestReferenceEquality
    {
        struct TestStruct
        {
            public int Num { get; private set; }
            public string Name { get; private set; }

            public TestStruct(int i, string s) : this()
            {
                Num = i;
                Name = s;
            }
        }

        class TestClass
        {
            public int Num { get; set; }
            public string Name { get; set; }
        }

      
        class Program
        {
            static void Main()
            {
                // Demonstrate reference equality with reference types.
                #region ReferenceTypes

                // Создаем два экземпляра ссылочного типа с одинаковыми значениями.
                TestClass tcA = new TestClass() { Num = 1, Name = "New TestClass" };
                TestClass tcB = new TestClass() { Num = 1, Name = "New TestClass" };

                Console.WriteLine("ReferenceEquals(tcA, tcB) = {0}",
                                    Object.ReferenceEquals(tcA, tcB)); // false

                //  После присвоения tcB и tcA ссылаются на один и тот же объект.
                // Теперь у них есть ссылочное равенство.
                tcB = tcA;
                Console.WriteLine("After assignment: ReferenceEquals(tcA, tcB) = {0}",
                                    Object.ReferenceEquals(tcA, tcB)); // true

                // Изменения, внесенные в tcA, отражаются в tcB. Следовательно, объекты
                // которые имеют ссылочное равенство, также имеют равенство значений.
                tcA.Num = 42;
                tcA.Name = "TestClass 42";
                Console.WriteLine("tcB.Name = {0} tcB.Num: {1}", tcB.Name, tcB.Num);
                #endregion

                // Демонстрация того, что два экземпляра типа значения никогда не имеют ссылочного равенства.
                #region ValueTypes

                TestStruct tsC = new TestStruct(1, "TestStruct 1");

                // Типы значений копируются при присвоении. ЦД и ЦЦ имеют
                // одинаковые значения, но не один и тот же объект.
                TestStruct tsD = tsC;
                Console.WriteLine("After assignment: ReferenceEquals(tsC, tsD) = {0}",
                                    Object.ReferenceEquals(tsC, tsD)); // false
                #endregion

                #region stringRefEquality
                // Постоянные строки в одной сборке всегда интернируются средой выполнения.
                // Это означает, что они хранятся в одном месте в памяти. Следовательно,
                // две строки имеют ссылочное равенство, хотя присваивание не происходит.
                string strA = "Hello world!";
                string strB = "Hello world!";
                Console.WriteLine("ReferenceEquals(strA, strB) = {0}",
                                 Object.ReferenceEquals(strA, strB)); // true

                // After a new string is assigned to strA, strA and strB
                // are no longer interned and no longer have reference equality.
                strA = "Goodbye world!";
                Console.WriteLine("strA = \"{0}\" strB = \"{1}\"", strA, strB);

                Console.WriteLine("After strA changes, ReferenceEquals(strA, strB) = {0}",
                                Object.ReferenceEquals(strA, strB)); // false

                // После присвоения новой строки strA, strA и strB
                // больше не интернированы и больше не имеют ссылочного равенства.
                StringBuilder sb = new StringBuilder("Hello world!");
                string stringC = sb.ToString();
                // False:
                Console.WriteLine("ReferenceEquals(stringC, strB) = {0}",
                                Object.ReferenceEquals(stringC, strB));

                // Строка, созданная во время выполнения, не может быть интернирована.
                Console.WriteLine("stringC == strB = {0}", stringC == strB); //по значению строки ранны true
                Console.WriteLine("ReferenceEquals(stringC, strB) = {0}",
                    Object.ReferenceEquals(stringC, strB));//false строка не может быть инетрнироваа 
                //и потому по ссылке не совпадает 
                Console.WriteLine("ReferenceEquals(stringC, strB) = {0}",
                    Object.Equals(stringC, strB));//false строка не может быть инетрнироваа 
                //и потому по ссылке не совпадает 
                #endregion

                // Keep the console open in debug mode.
                Console.WriteLine("Press any key to exit.");
                Console.ReadKey();
            }
        }
    }
------------------------------------------
сравнение списков по муолчанию (именно содержимого а не ссылок)ListName1.SequenceEqual(ListName2);

public static bool SequenceEqual<T>( 
       this IEnumerable<T> first, 
       IEnumerable<T> second);
Эта операция перечисляет каждую входную последовательность параллельно, сравнивая элементы с помощью метода
 System.Object.Equals. Если элементы эквивалентны, и последовательности содержат одинаковое количество элементов, 
 операция возвращает true. Иначе она возвращает false.

*List, *сравнение *IEqualityComparer *Linq *SequenceEqual
static void Main(string[] args)
        {
            string[] strArr1 = {"0012", "130", "0000019", "4"};
            string[] strArr2 = {"12", "0130", "019", "0004"};
            
            bool eq = strArr1.SequenceEqual(strArr2, new MyStringifiedNumberComparer());//используем наш класс в качесвте опции сравнения

            Console.WriteLine(eq);
        }

        public class MyStringifiedNumberComparer : IEqualityComparer<string>//в генерик пишем знаение кторое идет в сравниаемых обьектах
        {
            public bool Equals(string x, string y)//переопределяем метод Equals взятый из IEqualityComparer
            {
                return (Int32.Parse(x) == Int32.Parse(y));//очищаем от лишних 00 впрееди наши строки преобразовоывая из в int 
                //тк 0012 нитов не бывает есть тольо 12 и тд
            }

            public int GetHashCode(string obj)//это необходимо для того чтобы сравнивать хеши обьектов те например хеш инта
                                              //12 и еще одного инта 12 будут равны
            {
                return Int32.Parse(obj).ToString().GetHashCode();
            }

        }

==========================================

--generics обобщения (--упаковка распкаовка boxing unboxing--)--генерики--
------------------------------------------
упаковка распкаовка

 class Account
    {
        public object Id { get; set; }
        public int Sum { get; set; }
    }

    Account acc1 = new Account();
    Account acc2 = new Account();

            //упкаовка и распкаовка ведут к снижению производительностьи и нарушению безопасности типа если
            // обьекты изменяются извне и мы можем не знать какие значения хранятся в этом обьекте если не те
            //к торым мы распаковываем происходит System.InvalidCastException

            //упаковка значнимый тип превращется в ссылочный, распокаовка это обратный процесс
            acc1.Id = 45;// происходит упаковка boxing, int упакаютеся в тип object
            int intID = (int)acc1.Id;//обратный процесс распокавка unboxing

            string intID = (string)acc1.Id;//выдаст ошибку изза нессотвтествия типов
            //упаковка значнимый тип превращется в ссылочный, распокаовка это обратный процесс
            acc2.Id = "55";// происходит упаковка boxing, int упакаютеся в тип object
            string str = (string)acc2.Id;//обратный процесс распокавка unboxing

            Console.WriteLine(str + intID);
            Console.Read();


------------------------------------------
generics
 //чтобы решить проблему упаковки распкаовки и проблему безопасноти типов исопльзуются обощения
    class Account<T>//это универсальный парметр всемто него можно пердать любой тип
    {
        public T Id { get; set; }
        public int Sum { get; set; }
    }
    class Program
    {
        static void Main(string[] args)
        {
            //после создания обьектов не происходит не упаковки не распкаовки
            Account<int> acc1 = new Account<int>();//тк класс теперь обобщенный нужно при создани экземпляра 
            //указать какой типа экземпляр будет использовать
            Account<string> acc2 = new Account<string>();//тк класс теперь обобщенный нужно прри создани экземпляра
            //указать какой типа экземпляр будет использовать

            acc1.Id = 11;
            Console.WriteLine(acc1.Id);
            Console.Read();
        }
    }
------------------------------------------
так же можно использовать класс с несколькими генериками и генерик с включенным в него классом с генериком

class Instantiator<U,V>
    {
        public U FromInstance { get; set; }
        public U ToInstance { get; set; }
        public V Code { get; set; }

    }
    class Account<T>
    {
        public T Id { get; set; }
        public int Sum { get; set; }
    }

class Program
    {
        static void Main(string[] args)
        {
            Account<int> acc1  = new Account<int>();
            //присваиваем значения для будущего их использования в генерике Instantiator<Account<int>,...
            acc1.Id = 10;
            acc1.Sum = 20;
            Account<int> acc2 = new Account<int>();
            //присваиваем значения для будущего их испольхования в генерике Instantiator<Account<int>,...
            acc2.Id = 30;
            acc2.Sum = 60;
            Account<string> acc3 = new Account<string>();

            Instantiator<Account<int>,string> i = new Instantiator<Account<int>, string>//кладем в обьект i наш класс 
            //Account с генериком int, а вторым генриком кладем простую строку
            {
                FromInstance = acc1,//кладем сюда экземпляр Acction<int>acc1 с вложеиями ввиде acc1.Id = 10 и
                // acc1.Sum = 20
                ToInstance = acc2,//кладем сюда экземпляр Acction<int>acc2 с вложеиями ввиде acc1.Id = 30 и
                // acc1.Sum = 60
                Code = "2520"//кладем сюда строку
            };

Console.WriteLine($"{i.FromInstance.Id} {i.FromInstance.Sum} {i.ToInstance.Id} {i.ToInstance.Sum} { i.Code}");

            Instantiator<int, string> j = new Instantiator<int, string>//здесь просто тандартный пример с двумя 
            //генериками в виде int и string
            {
                FromInstance = 20,
                ToInstance = 10,
                Code = "2010"
            };


------------------------------------------
Мы не можем использовать конструктор для создания объекта типа T. Если нам нужно создать значение по умолчанию,
то для этого необходимо использовать оператор default
 
 class Instantiator<T>
    {
        public T instance;
        public Instantiator()
        {
            instance = default(T);//здесь используется дефаулт
        }
    }

        static void Main(string[] args)
        {
            Instantiator<int> i = new Instantiator<int> {instance = 10};
            Console.WriteLine(i.instance);
        }

похоже в нет 5 можем
class Instantiator<T>
    {
        public T instance;
        public Instantiator(T instances)
        {
            instance = instances;//здесь используется дефаулт
        }
    }

     static void Main(string[] args)
        {
            Instantiator<int> i = new Instantiator<int>(2);

            Console.WriteLine(i.instance);
        }
------------------------------------------ 
так же можно использовать generics методы 

            int x = 10;
            int y = 30;
            //ref используется чтобы наш метод поменял значение непосредственно в перменных, а
            //не только внутри себя 
            Swap(ref x, ref y);
            //int x = 30; после работы метода в перменных выше будет так
            //int y = 10; после работы метода в перменных выше будет так

            string xx = "x";
            string yy = "y";

            Swap(ref xx, ref yy);
            // string xx = "y"; после работы метода в перменных выше будет так
            // string xx = "x"; после работы метода в перменных выше будет так

            void Swap<T>(ref T x, ref T y)
            {
                T temp = x;
                x = y;
                y = temp;
                Console.WriteLine($"x = {x},y = {y}");
            }

==========================================



--generic where ограничения обощений--
------------------------------------------
С помощью универсальных параметров мы можем типизировать обобщенные классы любым типом. 
Однако иногда возникает необходимость ограничить генерик определенным типом и его наследниками.

Делается это все потому что в этом случае будет идти преобразование типов. 
Параметризация generic <T> where : class позволяет избежать преобразований типов

В качестве ограничений мы можем использовать следующие типы:

Классы - универсальный параметр должен представлять ОПРЕДЕЛЕННЫЙ класс и его НАСЛЛЕДНИКОВ

Интерфейсы - универсальный параметр должен представлять ОПРЕДЕЛЕННЫЙ интерфейс и его РЕАЛИЗАЦИИ

class - универсальный параметр должен представлять класс

struct - универсальный параметр должен представлять структуру при этом использовать в качестве ограничения конкретные 
структуры в отличие от классов нельзя.

new() - универсальный параметр должен представлять тип, который имеет общедоступный (public) конструктор без параметров

------------------------------------------
//создадим класс Account  и его наследника Persone и DemandAcc
class Account
{
    public int Id { get; private set; } // номер счета
    public int Sum { get; set; }

    public Account(int _id)
    {
        Id = _id;
    }
}

class Persone : Account
{
    public string Name { get; set; }
    public Persone(int id, string name): base(id)
    {
        Name = name;
    }
}

class DemandAcc : Account
{
    public DemandAcc(int id) : base(id)
    {
        
    }
}


Следует учитывать, что  ТОЛЬКО ОДИН КЛАСС может использоваться в качестве ограничения

class Transaction<T> where T : Account// с помощью выражения where T : Account мы указываем,
// что используемый тип T обязательно должен быть классом Account или его наследником (в данном сллучае Persone)
{
    // Благодаря подобному ограничению мы можем использовать внутри класса Transaction
    // все объекты типа T именно как объекты Account и соответственно обращаться к их свойствам и методам.
    public T FromAccount { get; set; } // с какого счета перевод
    public T ToAccount { get; set; } // на какой счет перевод
    public T NameAccount { get; set; }

    public int Sum { get; set; } // сумма перевода

    public void Execute()
    {
        if (FromAccount.Sum > Sum)
        {
            FromAccount.Sum -= Sum;
            ToAccount.Sum += Sum;
            Console.WriteLine($"Счет {FromAccount.Id}: {FromAccount.Sum}$ \nСчет {ToAccount.Id}: {ToAccount.Sum},");//
            //благодаря where в перменные можно записать поля и методы относящиеся к классу которым ограничен данный генерик

            //Console.WriteLine($"Name{NameAccount.Name}");//вызовет ошибку тк это поле из наследника класса Account
        }
        else
        {
            Console.WriteLine($"Недостаточно денег на счете {FromAccount.Id}");
        }
    }
}

 
class Program
{
    static void Main(string[] args)
    {
        
        Account acc1 = new Account(1) {Sum = 4500};//создаем класс Account Id = 1, Sum = 4500
        Account acc2 = new Account(2) {Sum = 5000};

        //используем класс наследник который исполльзует передачу данных через конструктор в класс родитель
        DemandAcc acc3 = new DemandAcc(3){Sum = 10000};
        DemandAcc acc4 = new DemandAcc(4){Sum = 3000};

        Transaction<Account> transaction1 = new Transaction<Account>//использумем указанный в  where T : Account класс
        {
            FromAccount = acc1,  
            ToAccount = acc2,
            Sum = 300
        };

        transaction1.Execute();

        Transaction<DemandAcc> transaction2 = new Transaction<DemandAcc>//использумем наследника указанного 
        //в where T : Account класса Account
           {
               FromAccount = acc3,//если бы в классе Transaction мы вместо типа T FromAccount, использовали бы тип 
               //Account FromAccount, в это строчук мы получили бы апкаст тк как acc3 чтобы присвоится в переменную FromAccaunt 
               //которая в нашем случае является Account, те классом родителем, нам пришлоь бы произвести апкаст 
               //преобразование от производного к базовому классу

               ToAccount = acc4,//если бы в классе Transaction мы вместо типа T FromAccount, использовали бы тип 
               //Account FromAccount, в это строчук мы получили бы апкаст тк как acc3 чтобы присвоится в переменную FromAccaunt 
               //которая в нашем случае является Account, те классом родителем, нам пришлоь бы произвести апкаст 
               //преобразование от производного к базовому классу
               Sum = 6900
           };

        DemandAcc acc5 = (DemandAcc)transaction2.FromAccount;//и если бы мы захотели бы получить обрантно данный обьект в 
        //перепенную DemandAcc нам пришлось бы произсодить даункаст,но в случаее если бы мы использволи where T : Account 
        //этого делать не пришлось -> DemandAcc acc5 = transaction2.FromAccount;
        DemandAcc acc6 = (DemandAcc)transaction2.ToAccount;//и если бы мы захотели бы получить обрантно данный обьект в 
        //перепенную DemandAcc нам пришлось бы произсодить даункаст,но в случаее если бы мы использволи where T : Account 
        //этого делать не пришлось -> DemandAcc acc5 = transaction2.FromAccount;
        ransaction2.Execute();

        Console.ReadLine();
    }
}


------------------------------------------
В качестве ограничения также может выступать и обобщенный класс

class Account<T>//Класс Account же может быть типизирован абсолютно любым типом
   {
       public T Id { get; private set; } // номер счета
       public int Sum { get; set; }
       public Account(T _id)
       {
           Id = _id;
       }
   }
   class Transaction<T> where T : Account<int>//В данном случае класс Transaction типизирован классом Account<int>
       // класс Transaction может использовать только объекты класса Account<int> или его наследников
   {
       public T FromAccount { get; set; }  // с какого счета перевод
       public T ToAccount { get; set; }    // на какой счет перевод
       public int Sum { get; set; }        // сумма перевода

       public void Execute()
       {
           if (FromAccount.Sum > Sum)
           {
               FromAccount.Sum -= Sum;
               ToAccount.Sum += Sum;
               Console.WriteLine($"Счет {FromAccount.Id}: {FromAccount.Sum}$ \nСчет {ToAccount.Id}: {ToAccount.Sum}$");
           }
           else
           {
               Console.WriteLine($"Недостаточно денег на счете {FromAccount.Id}");
           }
       }
   }

   class Program
   {
       static void Main(string[] args)
       {
           Account<int> acc1 = new Account<int>(1857) { Sum = 4500 };
           Account<int> acc2 = new Account<int>(3453) { Sum = 5000 };

           Transaction<Account<int>> transaction1 = new Transaction<Account<int>>
           {
               FromAccount = acc1,
               ToAccount = acc2,
               Sum = 300
           };

            transaction1.Execute();

           Account<string> acc1 = new Account<string>("34") { Sum = 4500 };
           Account<string> acc2 = new Account<string>("45") { Sum = 5000 };
       
           //так нельзя написать,
           //так как Bank должен быть типизирован классом Account<int> или его наследником
           Transaction<Account<string>> transaction2 = new Transaction<Account<string>>
           {
              FromAccount = acc1,
               ToAccount = acc2,
               Sum = 900
           };

           Console.Read();
       }
   }

------------------------------------------
Есть ряд стандартных ограничений, которые мы можем использовать. можно задать в качестве ограничения ссылочные типы:
в частности, можно указать ограничение, чтобы использовались только структуры или другие типы значений 

------------------------------------------
ограничение структуой

class Transaction<T>  where T : struct
{
    public T FromAccount { get; set; } // с какого счета перевод
    public T ToAccount { get; set; } // на какой счет перевод
}

Transaction<int> transaction3 = new Transaction<int>//тк int предстявляет собой струтктуру
   //мы можем сделать так
   {
       //соответвенно теперь нужно предостаивть FromAccount и ToAccount числовые значения
       FromAccount = 123,
       ToAccount = 321,  
   };

--

struct My
    {
        public int Id { get; set; }
        public int Sum { get; set; }

    }

    class Transaction<T> where T : struct
    {
        public T FromAccount { get; set; } // с какого счета перевод
        public T ToAccount { get; set; } // на какой счет перевод
    }



    class Program
    {
        static void Main(string[] args)
        {
            My my;
            Transaction<My> transaction3 = new Transaction<My>//тк My предстявляет собой струтктуру мы можем сделать так
            {
                //соответвенно теперь нужно предостаивть FromAccount и ToAccount новосозданной структуры
                FromAccount = new My
                {
                    Id = 50,
                    Sum = 100
                },

                ToAccount = new My
                {
                    Id = 5,
                    Sum = 1000
                },
            };

            //НО при этом использовать в качестве ограничения конкретные те (имена структур) структуры в отличие от классов нельзя!
            Transaction<myy> transaction3 = new Transaction<my>//так делать нелья!
            {
                ...
            };
            Console.ReadLine();

        }
    }

------------------------------------------
ограничение классом
Означает, что тип T должен быть ссылочным типом (а не типом значения).
Это означает T не может быть int, float, double, DateTimeили любой другой struct(тип значения).
Это может быть stringили любой другой пользовательский ссылочный тип, если он имеет конструктор по умолчанию или без параметров.

class Transaction<T> where T : class
{}

------------------------------------------
ограничение new()

А также можно задать с помощью слова new в качестве ограничения класс или структуру, которые имеют общедоступный 
конструктор без параметров


class Transaction<T> where T : new()//это значит что ограничивающеи генерик 
//тип дожен поределять констуктор по умолчанию без парметров 
{
    ...
}
class Account//такой обьект впишется в ограничение генерика сверху
    {
        public int Id { get;  set; } 
        public int Sum { get; set; }
        public Account(int _id)
        {
            Id = _id;
        }
        public Account()//для этого нужно просто опеределить вот такой констурктор по умолчанию
        {
            
        }
    }

------------------------------------------
Если для универсального параметра задано несколько ограничений, то они должны идти в определенном порядке
1 Название класса, class, struct. Причем мы можем одновременно определить только одно из этих ограничений. 

2Название интерфейса.

3 new()

interface IAccount
{
    int CurrentSum { get; set;}
}
class Person
{
    public string Name { get; set; }
}
 
class Transaction<T> where T: Person, IAccount, new()//1 Название класса, class, struct
//2Название интерфейса
//3 new()
{
 ...
}

------------------------------------------
Использование нескольких универсальных параметров

class Transaction<U, V>
        where U : Account<int>//Если класс использует несколько универсальных параметров,
        // то последовательно можно задать ограничения к каждому из них
        where V : struct//Если класс использует несколько универсальных параметров, 
        //то последовательно можно задать ограничения к каждому из них

------------------------------------------
Ограничения методов

Подобным образом можно использовать и ограничения методов

private static void Main(string[] args)
{
    Account<int> acc1 = new Account<int>(1857) { Sum = 4500 };
    Account<int> acc2 = new Account<int>(3453) { Sum = 5000 };
 
    Transact<Account<int>>(acc1, acc2, 900);
 
    Console.Read();
}
 
public static void Transact<T>(T acc1, T acc2, int sum) where T : Account<int>//Метод Transact в качестве ограничения
// принимает тип Account<int>.
    if (acc1.Sum > sum)
    {
        acc1.Sum -= sum;
        acc2.Sum += sum;
    }
    Console.WriteLine($"acc1: {acc1.Sum}   acc2: {acc2.Sum}");
}
==========================================


--generic наследование--
------------------------------------------
Один обобщенный класс может быть унаследован от другого обобщенного. При этом можно использовать различные 
варианты наследования.

class Account<T>//Допустим, у нас есть следующий базовый обощенный класс Account
    {
        public T Id { get; private set; }
        public Account(T _id)
        {
            
            Id = _id;
        }
    }
    
    
    class UniversalAccount<T> : Account<T>//создание класса-наследника,
        //который типизирован тем же типом, что и базовый
    {
        private T ss;
        
    public UniversalAccount(T id) : base(id)
        {
             
        }
    }

    class StringAccount : Account<string>//в случае создание обычного
        //необобщенного класса-наследника у базового класса надо явным
        //образом определить используемый тип
    {
        public StringAccount(string id) : base(id)
        {
        }
    }

    class IntAccount<T> : Account<int>//Третий вариант представляет типизацию
        //производного класса параметром совсем другого типа, отличного от
        //универсального параметра в базовом классе. В этом случае для
        //базового класса также надо указать используемый тип:
    {
        public T Code { get; set; }
        public IntAccount(int id) : base(id)
        {
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Account<string> acc1 = new Account<string>("34");//реализация базвого класса 
            Account<int> acc3 = new UniversalAccount<int>(45);//апкаст класса наследника
            UniversalAccount<int> acc2 = new UniversalAccount<int>(33);//реализщация
            //класса наследника типизированого тем же типмо что и рожител
            Console.WriteLine(acc1.Id);
            Console.WriteLine(acc2.Id);
            Console.WriteLine(acc3.Id);
            
            //Теперь в производном классе в качестве типа будет использоваться тип string
            StringAccount acc4 = new StringAccount("43876");//реалищзация наследника 
            //без обощения тк оно уже опредено на этапео создания этого класа
            Account<string> acc5 = new StringAccount("43875");//при апкасте следует
            //у класса родителя указывать испольлзуемый тип
            Console.WriteLine(acc4.Id);
            Console.WriteLine(acc5.Id);
            
            IntAccount<string> acc7 = new IntAccount<string>(5) { Code = "r4556" };//реалищзация 
            //наследникаc с отличным от родителя генериком
            //тип в родительнсом классе  может не совпадать с типом, который
            // используется базовым классом
            
            Account<int> acc8 = new IntAccount<long>(7) { Code = 4587 };//при апкасте
            // тип в родительнсом классе  может не совпадать с типом, который
            // используется базовым классом
            Console.WriteLine(acc7.Id + " " + acc7.Code);
            Console.WriteLine(acc8.Id);
              
        }
    }
==========================================



--Исключения(Exception)--
------------------------------------------
 вначале выполняются все инструкции в блоке try если в этом блоке не возникло исключений, 
 то после его выполнения начинает выполняться блок finally

 Если же в блоке try возникает исключение, порядок выполнения останавливается,
 и среда CLR начинает искать блок catch, который может обработать данное исключение. 
 Если нужный блок catch найден, то он выполняется, и после его завершения выполняется блок finally.

 try
{
     
}
catch
{
     
}
finally//выполнится в любом члуче елси возникет исключение или если не возникнет
//При наличии блока catch мы можем опустить блок finally
{
     
}

InnerException: хранит информацию об исключении, которое послужило причиной текущего исключения

Message: хранит сообщение об исключении, текст ошибки

Source: хранит имя объекта или сборки, которое вызвало исключение

StackTrace: возвращает строковое представление стека вызывов, которые привели к возникновению исключения

TargetSite: возвращает метод, в котором и было вызвано исключение

------------------------------------------
типы исключений

Exception общий или стандартный тип исключений

            catch (Exception e)
            {
                 Console.WriteLine(ex.Message);//Message: хранит сообщение об исключении, текст ошибки
                 //в этом члучае на консоль будет выведено сообщение исключения
            }
остальные типы сиключений исплюзуются когода мы хотим обработтаь только лишь сиключение этого типа 
можно использзовать несоклькок блоков catch чтобы обработать несоклько разных исключений и чтобы 
обработатть их по разному 


IndexOutOfRangeException возмникает при присовению по индексу вне границ массива

            catch (IndexOutOfRangeException ex)
            {
                Console.WriteLine(ex.Message);
            }

DivideByZeroException возмникает при попытке деления на 0 
            catch (DivideByZeroException ex)
            {
                Console.WriteLine(ex.Message);
            }

НО если мы получим какоето иное от этих исключений исключение программа арварийно завершится 
для этого следует в коенце записать стандартный тип исключений;

НО если мы испобьзуем стандратныый тип исключений в купе с нестандартными типами нам необходим помещать 
стандартный в самый конец иначе он будет брать на себя обработку специализированых типа DivideByZeroException
и смысла в них тогда не будет

            catch (Exception e)
            {
                 Console.WriteLine(ex.Message);//в эом члучае на консоль будет выведено сообщение исключения
            }
------------------------------------------
собтвенные исключения 

  try
            {
                Console.WriteLine("write string");
                var mes = Console.ReadLine();

                if (mes.Length > 6)//определим условие для нашего и исключения тру попытается выполнить уловие в ифе
                //если выолпнит выоброится наше ичключение
                {
                    throw new Exception("длина строки больше 6 символов"); //этот оператор используется для
                     //генерации созданного нами исключения,после этого оператора указывается обьект 
                     //исключения например new Exception("сюда можно записать собобщение которое будет 
                     //показываатся при исключении");а посколькку здесь указано исключение типа Exception 
                     //то обрабатываться оно будет в соотвтетвующем блоке catch
                }

                //в случае выпадения исключения дльнейший код НЕ выполняется
                Console.WriteLine("End of try block");
            }

            catch (DivideByZeroException e)
            {
                Console.WriteLine(e);
            }
            catch (Exception e
            ) //обрабатыватся это исключение (throw new Exception("длина строки больше 6 символов")) будет здесь
            {
                Console.WriteLine($"Ошибка строки: {e.Message}"); // Ошибка строки: длина строки больше 6 символов
            }

            finally
            {
                Console.WriteLine("Finally block");
            }
            Console.ReadLine();
------------------------------------------
собтвенные исключения класс

 class MyExtention : Exception//так же можно создавать собтвенные
        //КЛАССЫ наследованые от исключения Exception или можно 
        //взять какой-нибудь другой производный тип нпмриер  или ArgumentException

    {
        public MyExtention(string mes) : base(mes)//По сути класс кроме пустого конструктора ничего не имеет,
        // и то в конструкторе мы просто обращаемся к конструктору базового класса Exception, 
        //передавая в него строку message
        {
            
        }
    }

 static void Main(string[] args)
        {

            try
            {
                
                if (mes.Length < 4)//определим условие для нашего и исключения тру попытается выполнить уловие в ифе
                //если выолпнит выбросится наше икслючение кторое мы записали ниже
                {
                    throw new MyExtention("длина строки меньше 4 символов");//этот оператор используется для 
                    //генерации исключения, после этого оператора указывается обьект исключения в данном 
                    //случае это наш собственный класс текст из скобок подставиться в Extention.Message 
                    //при выбрасывании исключения
                }

                //в случае выпадения исключения дльнейший код НЕ выполняется
                 Console.WriteLine("End of try block");

            }
            catch (MyExtention myExtention)//в случае если мы определим наш класс отдельным исключением при вызове 
            //нешго исключения сработает ьело данного кетча если же ммы не определим наш класс сработает 
            //стандарный Exception если он есть 
            {
                Console.WriteLine($"Ошибка: {myExtention.Message} (собственный класс)");//Ошибка: 
                //длина строки меньше 4 символов (собственный класс)

            }

            catch (Exception e)//если мы не определим собственное исключение как сделано выше сработает 
            //стандарный Exception если он есть 
            {
                Console.WriteLine($"Ошибка строки: {e.Message}"); // Ошибка строки: длина строки меньше 4 символов
            }
------------------------------------------
собственные исключения класс допольнительные свойства 

class PersonException : Exception
   {
       //доавляем поля для допольнительной информации о нашем исключеннии
       public int Value { get; } 
       public string Name { get; }
       public PersonException(string message, int val, string name)
           : base(message)//также мы можнм определять в конутркторе
       //нашего исключения дополнительные свойства val и name
       {
           Value = val;
           Name = name;
       }
   }

class Person
    {
        public string Name { get; set; }
        private int age;
        public int Age
        {
            get { return age; }
            set
            {
                if (value < 18)
                    throw new PersonException(
                        "Лицам до 18 регистрация запрещена", value, Name);//добавляем наши
                //довольнительнгые свойства для вывода при выбросе исключения 
                else
                    age = value;
            }
        }
    }

 static void Main(string[] args)
        {

            try
            {
                Person p = new Person { Name = "Tom", Age = 13 };
            }
            catch (PersonException ex)
            {
                Console.WriteLine($"Ошибка: {ex.Message}");//Лицам до 18 регистрация запрещена

                //при выброске наешго исключения помимо сообщения из свойства Message мы получим и наши дпольнительные свойства
                Console.WriteLine($"Некорректное значение: {ex.Value}");//Некорректное значение: 13
                Console.WriteLine($"Имя субъекта: {ex.Name}");// Имя субъекта: Tom
            }
        }   
------------------------------------------
Поиск блока catch при обработке исключений

 данном случае стек вызовов выглядит следующим образом: метод Main вызывает метод Method1, который, 
 в свою очередь, вызывает метод Method2. И в методе Method2 генерируется исключение 
 DivideByZeroException. 

    class TestClass
    {
        public static void Method1()
        {
            try
            {
2               Method2();//2. тот вызывает метод Method2
            }
5           //5. Система также ищет в этой конструкции блок catch, который обрабатывает
            //исключение DivideByZeroException. Однако здесь также подобный блок catch отсутствует.

            //catch (DivideByZeroException ex) // Однако такого блока catch так же нет
            //{
            //}
            catch (IndexOutOfRangeException ex)
            {
                Console.WriteLine($"Catch в Method1 : {ex.Message}");
            }
10           finally//10. Далее система возвращается по стеку вызовов вниз в метод Method1
                   //и выполняет в нем блок finally
            {
                Console.WriteLine("Блок finally в Method1");
            }
            Console.WriteLine("Конец метода Method1");
        }
        static void Method2()
        {
            //Система видит, что код, который вызывал исключение, помещен в конструкцию try..catch
            try
            {
                int x = 8;
3               int y = x / 0; //3. в метод Method2 генерируется исключение DivideByZeroException

4               
            }
            //4. Система ищет в этой конструкции блок catch, который обрабатывает исключение
            //DivideByZeroException. Однако такого блока catch нет.

            //catch(DivideByZeroException ex)// Однако такого блока catch нет
            //{
            //}

9           finally//9. Система поднимается обратно по стеку вызовов в самый верх в метод Method2
                   //и выполняет в нем блок finally
            {
                Console.WriteLine("Блок finally в Method2");
            }
            Console.WriteLine("Конец метода Method2");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            try
            {
1               TestClass.Method1();//1. Метод Main вызывает метод Method1
            }
6           //6. Система далее опускается в стеке вызовов в метод Main, который вызывал Method1.
            //Здесь вызов Method1 помещен в конструкцию try..catch

7           //7. Система снова ищет в этой конструкции блок
            //catch, который обрабатывает исключение DivideByZeroException. И в
            //данном случае ткой блок найден.

8           //8. Система наконец нашла нужный блок catch в методе Main, для обработки
            //исключения, которое возникло в методе Method2 - то есть к начальному методу,
            //где непосредственно возникло исключение. Но пока данный блок catch НЕ выполняется.

11          catch (DivideByZeroException ex) //11. Затем система переходит по стеку вызовов вниз в
                //метод Main и выполняет в нем найденный блок catch
            {
                Console.WriteLine($"Catch в Main : {ex.Message}");
            }
12          finally//12. и последующий блок finally
            {
                Console.WriteLine("Блок finally в Main");
            }
13          //13. Далее выполняется код, который идет в методе Main после конструкции try..catch
            Console.WriteLine("Конец метода Main");
            Console.Read();
        }
    }

------------------------------------------
try//внешний блок тру
{
    try//внутренний блолк тру
    {
        Console.Write("Введите строку: ");
        string message = Console.ReadLine();
        if (message.Length > 6)
        {
            throw new Exception("Длина строки больше 6 символов");//В данном случае при вводе 
            //строки с длиной больше 6 символов возникнет исключение
        }
    }
    catch//внутренний блок кетч,сперва исключение обрабывтвается здесь 
    {
        Console.WriteLine("Возникло исключение");//выодится на консокл сообщение "Возникло исключение"
        throw;//если пристувутет этот оператор то иклюлчение передается дальше внешнему блоку кетч, 
        //если его нет то програма аварийно завершится так как исключению негде буде обратбатыватся
    }
}
catch (Exception ex)//внешний блолк кетч, сюда передатся исключение при отрабатвании оператора throw
{
    Console.WriteLine(ex.Message);
}
------------------------------------------
фильтры исключений

В этом случае обработка исключения в блоке catch производится только в том случае, если условие в выражении when 
истинно.
catch when(условие)
{    

}

например 

int x = 1;
int y = 0;
 
try
{
    int result = x / y;
}
catch(DivideByZeroException) when (y==0 && x == 0)// если y =! 0 и x != 0 то оно не будет обрабатывать
//исключение так как условие, указанное после оператора when возвращает false
//Поэтому CLR будет дальше искать соответствующие блоки catch далее и для обработки исключения выберет 
//второй блок catch. 
{
    Console.WriteLine("y не должен быть равен 0");
}
catch(DivideByZeroException ex) //вот этот блок будет выбран если условие первого не будет соблюдено
{
    Console.WriteLine(ex.Message);
}
------------------------------------------
условные конструкции

С точки зрения производительности использование блоков try..catch более накладно,
чем применение условных конструкций. Поэтому по возможности вместо try..catch лучше 
использовать условные конструкции на проверку исключительных ситуаций.

чаще всего гораздо оптимальнее было бы проверить допустимость преобразования

//птыается преобразовать строковое представление числа input
 //в эквивалентное 32-битовое знаковое целое число x, и возрващает его в тело условной контрукции,
 //если преобразование успешно, если преобзрахоавние не удалосчь прграмма идт дальше без 
 //выполнения тела условной констуркции
if (Int32.TryParse(input, out x))
{
    x *= x;
    Console.WriteLine("Квадрат числа: " + x);
}
else
{
    Console.WriteLine("Некорректный ввод");
}

------------------------------------------
циклический вызов try...catch просто применив рекурсию, обернув блок в функцию:

public int GetInput()
{
try
{
int input = Int32.Parse(Console.ReadLine());
return input;
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
return GetInput();
}
}

var gg = Num(Console.ReadLine());

static int Num(string num)
        {

            int ss = 20;
            var gg = int.Parse(num);

            try
            {
                ss = ss / gg;
            }
            catch (DivideByZeroException ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine("число не должно быть 0");
                return Num(Console.ReadLine());//нужно сделать возрващение
                // чтобы код не возрващал оригиальное значение ss
            }


            return ss;
        }

------------------------------------------
К слову сказать, лучше юзать throw ex только в самом начале стека вызова, а во всех последующих throw, 
так как throw ex резетит Stack Trace, и отследить начальную функцию, в которой было вызвано исключение
 уже намного сложнее.

==========================================



--Интерфейсы--interface--
------------------------------------------
Интерфейс представляет ссылочный тип, который может определять некоторый функционал - 
набор методов и свойств без реализации

разница между интерфейсом и абстарктным классом в том что Абстрактный класс — это класс,
 у которого не реализован один или больше методов (некоторые языки требуют такие методы помечать специальными ключевыми словами).
Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.

Что может определять интерфейс? В целом интерфейсы могут определять следующие сущности:
Методы
Свойства
Индексаторы
События
Статические поля и константы (начиная с версии C# 8.0)

НО интерфейсы НЕ могут определять нестатические переменные!

Интерфейсы так же не могут иметь модификатор abstract.

интерфейсы по умолчанию имеют уровень доступа internal
с помощью модификатора public мы можем сделать интерфейс общедоступным:

public interface IMovable
{
    void Move();
}
по умолчанию все методы, свойства и перменные имеют модификатор доступа public 
так как цель интерфейса - определение функционала для реализации его классом.

При этом класс ДОЛЖЕН реализовать ВСЕ методы и свойства применяемых интерфейсов, 
ТОЛЬКО если эти методы и свойства НЕ ИМЕЮТ реализации по умолчанию.

Как и классы, интерфейсы по умолчанию имеют уровень доступа internal
если мы подключаем к классу интерфейс то необходимо реализовать все поля и методы интерфейса

  interface IFoo
    {
        void Execute();
    }
    interface IBar
    {
        void Execute();
    }
    class Tester : IFoo, IBar//вызовет ошибку тк  нужно реализовтаь метод Execute 
    //из интереффейса IBar
    {
        void IFoo.Execute()
        {
            Console.WriteLine("IFoo Executes");
        }
    }

Но также, начиная с версии C# 8.0, мы можем явно указывать модификаторы доступа у компонентов интерфейса:

interface IMovable
{
    public const int minSpeed = 0;     // минимальная скорость
    private static int maxSpeed = 60;   // максимальная скорость
    public void Move();
    protected internal string Name { get; set; }    // название
    public delegate void MoveHandler(string message);  // определение делегата для события
    public event MoveHandler MoveEvent;    // событие движения

------------------------------------------
Когда следует использовать интерфейсы:

Если нам надо определить функционал для группы разрозненных объектов, которые могут быть никак не связаны между собой.

Если мы проектируем небольшой функциональный тип

логичность использования можно свести к следующему принципу: если классы НЕ относятся к единой системе классификации, то выбирается интерфейс 

елси обьекты например средвта пережвижения свзяаные какимто ообщим свойсмсвом по факту являются малосвязанными между собой сущностями, 
то для определения общего для всех них функционала лучше определить интерфейс. 
Тем более некоторые из этих объектов могут существовать в рамках параллельных систем классификаций.
Например, лошадь может быть классом в структуре системы классов животного мира.


public interface IMovable//Теперь метод Move() определяется в интерфейсе IMovable
{
    void Move();
}
 
public abstract class Vehicle
{}
 
public class Car : Vehicle, IMovable//тут мы можем реализовывать несоклько интерфейсов и одновременно и наследовать от класса
{
    public void Move()// конкретные классы  реализуют метоод из интерфейса
    {
        Console.WriteLine("Машина едет");
    }
}
 
public class Bus : Vehicle, IMovable //тут мы можем реализовывать несоклько интерфейсов и одновременно и наследовать от класса
{
    public void Move()// конкретные классы  реализуют метоод из интерфейса
    {
        Console.WriteLine("Автобус едет");
    }
}
 
public class Hourse : IMovable //тут мы можем реализовывать несоклько интерфейсов 
{
    public void Move()// конкретные классы  реализуют метоод из интерфейса
    {
        Console.WriteLine("Лошадь скачет");
    }
}
 
public class Aircraft : IMovable//тут мы можем реализовывать несоклько интерфейсов
{
    public void Move()// конкретные классы  реализуют метоод из интерфейса
    {
        Console.WriteLine("Самолет летит");
    }
}


Говоря об использовании абстрактных классов и интерфейсов можно привести еще такую аналогию, 
как состояние и действие. Как правило, абстрактные классы фокусируются на общем состоянии классов-наследников.
 В то время как интерфейсы строятся вокруг какого-либо общего действия.

Например, солнце, костер, батарея отопления и электрический нагреватель выполняют функцию нагревания или излучения тепла. 
По большому счету выделение тепла - это единственный общий между ними признак. Можно ли для них создать общий абстрактный класс?

Можно, но это не будет оптимальным решением, тем более у нас могут быть какие-то родственные сущности, которые мы, возможно, 
тоже захотим использовать. Поэтому для каждой вышеперечисленной сущности мы можем определить свою систему классификации. 
Например, в одной системе классов, которые наследуются от общего астрактного класса, были бы звезды, в том числе и солнце, 
планеты, астероиды и так далее - то есть все те объекты, которые могут иметь какое-то общее с солнцем состояние. 
В рамках другой системы классов мы могли бы определить электрические приборы, в том числе электронагреатель. 
И так, для каждой разноплановой сущности можно было бы составить свою систему классов, исходяющую от определенного
 абстрактного класса. А для общего действия определить интерфейс, например, IHeatable, в котором бы был метод Heat, 
 и этот интерфейс реализовать во всех необходимых классах.

Таким образом, если разноплановые классы обладают каким-то общим действием, 
то это действие лучше выносить в интерфейс. А для одноплановых классов, которые имеют общее состояние, лучше определять абстрактный класс.

------------------------------------------
Применение интерфейсов

В данной программе определен метод Action(), который в качестве параметра принимает объект интерфейса 
IMovable. На момент написания кода мы можем не знать, что это будет за объект -
какой-то класс или структура. Единственное, в чем мы можем быть уверены, 
что этот объект обязательно реализует метод Move и мы можем вызвать этот метод.

 interface IMovable
    {
        void SS();
    }
    class Person : IMovable//обьект интерфейса IMovable
    {
        public int I;
        public Person(int i)
        {
            I = i;
        }
        
        public void SS() //этот объект обязательно должен реализовать метод Move и мы можем вызвать этот метод.
        {
            
            if (I < 5)
            {
                Console.WriteLine("челове идет");
            }
            else
            {
                Console.WriteLine("челове плющися");
            }
        }
    }
    struct Car : IMovable//обьект интерфейса IMovable
    {
        public void SS() //этот объект обязательно должен реализовать метод Move и мы можем вызвать этот метод.
        {
            Console.WriteLine("Машина едет");
        }
    }
    class Program
    {
        static void Action(IMovable movable)//это метод в качестве параметра принимает объект интерфейса IMovable
                                            //мы можем не знать, что это будет за объект - какой-то класс или структура.
                                            //этот объект обязательно должен реализовать метод SS и мы можем вызвать этот метод.
        {
            movable.SS();//вызваем метод SS можем и не вызывать
        }
        static void Main(string[] args)
        {
            Person person = new Person(3);
            Car car = new Car();
            
            Action(car);// Move и мы можем вызвать этот метод вывод: Машина едет
            Console.Read();
        }
    }
   интерфейс это контракт, что какой-то определенный тип обязательно реализует некоторый функционал

------------------------------------------
реализация методов и свойств интерфейсов по умолчанию

Начиная с версии C# 8.0 интерфейсы поддерживают реализацию методов и свойств по умолчанию. 
Зачем это нужно? Допустим, у нас есть куча классов, которые реализуют некоторый интерфейс. 
Если мы добавим в этот интерфейс новый метод, то мы будем обязаны реализовать этот метод во всех классах,
применяющих данный интерфейс. Иначе подобные классы просто не будут компилироваться.
НО в 8.0 вместо реализации метода во всех классах нам достаточно определить его реализацию по умолчанию в интерфейсе.
Если класс НЕ РЕАЛИЗУЕТ метод, будет применяться реализация ПО УМОЛЧАНИЮ.

 class Program
    {
        static void Main(string[] args)
        {
            IMovable tom = new Person();//для объекта класса Person мы можем вызвать метод Move -
            //ведь класс Person применяет интерфейс IMovable
            tom.Move();     // Walking

            Car tesla = new Car();
            tesla.Move();   // Driving

            Person tom2 = new Person();
            tom2.Move();// Ошибка - метод Move не определен в классе Person
        }
    }

    interface IMovable
    {
        void Move()
        {
            Console.WriteLine("Walking");
        }
    }
    class Person : IMovable { }//используется реализация метода Move по муолманию те вывод на консоль Walking
    class Car : IMovable
    {
        public void Move()//перопределение метода вывод на консоль Driving
        {
            Console.WriteLine("Driving");
        }
    }
} 

С реализацией свойств по умолчанию в интерфейсах дело обстоит несколько сложнее, 
поскольку мы не можем определять в интерфейсах нестатические переменные, соответственно
 в свойствах интерфейса мы не можем манипулировать состоянием объекта. Тем не менее реализацию 
 по умолчанию для свойств мы тоже можем определять

 interface IMovable
{
    public const int minSpeed = 0;     // минимальная скорость

    //перменная с модифиаткором private
    private static int maxSpeed = 60;   // максимальная скорость
        // находим время, за которое надо пройти расстояние distance со скоростью speed

    static double GetTime(double distance, double speed) => distance / speed;
    static int MaxSpeed
    {
        get { return maxSpeed; }
        set
        {
            if (value > 0) maxSpeed = value;
        }
    }
}
Стоит отметить, что если интерфейс имеет приватные методы и свойства (то есть с модификатором private),
то они должны иметь реализацию по умолчанию. То же самое относится к любым статическим методам
и свойствам (не обязательно приватным)

 
------------------------------------------
Множественная реализация интерфейсов

к классу можно полдключать сразу несоклько интрефейсов

interface IFoo
{
    void Execute();
}
interface IBar
{
    void Execute();
}
class Tester : IFoo, IBar
{
    public void Execute()
    {
        Console.WriteLine("Tester Executes");
    }
}

или так 

 interface IAccount
    {
        int CurrentSum { get; } // CurrentSum похож на автосвойство, но это не автосвойство. 
        //При реализации мы можем развернуть его в полноценное свойство, либо же сделать автосвойством

        void Put(int sum); // Положить деньги на счет
        void Withdraw(int sum); // Взять со счета


    }

    interface IClient
    {
        string Name { get; set; }//Name похож на автосвойство, но это не автосвойство. 
        //При реализации мы можем развернуть его в полноценное свойство, либо же сделать автосвойством
    }

    class Client : IAccount, IClient
    {
        int _sum; // Переменная для хранения суммы
        public string Name { get; set; }

        public Client(string name, int sum)
        {
            Name = name;
            _sum = sum;
        }

        public int CurrentSum
        {
            get { return _sum; }
        }

        public void Put(int sum)
        {
            _sum += sum;
        }

        public void Withdraw(int sum)
        {
            if (_sum >= sum)
            {
                _sum -= sum;
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Client client = new Client("Tom", 200);
            client.Put(30);
            Console.WriteLine(client.CurrentSum); //230
            client.Withdraw(100);
            Console.WriteLine(client.CurrentSum); //130

//  Необходимо явно указать, реализацию какого интерфейса мы хотим использовать, например, 
 //с помощью операции приведения типов:

            // Все объекты Client являются объектами IAccount 
            IAccount account = new Client("Том", 200);
            account.Put(200);
            Console.WriteLine(account.CurrentSum); // 400
            // Не все объекты IAccount являются объектами Client, необходимо явное приведение
            Client client2 = (Client)account;
            // Интерфейс IAccount не имеет свойства Name, необходимо явное приведение
            string clientName = ((Client)account).Name;
            Console.Read();
        }
    }
еще один пример 

 interface IFoo
    {
        void Execute();
    }
    interface IBar
    {
        void Execute();
    }
    class Tester : IFoo, IBar
    {
        void IFoo.Execute()
        {
            Console.WriteLine("IFoo Executes");
        }
        void IBar.Execute()
        {
            Console.WriteLine("IBar Executes");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Tester t = new Tester();
            (t as IFoo).Execute();
        }
    }
}

------------------------------------------
Интерфейсы в преобразованиях типов (upcasting downcasting)

Преобразование от класса к его интерфейсу, как и преобразование от производного типа к
 базовому, выполняется автоматически. Так как любой объект Client реализует интерфейс IAccount.

Необходимо явно указать, реализацию какого интерфейса мы хотим использовать, например, 
 с помощью операции приведения типов:

            // Все объекты Client являются объектами IAccount 
            IAccount account = new Client("Том", 200);//Поскольку класс Client реализует интерфейс 
            //IAccount, то переменная типа IAccount может хранить ссылку на объект типа Client

            account.Put(200);

            Console.WriteLine(account.CurrentSum); // 400
            // Не все объекты IAccount являются объектами Client, необходимо явное приведение

            Client client2 = (Client)account;

            //И если мы хотим обратиться к методам класса Client, которые не определены в интерфейсе IAccount, 
            //но являются частью класса Client, 
            // Интерфейс IAccount не имеет свойства Name, необходимо явное приведение

            string clientName = ((Client)account).Name;
            Console.Read();

Необходимо явно указать, реализацию какого интерфейса мы хотим использовать, например, с помощью операции приведения типов:

 interface IFoo
        {
            void Execute();
        }
        interface IBar
        {
            void Execute();
        }
        class Tester : IFoo, IBar //Класс Tester реализует интерфейсы IFoo и IBar:
        {
            void IFoo.Execute()//При явной реализации указывается название метода или свойства вместе с названием интерфейса,
 //при этом мы не можем использовать модификатор public, то есть методы являются закрытыми
            {
                Console.WriteLine("IFoo Executes");
            }

            void IBar.Execute()//При явной реализации указывается название метода или свойства вместе с названием интерфейса,
 //при этом мы не можем использовать модификатор public, то есть методы являются закрытыми
            {
                Console.WriteLine("IFoo Executes");
            }

        }
        class Program
        {
            static void Main(string[] args)
            {
                Tester t = new Tester();

                //придетс иполовать даункастинг чтобы вытащить метод Execute

                //или так
                if (t is IFoo e)
                {
                    e.Execute();
                }

                //или так
                (t as IFoo).Execute();
            }
        }   

------------------------------------------
пример интерфейса

Данный интерфейс содержит различные компоненты, которые описывают возможности движущегося объекта.
То есть интерфейс описывает некоторый функционал, который должен быть у движущегося объекта.


interface IMovable
{
    // константа
    const int minSpeed = 0;     // минимальная скорость
    // статическая переменная
    static int maxSpeed = 60;   // максимальная скорость
    // метод
    void Move();                // движение
    // свойство
    string Name { get; set; }   // название
     
    delegate void MoveHandler(string message);  // определение делегата для события
    // событие
    event MoveHandler MoveEvent;    // событие движения
}

Методы и свойства интерфейса могут не иметь реализации, в этом они сближаются с абстрактными 
методами и свойствами абстрактных классов. В данном случае интерфейс определяет метод Move, 
который будет представлять некоторое передвижение. Он не имеет реализации, не принимает никаких 
параметров и ничего не возвращает.

И, собственно, мы не можем создавать объекты интерфейса напрямую с помощью конструктора,
 как например, в классах

IMovable m = new IMovable(); // ! Ошибка, так сделать нельзя

Но также, начиная с версии C# 8.0, мы можем явно указывать модификаторы доступа у
 компонентов интерфейса:
interface IMovable
{
    public const int minSpeed = 0;     // минимальная скорость
    private static int maxSpeed = 60;   // максимальная скорость
    protected internal void Move();
    ...


==========================================



--Явная реализация интерфейсов--
------------------------------------------
При явной реализации указывается название метода или свойства вместе с названием интерфейса,
 при этом мы не можем использовать модификатор public, то есть методы являются закрытыми

interface IAction
{
    void Move();
}
class BaseAction : IAction
{
    void IAction.Move()
    {
        Console.WriteLine("Move in Base Class");
    }
}

Следует учитывать, что при явной реализации интерфейса его методы и свойства не являются 
частью интерфейса класса. Поэтому напрямую через объект класса мы к ним обратиться не сможем

interface IAction
{
    void Move();
}
class BaseAction : IAction
{
    void IAction.Move()
    {
        Console.WriteLine("Move in Base Class");
    }
}

static void Main(string[] args)
{
    BaseAction action = new BaseAction();
    ((IAction)action).Move();   // необходимо приведение к типу IAction
 
    // или так
    IAction action2 = new BaseAction();
    action2.Move();
     
    Console.ReadKey();
}
------------------------------------------
почему исопльзуется явная реализация 

В какой ситуации может действительно понадобиться явная реализация интерфейса? 
Например, когда класс применяет несколько интерфейсов, но они имеют один и тот же метод 
с одним и тем же возвращаемым результатом и одним и тем же набором параметров:


 interface ISchool
    {
        void Study() //одинавковые имена 
        {
            Console.WriteLine("School Learning");
        }
    }

    interface IUniversity
    {
        void Study() //одинавковые имена
        {
            Console.WriteLine("University Learning");
        }
    }

 class Person : ISchool, IUniversity
    {
        public void Study() //Класс Person определяет один метод Study(),
            //создавая одну общую реализацию для обоих примененных интерфейсов.

            //И вне зависимости от того, будем ли мы рассматривать объект Person
            //как объект типа ISchool или IUniversity, результат метода будет один и тот же.
        {
            Console.WriteLine("Учеба в школе или в университете"); //сейчас класс
            //Person реализует методы обоих интерфейсов одинково, тк как их имена совпадают, чтобы этого избежать
            //и производится разграничение 
        }

        
            void ISchool.Study()//Чтобы разграничить реализуемые интерфейсы, надо явным образом применить интерфейс
        {
                Console.WriteLine("Учеба в школе");//теперь в каждом из реализумеых методов будет разный результат
            }

            void IUniversity.Study()//Чтобы разграничить реализуемые интерфейсы, надо явным образом применить интерфейс
        {
                Console.WriteLine("Учеба в университете");//теперь в каждом из реализумеых методов будет разный результат
        }
        

    }

   
    class Program
    {
        static void Main(string[] args)
        {
            Person p = new Person();

            p.Study();
            Console.Read();

            Person per = new Person();

            ((ISchool)per).Study();//но в таком случае необходим будет использовать даункаст
            //тк эти методы больше не являются частью интерфейса наследуемого класса Person
            ((IUniversity)per).Study();//но в таком случае необходим будет использовать даункаст
            //тк эти методы больше не являются частью интерфейса наследуемого класса Person
            Console.Read();
        }
------------------------------------------
 явная реализация в случае реализации инерфейса в классе родителе

Другая ситуация, когда в базовом классе уже реализован интерфейс,
но необходимо в производном классе по-своему реализовать интерфейс

interface IAction
{
    void Move();
}
class BaseAction : IAction
{
    public void Move()//чтобы не получить результат мтоеда интерфейса из класса родителя...
    {
        Console.WriteLine("Move in BaseAction");
    }
}
class HeroAction : BaseAction, IAction
{
    void IAction.Move()// ...необходимо явно реализовать 
        //метод интерефейса в классе потомке
    {
        Console.WriteLine("Move in HeroAction");
    }
}
static void Main(string[] args)
        {
            HeroAction action1 = new HeroAction();
            action1.Move();// Move in BaseAction//этот метод идет от класса родителя
            // тк в нем он все еще является публичным

            ((IAction)action1).Move(); // Move in HeroAction//а вот этот метод уже идет от потомка
            // с даункастом к интерфейсу

            IAction action2 = new HeroAction();//а здесь от родительсокго интерфейса апкаст к
            //классу потомку HeroAction
            action2.Move();// Move in HeroAction

            Console.Read();

------------------------------------------
явная реализация в случае модификторов доступа не public

Члены интерфейса могут иметь разные модификаторы доступа. Если модификатор доступа не public, 
а какой-то другой, то для реализации метода, свойства или события интерфейса в классах и
 структурах также необходимо использовать явную реализацию интерфейса

 interface IMovable
{
    protected internal void Move();
    protected internal string Name { get; set; }
    delegate void MoveHandler();
    protected internal event MoveHandler MoveEvent;
}
class Person : IMovable
{
    // явная реализация свойства - в виде автосвойства
    string IMovable.Name { get; set; }//явное потому что не паблик
 
    // явная реализация события - дополнительно создается переменная
    IMovable.MoveHandler _moveEvent;//в случае делегат тк это указатели на методы и с помощью делегатов
     //мы можем вызвать данные методы, то нам необходимо указать что этот делегат ринадлежит к интерфейсу 
    //иначе программа решит что мы создали новый делегат, а если мыф не убдем его создавать то программа 
    //заругается на отутвие реализации делегает из интрефейса

    event IMovable.MoveHandler IMovable.MoveEvent//явное потому что не паблик
    {
        add => _moveEvent += value;
        remove => _moveEvent -= value;
    }
 
    // явная реализация метода потому что не паблик
    void IMovable.Move()
    {
        Console.WriteLine("Person is walking"); 
        _moveEvent();
    }
}
class Program
{
    static void Main(string[] args)
    {
        IMovable mov = new Person();
        // подписываемся на событие
        mov.MoveEvent += () => Console.WriteLine("IMovable is moving");
        mov.Move();
    }
}       
==========================================


--Интерфейсы и наследование
------------------------------------------
Если класс применяет интерфейс, то этот класс должен реализовать все методы и свойства интерфейса, 
которые не имеют реализации по умолчанию. Однако также можно и не реализовать методы, 
сделав их абстрактными, переложив право их реализации на производные классы

interface IMovable
    {
        void Move();
    }
    abstract class Person : IMovable
    {
        public abstract void Move();//сделав метод асбтсрактным мы переносим его
        //реализацию в класс потомок
    }
    class Driver : Person
    {
        public override void Move()//сдесь мы и реализуем этот класс
        {
            Console.WriteLine("Шофер ведет машину");
        }
    }

     static void Main(string[] args)
        {
            Driver p = new Driver();

            p.Move();//Шофер ведет машину
        }

------------------------------------------
поведление метододв и свойств интерфейса без реализации их в классе наследнике, но с рализацией в 
родительском.
При реализации интерфейса учитываются также методы и свойства, унаследованные от базового класса

interface IAction
    {
        void Move();
    }
    class BaseAction
    {
        public void Move()//в случае если в классе потомке HeroAction метод Move не будет определен, 
        //тогда будет исопльзоватся эта реализация
        {
            Console.WriteLine("Move in BaseAction");
        }
    }
    class HeroAction : BaseAction, IAction//название базового класса ВСЕГДА должно быть указано до 
    //реализуемых интерфейсов
    {
        //Move может быть не определен,но тогда используется реализация из класса родителя
    }

static void Main(string[] args)
        {
            BaseAction ba = new BaseAction();
            ba.Move(); //Move in BaseAction
             HeroAction ha = new HeroAction();
            ha.Move(); //Move in BaseAction
        }
Здесь класс HeroAction реализует интерфейс IAction, однако для реализации метода Move из интерфейса 
применяется метод Move, унаследованный от базового класса BaseAction. Таким образом, 
класс HeroAction может не реализовать метод Move, так как этот метод уже определен в базовом классе BaseAction;        
------------------------------------------
Изменение реализации интерфейсов в производных классах

Может сложиться ситуация, что базовый класс реализовал интерфейс, но в классе-наследнике
необходимо изменить реализацию этого интерфейса. 

 --1 вариант  переопределение виртуальных/абстрактных методов

  interface IAction
    {
        void Move();
    }
    class BaseAction : IAction
    {
        public virtual void Move()//В базовом классе BaseAction реализованный метод интерфейса определен как виртуальный
                                  //(можно было бы также сделать его абстрактным)
        {
            Console.WriteLine("Move in BaseAction");
        }
    }
    class HeroAction : BaseAction//наследуем только от BaseAction
    {
        public override void Move()//а в производном классе мы его переопределяем.
        {
            Console.WriteLine("Move in HeroAction");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            BaseAction action = new BaseAction();
            action.Move();//Move in BaseAction
            BaseAction action1 = new HeroAction();
            action1.Move();// Move in HeroAction

            IAction action2 = new HeroAction();//При вызове метода через переменную интерфейса, если она ссылается
            //на объект производного класса, будет использоваться реализация из производного класса
            action2.Move(); // Move in HeroAction
            IAction action3 = new BaseAction();//При вызове метода через переменную интерфейса, если она ссылается
            //на объект производного класса, будет использоваться реализация из производного класса
            action3.Move();//Move in BaseAction
        }
    }

--2 вариант - сокрытие метода в производном классе

Так как интерфейс реализован именно в классе BaseAction, то через переменную action2 можно обратиться 
только к реализации метода Move из базового класса BaseAction.

interface IAction
{
    void Move();
}
class BaseAction : IAction
{
    public void Move()//реализуем метод из интерфейса 
    {
        Console.WriteLine("Move in BaseAction");
    }
}
class HeroAction : BaseAction//наследуем только от BaseAction
{
    public new void Move()// сокрытием метода в производном классе мы переопредлделяем метод из базовго класса
    {
        Console.WriteLine("Move in HeroAction");
    }
}

BaseAction action1 = new HeroAction();
action1.Move();            // Move in BaseAction
 
IAction action2 = new HeroAction();
action2.Move();             // Move in BaseAction

--3 варинат повторная реализация интерфейса в классе-наследнике

interface IAction
    {
        void Move();
    }
    class BaseAction : IAction
    {
        public void Move()
        {
            Console.WriteLine("Move in BaseAction");
        }
    }
    class HeroAction : BaseAction, IAction//повторная реализуем интерфейс в классе-наследнике, 
//и за одно наследуемся от класса родителя
    {
        public new void Move()//еще один метод с таким же названием не взяаный с пердыдущим,
            //используется для разрешения конфликат имен без использования преопределения
        {
            Console.WriteLine("Move in HeroAction");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            BaseAction action1 = new HeroAction();//Если вы работаете с экземпляром класса-наследника 
            //HeroAction, через его родительский класс BaseAction...
            action1.Move(); //...то если исопльзовать тут перекрытый(new) метод, 
            //то будет вызван метод Move из базового класса BaseAction те - выведется Move in BaseAction          

            IAction action2 = new HeroAction();//При вызове метода Move через переменную интерфейса action2, 
            //если она ссылается на объект производного класса new HeroAction(), 
            //будет использоваться реализация из производного класса...
            action2.Move();             //...вот эта реализация - выведется Move in HeroAction

            HeroAction action3 = new HeroAction();
            action3.Move();             // Move in HeroAction
        }
    }
==========================================



--наследование интерфесйсов--
------------------------------------------
интерфейсы как и классы могут наследоваться

interface IAction
{
    void Move();
}
interface IRunAction : IAction
{
    void Run();
}
class BaseAction : IRunAction
{
    public void Move()
    {
        Console.WriteLine("Move");
    }
    public void Run()
    {
        Console.WriteLine("Run");
    }
}
Однако в отличие от классов мы не можем применять к интерфейсам модификатор sealed, чтобы запретить наследование 
интерфейсов.
Также мы не можем применять к интерфейсам модификатор abstract, поскольку интерфейс фактически итак, 
как правило, предоставляет абстрактный функционал, который должен быть реализован в классе или 
структуре (за исключением методов и свойств с реализацией по умолчанию).
------------------------------------------
сокрытия методов из базового интерфейса

Однако методы интерфейсов могут использовать ключевое слово new для сокрытия методов из базового интерфейса

interface IAction
{
    void Move();
}
interface IRunAction : IAction
{
    new void Move();//Здесь метод Move из IRunAction скрывает метод Move из базового интерфейса IAction
    // Большого смысла в этом нет, так как в данном случае нечего скрывать 
}

class RunAction : IRunAction
{
    public void Move()
    {
        Console.WriteLine("I am running");//А класс RunAction реализует метод Move сразу для обоих интерфейсов.
    }
}
------------------------------------------
При наследовании интерфейсов следует учитывать, что, как и при наследовании классов, 
производный интерфейс должен иметь тот же уровень доступа или более строгий, чем базовый интерфейс.

public interface IAction
{
    void Move();
}
internal interface IRunAction : IAction
{
    void Run();
}


в этом случап получим ошибку тк родтельский интерфейс имеет более строий уровень доступа чем интерфейс наследник

internal interface IAction
{
    void Move();
}
public interface IRunAction : IAction   // ошибка IRunAction может быть только internal
{
    void Run();
}
==========================================

--Интерфейсы в обобщениях--
------------------------------------------
Интерфейсы могут выступать в качестве ограничений обобщений. При этом если в качестве ограничения можно указаь 
только один класс, то интерфейсов можно указать несколько.

 interface IAccount
    {
        int CurrentSum { get; } // Текущая сумма на счету
        void Put(int sum);      // Положить деньги на счет
        void Withdraw(int sum); // Взять со счета
    }
    interface IClient
    {
        string Name { get; set; }
    }
    class Client : IAccount, IClient //здесь определен класс Client, который реализует оба интерфейса, 
    //таким образом мы можем им типизировать обьекты классов типизация которых  же интерфейсами

        int _sum; // Переменная для хранения суммы
        public Client(string name, int sum)
        {
            Name = name;
            _sum = sum;
        }

        public string Name { get; set; }
        public int CurrentSum
        {
            get { return _sum; }
        }
        public void Put(int sum)
        {
            _sum += sum;
        }
        public void Withdraw(int sum)
        {
            if (sum <= _sum)
            {
                _sum -= sum;
            }
        }
    }

    class Transaction<T> where T : IAccount, IClient//T представляет тип, который
    //который реализует сразу два интерфейса IAccount и IClient
    {
        public void Operate(T acc1, T acc2, int sum)
        {
            if (acc1.CurrentSum >= sum)
            {
                acc1.Withdraw(sum);
                acc2.Put(sum);
                Console.WriteLine($"{acc1.Name} : {acc1.CurrentSum}\n{acc2.Name} : {acc2.CurrentSum}");
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Client account1 = new Client("Tom", 200);
            Client account2 = new Client("Bob", 300);

            Transaction<Client> transaction = new Transaction<Client>();// Например,
            // выше определен класс Client, который реализует оба интерфейса,
            // поэтому мы можем данным типом типизировать объекты Transaction

            transaction.Operate(account1, account2, 150);
        }
    }

------------------------------------------
 interface IAccount
    {
        int CurrentSum { get; }
        void Put(int sum);
        void Withdraw(int sum);

        interface IClient
        {
            string Name { get; set; }
        }

        interface IClientAccount : IAccount, IClient //этот интерфейс
            //наследуется от обоих интерфейсов 
        {

        }

        class ClientAccount : IClientAccount
        {
            int _sum;

            public ClientAccount(string name, int sum)
            {
                _sum = sum;
                Name = name;
            }

            public int CurrentSum
            {
                get { return _sum; }
            }

            public string Name { get; set; }

            public void Put(int sum)
            {
                _sum += sum;
            }

            public void Withdraw(int sum)
            {
                if (_sum >= sum) _sum -= sum;
            }
        }

        class Transaction<T> where T : IAccount, IClient //Также параметр T может представлять
        //интерфейс, который наследуется от обоих интерфейсов
        {
            public void Operate(T acc1, T acc2, int sum)
            {
                if (acc1.CurrentSum >= sum)
                {
                    acc1.Withdraw(sum);
                    acc2.Put(sum);
                    Console.WriteLine($"{acc1.Name} : {acc1.CurrentSum}\n{acc2.Name} : {acc2.CurrentSum}");
                }
            }
        }

        class Program
        {
            static void Main(string[] args)
            {
                ClientAccount account3 = new ClientAccount("Alice", 400);
                ClientAccount account4 = new ClientAccount("Kate", 500);
                Transaction<IClientAccount> operation = new Transaction<IClientAccount>(); //В этом
                //случае объекты Transaction мы можем типизировать типом IClientAccount
                operation.Operate(account3, account4, 200);
            }
        }

------------------------------------------
Обобщенные интерфейсы

Как и классы, интерфейсы могут быть обобщенными

          interface IUser<T> //Интерфейс IUser типизирован параметром T, 
    {
        T Id { get; }
    }

    class User<T> : IUser<T> //памретр Т при реализации интерфейса используется в классе User
    {
        T _id; // переменная _id определена как T, что позволяет нам использовать

        // для id различные типы.
        public User(T id)
        {
            _id = id;
        }

        public T Id
        {
            get { return _id; }
        }
    }

    class IntUser : IUser<int> //Также при реализации интерфейса мы можем явным
        //образом указать, какой тип будет использоваться для параметра T
    {
        int _id;

        public IntUser(int id)
        {
            _id = id;
        }

        public int Id
        {
            get { return _id; }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            //Определим две реализации:
            IUser<int> user1 = new User<int>(6789); //одна в качестве параметра будет использовать тип int
            Console.WriteLine(user1.Id); // 6789

            IUser<string> user2 = new User<string>("12345"); //а другая - тип string
            Console.WriteLine(user2.Id); // 12345

            IntUser iu = new IntUser(200);
            Console.WriteLine(iu.Id);

            IUser<int> iui = new IntUser(500);
            Console.WriteLine(iui.Id);

        }
    }
==========================================



--Копирование объектов. Интерфейс ICloneable--
------------------------------------------


==========================================


--IComparable сортировка обьектов и IComparer Применение компаратора--compare
------------------------------------------
IComparable сортировка обьектов 
Большинство встроенных в .NET классов коллекций и массивы поддерживают сортировку.
С помощью одного метода, который, как правило, называется в Sort() можно сразу отсортировать по возрастанию весь набор данных. Например:

    class Program
    {
        static void Main(string[] args)
        {
            int[] numbers = new int[] {97, 45, 32, 65, 83, 23, 15};
            Array.Sort(numbers); //для простых типов типа int или string существует метод сортировки по возрвастанию через Sort 
            foreach (int n in numbers)
                Console.WriteLine(n);

            Person p1 = new Person {Name = "Bill", Age = 34};
            Person p2 = new Person {Name = "Tom", Age = 23};

            Person p3 = new Person {Name = "Alice", Age = 21};
            Person p4 = new Person {Name = "Max", Age = 21};
            Person[] people = new Person[] {p1, p2, p4, p3};
            Array.Sort(people); //здес будет исоплльзоваатсся CompareTo тк это сложный тип


            foreach (Person p in people)
            {
                Console.WriteLine($"{p.Name} - {p.Age}");
            }
        }
    }

    //public interface IComparable //это является устаревшим и не используемым интерфейсом
    //{
    //    int CompareTo(object o);
    //}

    class Person : IComparable<Person> //но для сложных типов это не сработает необходим интерфейс IComparable с обощением
    {
        public string Name { get; set; }
        public int Age { get; set; }

        //он имеет всего один метод CompareTo предназначен для сравнения текущего объекта Person с объектом,
        //который передается в качестве параметра Person o. На выходе он возвращает целое число, которое может иметь одно из трех значений
        //Меньше нуля. Значит, текущий объект должен находиться перед объектом, который передается в качестве параметра
        //Равен нулю.Значит, оба объекта равны
        //Больше нуля.Значит, текущий объект должен находиться после объекта, передаваемого в качестве параметра
        public int CompareTo(Person o) 
        {
            return this.Age.CompareTo(o.Age); //производим сортировку по возрасту сравнивая возраст текущего обьекта и обьекта который передается в качестве параметра
            //какой куда передается зависит от алгоритмов сортировки
            //далее если обьект который this < Person o то будет -1 и this должен находится до Person o,  this > Person o то будет 1 и this должен находится после Person o,
            // this == Person o то будет 0 и this будет находится относително Person o соответвенно порядку в котором они были в первоначальном списке
            // Person[] people = new Person[] {p1, p2, p4, p3}; те в данном случае спервма p4 а потом p3 тк их сравнение венет 0
        }
    }
}

------------------------------------------
--IComparer Применение компаратора --compareTo

Метод Compare предназначен для сравнения двух объектов o1 и o2. Он также возвращает три значения, в зависимости от результата сравнения: если первый объект больше 
второго, то возвращается число больше 0, если меньше - то число меньше нуля; если оба объекта равны, возвращается ноль.

class Program
    {
        static void Main(string[] args)
        {
          
            Person p1 = new Person {Name = "Bill", Age = 34};
            Person p2 = new Person {Name = "Tom", Age = 23};
            Person p3 = new Person {Name = "Alice", Age = 21};
            Person p4 = new Person {Name = "Maximmer", Age = 21};

            Person[] people = new Person[] {p1, p2, p4, p3};

            Person[] peopleLenght = new Person[] { p1, p2, p4, p3 };

            Array.Sort(peopleLenght, new PeopleComparer());//Объект компаратора указывается в качестве второго параметра метода Array.Sort(). 
            //При этом не важно, реализует ли класс Person интерфейс IComparable или нет. Правила сортировки, установленные компаратором, 
            //будут иметь больший приоритет. В начале будут идти объекты Person, у которых имена меньше, а в конце - у которых имена длиннее:

            foreach (Person p in peopleLenght)
            {
                Console.WriteLine($"{p.Name} - {p.Age}");
            }
        }
    }

   

    class Person : IComparable<Person> 
    {
        public string Name { get; set; }
        public int Age { get; set; }

        public int CompareTo(Person o)
        {
            return this.Age.CompareTo(o.Age); 
        }
    }

    class PeopleComparer : IComparer<Person>//В данном случае используется обобщенная версия интерфейса IComparer, чтобы не делать излишних преобразований типов.
    {
        public int Compare(Person p1, Person p2)//Метод Compare предназначен для сравнения двух объектов o1 и o2. Он также возвращает три значения,
            //в зависимости от результата сравнения: если первый объект больше второго, то возвращается число больше 0, если меньше
            //- то число меньше нуля; если оба объекта равны, возвращается ноль.
        {
            if (p1.Name.Length > p2.Name.Length)//он сравнивает объекты в зависимости от длины строки - значения свойства Name 
                return 1;
            else if (p1.Name.Length < p2.Name.Length)
                return -1;
            else
                return 0;
        }
    }
}
class Program
    {
        static void Main(string[] args)
        {
          
            Person p1 = new Person {Name = "Bill", Age = 34};
            Person p2 = new Person {Name = "Tom", Age = 23};
            Person p3 = new Person {Name = "Alice", Age = 21};
            Person p4 = new Person {Name = "Maximmer", Age = 21};
            
            Person[] peopleLenght = new Person[] { p1, p2, p4, p3 };

            Array.Sort(peopleLenght, new PeopleComparer());

            foreach (Person p in peopleLenght)
            {
                Console.WriteLine($"{p.Name} - {p.Age}");
            }
        }
    }

    class Person : IComparable<Person> 
    {
        public string Name { get; set; }
        public int Age { get; set; }

        public int CompareTo(Person o)
        {
            return this.Age.CompareTo(o.Age); 
        }
    }

    class PeopleComparer : IComparer<Person>//В данном случае используется обобщенная версия интерфейса IComparer, чтобы не делать излишних преобразований типов.
    {
        public int Compare(Person p1, Person p2)//Метод Compare предназначен для сравнения двух объектов o1 и o2. Он также возвращает три значения,
            //в зависимости от результата сравнения: если первый объект больше второго, то возвращается число больше 0, если меньше
            //- то число меньше нуля; если оба объекта равны, возвращается ноль.
        {
            if (p1.Name.Length > p2.Name.Length)//он сравнивает объекты в зависимости от длины строки - значения свойства Name
            //если первый объект больше второго, то возвращается число больше 0, если меньше
            //- то число меньше нуля; если оба объекта равны, возвращается ноль. 
                return 1;
            else if (p1.Name.Length < p2.Name.Length)
                return -1;
            else
                return 0;
        }
    }
}

==========================================

--Методы расширения--Extension Method--
------------------------------------------
Методы расширения (extension methods) позволяют добавлять новые методы в уже существующие типы без создания нового производного класса. 
Эта функциональность бывает особенно полезна, когда нам хочется добавить в некоторый тип новый метод, но сам тип (класс или структуру) 
мы изменить не можем, поскольку у нас нет доступа к исходному коду. Либо если мы не можем использовать стандартный механизм наследования, 
например, если классы определенны с модификатором sealed.


public static class StringExtension//вначале надо создать статический класс, который и будет содержать этот метод. 
{
    public static int CharCount(this string str, char c)// добавив перед первым свойстваством this мы создаем метод расширения
    //this имя_типа название_параметра, то есть в нашем случае this string str так можно добваит к типу string новый метод, 
    //который будет подсчитыват количество char c в строке string str, Причем нам уже не надо указывать первый параметр.
    {
        int counter = 0;
        for (int i = 0; i<str.Length; i++)
        {
            if (str[i] == c)
                counter++;
        }
        return counter;
    }
} 

class Program
{
    static void Main(string[] args)
    {
        string s = "Привет мир";
        char c = 'и';
        int i = s.CharCount(c);//Затем у всех строк мы можем вызвать данный метод: int i = s.CharCount(c);. 
        //Причем нам уже не надо указывать первый параметр. Значения для остальных параметров передаются в обычном порядке.

        Console.WriteLine(i);
 
        Console.Read();
    }
}
 
 public static class StringExtension
    {
        public static int CharCount(this DbSet<User> users, char c)//можно исопльзоват сложные типы и типы с обощением
        {
            int counter = 0;
            foreach (var user in users)
            {
                for (int i = 0; i < user.login.Length; i++)
                {
                    if (user.login[i] == c)
                        counter++;
                }
            }

            return counter;
        }
    }

            DbSet<User>  users = db.Users;
            users.CharCount('c');

Применение методов расширения очень удобно, но при этом надо помнить, что метод расширения никогда не будет вызван, 
если он имеет ту же сигнатуру, что и метод, изначально определенный в типе.

То есть, если добавить в проект другое пространство имен, то метод не будет применяться к строкам, и в этом случае надо будет 
подключить пространство имен метода через директиву using.


==========================================


--Deconstruct--
------------------------------------------
C# не предоставляет встроенную поддержку для деконструкции типов, не являющихся кортежами, кроме типов record и DictionaryEntry. 
Тем не менее, если вы являетесь создателем класса, структуры или интерфейса, вы можете разрешить деконструкцию экземпляров определенного типа, 
реализовав один или несколько методов Deconstruct. 
 
    class Person
    {
        public string Name { get; set; }
        public int Age { get; set; } 
        public int Height { get; set; }

        //public void Deconstruct(out string name)//метод Deconstruct должен принимать как минимум два выходных параметра, те так метод не сработает как надо
        //{
        //    name = this.Name;

        //}

        public void Deconstruct(out string name, out int age)//Метод возвращает "void", и каждое деконструируемое значение обозначается параметром out в сигнатуре метода.
            //Например, следующий метод  Deconstruct класса Person возвращает name и age
        {
            name = Name;
            age = Age;
        }

        public void Deconstruct(out string name, out int age, out int height)//так же можно реализовывать пергрузки меоду деконструкт
        {
            name = Name;
            age = Age;
            height = Height;
        }


        public void Deconstruct1(out string name, out int age)//обычный метод который реализован в примере без исопльзования функционала Deconstruct
        {
            name = Name;
            age = Age;
        }

    }

    public static class Strings
    {
        public static void Deconstruct(this String str, out int length, out int getHashCode)//Если вы не являетесь создателем класса, структуры или интерфейса,
            //вы все равно можете выполнять деконструкцию объектов этого типа, реализовав один или несколько Deconstruct методов расширения,
            //которые будут возвращать интересующие вас значения.
        {
            length = str.Length;
            getHashCode = str.GetHashCode();
        }
    }

        class Program
    {
        static void Main(string[] args)
        {
            Person person = new Person { Name = "Tom", Age = 33, Height = 180};

            (string names, int ages) = person;// В этом случае мы могли бы выполнить декомпозицию объекта Person так
            //создаем две перменные и через деконстурктор предаем в них значния по ссылке которые берем из полей класса Person - Name и Age  
            //string names, int ages, int heights имена перменных необзательно дожны сопвадать с именами перменных в методе  Deconstruct(out string name, out int age, out int height)

            Console.WriteLine(names);    // Tom
            Console.WriteLine(ages);     // 33


            var ( name1,  age1,  height) = person;//можно так же обьявить в начал var  и тогда все перенные в деконструкторе примут нужные типы в зависимости от типов в классе
            Console.WriteLine(name1);    // Tom
            Console.WriteLine(age1);     // 33
            Console.WriteLine(height);    // 180

            var (name2, _, height2) = person;//пустые переменные можно применять с пользовательскими типами, чтобы игнорировать определенные элементы, возвращаемые методом Deconstruct
            Console.WriteLine(name2);    // Tom
            Console.WriteLine(height2);    // 180

            //этот код аналлгичен вышенаписаному но без исопльзования функционала Deconstruct
            Person person2 = new Person { Name = "Max", Age = 20 };

            string name3; 
            int age3;
            person.Deconstruct1(out name3, out age3);
            Console.WriteLine(name3);    // Max
            Console.WriteLine(age3);     // 20


            String ss = "Hello";//можно например сделать так
            (int length,int getHashCode) = ss;
            Console.WriteLine(length);//длина строки 5
            Console.WriteLine(getHashCode);//хешкод строки -1454575212
        }
}
==========================================

--многопоточность--thread--
------------------------------------------
ключевым понятием при работе с многопоточность является поток, поток это некторая часть программы. при выполнении
программы каждому потоку выделяется определенный квант времени.(это численное значение, которое характеризует,
как долго может выполняться задание до того момента, пока оно не будет вытеснено.), и при помощи многопоточность
мы можем выделить в прилождении несколько потоков, которые будудт выполнять разные задачи одновременно.
к примеру если приложение с UI обрабатывает задачу свыше 50 мс ,UI бы блокировался на время выполнения этой задачи.
а благодаря многопоточности мы можем поместить эту задачу в отдельный поток.

------------------------------------------
--основые свойства класса Thread 

статическлое CurrentContext - получаем контекст в коором выполняется поток(структура, содержащая всю информацию, 
необходимую для выполнения кода потока с помощью OS. Если OS необходимо изменить выполнение из одного потока в другой, 
он выполняет то, что называется переключением контекста).

статическое  CurrentThread - возварщает ссылку на выполняемый поток

IsAlive - работае ли поток в данный момент

IsBackground - является ли поток фоновым

Name - имя потока

Priority - Enum приоритет потока  

ThreadState - Enum состояние потока

------------------------------------------
методы класса Thread:

cтатический GetDomain возварщает ссылку на домен приложения (буквально его навазние)

статический GetDomainId - возвращает id домена приложени, в котором выполнгяется текуущий поток

стаитческий Sleep - останваливает поток на определленно коллво сек 

Abort - уведомеляет среду, что необходдимо прекартить поток, однако пркарщение рабоыт потока происходит не сразу, 
а только тогда когда это стане возможно. (для проверки завершенности потока опроситьь его ThreadState)

Interrupt - прерывает поток который находится в сотоянии WaitSleepJoin (получаем из ThreadState)

Join - см. ниже

Start - запускает поток

Thread t = Thread.CurrentThread;// представляет текущий выполняющийся поток. После получения текущего потока можно вывести разнообразную статистику о нем

//Так как по умолчанию свойство Name у объектов Thread не установлено, то в первом случае мы получаем в качестве значения этого свойства //пустую строку.
Console.WriteLine($"Имя потока: {t.Name}");//имя потока
t.Name = "1";
Console.WriteLine($"Имя потока: {t.Name}");//имя потока: 1

Console.WriteLine($"Запущен ли поток: {t.IsAlive}");//запущен ли поток: true
Console.WriteLine($"Приоритет потока: {t.Priority}");//приоритет потока: normal
Console.WriteLine($"Статус потока: {t.ThreadState}");//статус потока: Running

// получаем домен приложения
Console.WriteLine($"Домен приложения: {Thread.GetDomain().FriendlyName}");//HelloApp

------------------------------------------
статус потока в ThreadState Enum

Aborted: остановлен, но пока еще не окочнатенльно завершен

AbortRequested: для потока вызван метод Abort, но остановка потока еще не произошла, поток получил запрос на завершение

Background: поток выполняется в фоновом режиме 

Running: поток запушен и работает(не приостановлен)

Stopped: поток завершен

StopRequested: поток получил запрос на остановку

Suspended: поток приостановлен !является УСТАРЕВШЕЙ

SuspendRequest: поток получил запрос на приостановку !является УСТАРЕВШЕЙ

Unstarted: поток еще не был запущен

WaitSleepJoin: поток заблокирован в результате дествия метода Sleep или Join

во время работы потока его сотсояние постоянно изменяется. до вызова метоад Start его состояния Unstarted.
запустив поток Running. при вызове Sleep статус WaitSleepJoin. при Abort поток становится AbortRequested,
а затем Aborted, послле чего поток завершится.

------------------------------------------
приоритеты потоков 

приоритеты потоков рпспологаются в Enum ThreadPriority

Lowest

BellowNormal

Normal

AboveNormal

Highesst

По умолчанию потоку задается занчение Normal. однако можно изменить приоритет во время работы программы. и в зависимосчти от ваажности потока 
программа будет выделять потоку то или иное колво времени.


------------------------------------------
--Join пример работы

public class ExThread 
{ 
  
    // Non-Static method
    public void mythread() 
    { 
        for (int x = 0; x < 4; x++) 
        { 
            Console.WriteLine(x); 
            Thread.Sleep(100); 
        } 
    } 
  
    // Non-Static method
    public void mythread1()
    {
        Console.WriteLine("2nd thread is Working..");
    }
} 
  
// Driver Class
public class ThreadExample 
{ 
    // Main method
    public static void Main() 
    { 
        // Creating instance for
        // mythread() method
        ExThread obj = new ExThread(); 
          
        // Creating and initializing threads 
        Thread thr1 = new Thread(new ThreadStart(obj.mythread)); //создаем Unstarted поток 1
        Thread thr2 = new Thread(new ThreadStart(obj.mythread1)); //создаем Unstarted поток 2
        thr1.Start(); //поток 1 Running
          
        // Join thread
        thr1.Join(); //join указывает текущему потоку те Main остановится пока не выполнится поток 1
        thr2.Start(); //после этого старутерм поток 2
          
    } 
} 

------------------------------------------
--ThreadStart

Используя класс thread можно выделить в приложении несколько потоков которые будут выполнятся одновременно

1 для запуска новго потока нам надо поределить задачу в приложении которую будет выполнять данный поток. 
для этого мы можем добавит новый метод который производит какето дествия.
2. длля создания потока используется делегат ThreadStart, который получает в качестве парметра выолпняемый метод, 
аналогично Task.Run



==========================================


--async--await--асинхронность--
------------------------------------------
Асинхронность позволяет вынести отдельные задачи из основного потока в специальные асинхронные методы или блоки кода.
Особенно это актуально в графических программах, где продолжительные задачи могу блокировать интерфейс пользователя.

Ключевыми для работы с асинхронными вызовами в C# являются два ключевых слова: async и await, цель которых 
- упростить написание асинхронного кода. Они используются вместе для создания асинхронного метода.

стандартынй вызов такой операции - await Task.Run(()=>Factorial());

Ключевые слова async и await не вызывают создания дополнительных потоков.
 Асинхронные методы не требуют многопоточности, потому что асинхронный метод не работает в собственном потоке. 
 Метод работает в текущем контексте синхронизации и использует время в потоке только тогда, когда метод активен.
------------------------------------------
простейший пример async
//async дает понять методу что в его теле придется когото ждать
 static async void FactorialAsync()//(3)Метод FactorialAsync начинает выполняться синхронно вплоть до выражения await.
 {
    Console.WriteLine("Начало метода FactorialAsync"); //(4) выполняется синхронно
    //метод будет ждать задачу  Factorial
    await Task.Run(()=>Factorial());//(5)Выражение await запускает асинхронную задачу Task.Run(()=>Factorial())
    Console.WriteLine("Конец метода FactorialAsync");//(8)Когда асинхронная задача завершила свое выполнение
    // (в случае выше - подсчитала факториал числа), продолжает работу асинхронный метод FactorialAsync,
    // который вызвал асинхронную задачу.
 }
        
void Factorial()//(6)выплоняетсся асинхронно из FactorialAsync
   {
       int result = 1;
       for(int i = 1; i <= 6; i++)
       {
           result *= i;
       }
       Thread.Sleep(8000);
       Console.WriteLine($"Факториал равен {result}");
   }

static void Main(string[] args)//(1)Запускается метод Main, 
        {
            FactorialAsync();  //(2)в котором вызывается асинхронный метод FactorialAsync.
 
            Console.WriteLine("Введите число: ");//(7)Пока выполняется асинхронная задача,
            // выполнение кода возвращается в вызывающий метод - то есть в метод Main. 
            //В методе Main нам будет предложено ввести число для вычисления квадрата числа.
            int n = Int32.Parse(Console.ReadLine());
            Console.WriteLine($"Квадрат числа равен {n * n}");
             
            Console.Read();
        }

вывод из программы :

(4)Начало метода FactorialAsync
(7)Введите число:
(тут мы жддем рун но основной поток с Введите число продожается, стоит только поток в методе FactorialAsync)
(5 и 6)Факториал равен 720
(8)Конец метода FactorialAsync
10
Квадрат числа равен 100

Асинхронный метод, как и обычный, может использовать любое количество параметров или не использовать их вообще. 
Однако асинхронный метод не может определять параметры с модификаторами out и ref.

------------------------------------------
встроеная поддержка асинк

Фреймворк .NET уже имеет встроенную поддержку асинхронных операций. Например, в классе StreamWriter определен метод WriteLineAsync(). 
По сути он уже представляет асинхронную операцию и принимает в качестве параметра некоторую строку, которую надо записать в файл.
 Поскольку этот метод представляет асинхронную операцию, то вызов этого метода мы можем оформить в выражение await:

await writer.WriteLineAsync(s);  // асинхронная запись в файл

------------------------------------------
В чем разница между Task.Run () и await Task.Run ()?

Task.Run() запускает задачу, а затем выполняет работу в методе задачи, сразу после этой задачи, прежде чем задача завершится.
если в вызывающем задауче методе нет нужды ждать результаты задачи то исопльзуется Task.Run()

Это очень разные рабочие процессы. Оба являются асинхронными, но только последний имеет асинхронное ожидание . 
Мы асинхронно ждем, чтобы сообщить супруге, что газон стрижен, до тех пор, пока он действительно не будет стрижен .

Нанять кого-нибудь постричь газон.
Скажите супруге, что газон подстрижен.
Иди и посмотри Netflix.

------------------------------------------
Task.Run()

оператор CommandToFormSupply("Output", "0");//программа не дожидается выполнения и сразу  перскакивает на следующий 
//оператор
--
пример  Tasl.Run()
static async void FactorialAsync()//(3)Метод FactorialAsync выполняться синхронно 
 {
    Console.WriteLine("Начало метода FactorialAsync"); //(4) выполняется синхронно

    //метод НЕ будет ждать задачу  Factorial
    Task.Run(()=>Factorial());//(5)Выражение запускает задачу Task.Run(()=>Factorial()) в отдельном потоке

    Console.WriteLine("Конец метода FactorialAsync");//(6)FactorialAsync НЕ ждет пока задача завершила свое выполнение
    // и СРАЗУ же продолжает работу
 }
        
void Factorial()//(5+)выплоняетсся в другом потоке из FactorialAsync 
   {
       int result = 1;
       for(int i = 1; i <= 6; i++)
       {
           result *= i;
       }
       Thread.Sleep(8000);
       Console.WriteLine($"Факториал равен {result}");
   }

static void Main(string[] args)//(1)Запускается метод Main, 
        {
            FactorialAsync();  //(2)в котором вызывается асинхронный метод FactorialAsync.
 
            Console.WriteLine("Введите число: ");//(7)код продложает работу синхронно после выхода из метода 
            //В методе Main нам будет предложено ввести число для вычисления квадрата числа.
            int n = Int32.Parse(Console.ReadLine());
            Console.WriteLine($"Квадрат числа равен {n * n}");
             
            Console.Read();
        }

вывод из программы:

(4)Начало метода FactorialAsync
(тут выполняется run но мы его не ждем и идем дальше)
(6)Конец метода FactorialAsync
(7)Введите число:
(5 и 5+)Факториал равен 720 (дождались Run и выводим его по готовности)
10
Квадрат числа равен 100

------------------------------------------
await Task.Run() 
запускает задачу, а затем выполняет другую работу, пока задача не будет завершена, после чего он выполняет работу после задачи.
те он ждет пока задача выполнится и выпллняем определенную работу после задачи

Нанять кого-нибудь постричь газон.
Смотрите Netflix, пока косят газон.
Когда стрижка газона закончена и фильм закончен, скажите супруге, что газон стрижен.

--
await CommandToFormSupply("Output", "0");//программа дожидается выполнения и только потом перскакивает на следующий 

пример await Task.Run () в "простейший пример async"


------------------------------------------
основные правила синхронизации

(1)Правило 50 мс, Операции следует делать асинхронными, если они «могут занимать более 50 миллисекунд для выполнения» 
все, что занимает менее 50 мсек, считается «быстрым» и достаточно близким к «немедленному», чтобы не требовать асинхронного API. 

(2)Обычно это хорошая идея использовать ConfigureAwait(false)в коде вашей библиотеки и запускать продолжения в потоке пользовательского
интерфейса только в том случае, если им действительно нужен контекст пользовательского интерфейса:
Например, await MyAsync().ConfigureAwait(false); вместо await MyAsync();.
ConfigureAwait(false)сообщает, await что вам не нужно возобновлять работу в текущем контексте 
(в этом случае «в текущем контексте» означает «в потоке пользовательского интерфейса»). 
Однако для остальной части этого async метода (после ConfigureAwait) вы не можете делать ничего, 
что предполагает, что вы находитесь в текущем контексте (например, обновлять элементы пользовательского интерфейса).

------------------------------------------
педеача и получение результата из асинхронной ОПЕРАЦИИ (внутри асинх метода)

педеача
--
static async void FactorialAsync(int n)
{
    await Task.Run(() => Factorial(n));//передача в операцию данных
}
void Factorial(int n)//метод для передачи в асинхронную задачу
{
    ...
}


прием
--
 static async void FactorialAsync(int n)//сам асинхронный метод НИЧЕГО НЕ ВОЗВАРЩАЕТ
{
   int x = await Task.Run(()=>Factorial(n));//прием из операции и передача в операцию данных
   int y = x*10;
   Console.WriteLine();
}


int Factorial(int n)//метод для передачи в асинхронную задачу
{
    int result = 1;
    ...
    return result;
}
------------------------------------------
педеача и получение результата из асинхроннго МЕТОДА
  
В качестве возвращаемого типа в асинхронном методе должны использоваться типы void, Task, Task<T> или ValueTask<T>

--
Возвращение объекта типа Task:

        static int Factorial(int n)//в данном случае функция Factorial возвращает значение типа int.
        {
            int result = 1;
            for (int i = 1; i <= n; i++)
            {
                result *= i;
            }
            return result;
        }

        //Метод может возвращать некоторое значение.
        //Тогда возвращаемое значение оборачивается в объект Task, а возвращаемым типом является Task<T>
        static async Task<int> FactorialAsync(int n)//в данном случае это Task<int>
        {
            return await Task.Run(() => Factorial(n));
        }
        static async Task Main(string[] args)
        {
            int n1 = await FactorialAsync(5);// Чтобы получить результат асинхронного метода в методе Main,
            // который тоже определен как асинхронный, применяем оператор await при вызове FactorialAsync.

            Console.WriteLine($"n1={n1}");
            Console.Read();
        }

--
возвращение типа ValueTask<T>

Использование типа ValueTask<T> во многом аналогично применению Task<T> за исключением некоторых различий в работе с памятью, 
поскольку ValueTask - структура, а Task - класс.

using System;
using System.Threading.Tasks;

namespace HelloApp
{
    class Program
    {
        static int Factorial(int n)
        {
            int result = 1;
            for (int i = 1; i <= n; i++)
            {
                result *= i;
            }
            return result;
        }
        // определение асинхронного метода
        static async ValueTask<int> FactorialAsync(int n)
        {
            return await Task.Run(() => Factorial(n));
        }
        static async Task Main(string[] args)
        {
            int n1 = await FactorialAsync(5);
            int n2 = await FactorialAsync(6);
            Console.WriteLine($"n1={n1}  n2={n2}");
            Console.Read();
        }
    }
}


==========================================

https://metanit.com/sharp/tutorial/13.5.php

--примитивы синхронизации--
------------------------------------------

--События--ManualResetEvent
------------------------------------------
 // событийного объектт == Событие - это уведомление, отправляемое объектом, чтобы сигнализировать о возникновении действия. События в
    // .NET следуют шаблону проектирования наблюдателя .

    //Шаблон проектирования наблюдателя позволяет подписчику регистрироваться и получать уведомления от поставщика.

    //Поток переходит в сигнальное состояние тогда, когда он завершается.

    //Set() следует рассматривать как уведомляющий о том, что событие произошло.

    //сигнальное сотояние это когда поткок завершился
    class MyThread
    {
        public Thread Thr;//обьект потока

        public ManualResetEvent MRE;//ManualResetEvent - автоматически не выполняет Reset после того, как поток пропускается по вызову
                                    //WaitOne и, таким образом, функционирует как ворота: вызов Set открывает ворота, позволяя любое количество потоков,
                                    //которые WaitOne(ожидают пока выполнится поток) у ворот; вызов reset закрывает ворота,
                                    //вызывая, потенциально, очередь официантов накапливаться до следующего его открытия.

        public MyThread(string thrName, ManualResetEvent mre)
        {
            Thr = new(RunThr);//инициализурем обьект потока с методом который будет выполнять в нем(в потоке)
            Thr.Name = thrName;
            Thr.Start();//запускаем поток
        }

        void RunThr()
        {
            Console.WriteLine($"вошли в поток {Thr.Name}");

            for (int i = 1; i < 3; i++)//чтото делаем в потоке(кажудю секунду выводим i и имя потока)
            {
                Console.WriteLine($"{i} сeк, поток {Thr.Name}");
                Thread.Sleep(1000);
            }

            Console.WriteLine($"поток {Thr.Name} завершен");

            MRE.Set();//Когда завершается метод RunThr() из класса MyThread, уведомили о заваершении потока(постапвили его в сиглальное положение)
                      //и это сигналихзирует оснвному потоку через союытие eventObj.WaitOne() продолддить сове выполнение (позволяя одному или нескольким ожидающим потокам продолжить.)

        }

    }
    class Program
    {
        static void Main()
        {
            ManualResetEvent eventObj = new(false);// В методе Main() формируется событийный объект eventObj типа ManualResetEvent,
            //первоначально устанавливаемый в исходное, несигнальное состояние (false)

            MyThread mt = new("1", eventObj);// Затем создается экземпляр объекта типа MyThread, которому передается событийный объект eventObj.


            Console.WriteLine("Основной поток ожидает событие");
            eventObj.WaitOne();//После этого основной поток ожидает уведомления о событии . А поскольку событийный объект eventObj первоначально находится
            //в несигнальном состоянии, то основной поток вынужден ожидать до тех пор, пока для экземпляра объекта типа MyThread (в данном случае mt = new("1", eventObj))
            //не будет вызван метод Set() устанавливающий событийный объект eventObj в сигнальное состояние, что позолят основному потокуу прожолжить свое выполнение

            Console.WriteLine("Основной поток получил уведомление о событии от 1 потока и продолжает свое выполнение");

            eventObj.Reset();// Затем событийный объект устанавливается в исходное состояние (несигнальное те false), вызывая блокирование потоков.

            //весь процесс повторяется, но на этот раз для второго потока
            mt = new MyThread("2", eventObj);

            Console.WriteLine("Основной поток ожидает событие");
            eventObj.WaitOne();

            Console.WriteLine("Основной поток получил уведомление о событии от 2 потока и продолжает свое выполнение");

            //Если бы не событийный объект, то все потоки выполнялись бы одновременно, а результаты их выполнения оказались бы окончательно запутанными.


            //Если бы в рассматриваемой здесь программе событийный объект типа AutoResetEvent использовался вместо событийного объекта типа ManualResetEvent,
            //то вызывать метод Reset() в методе Main() не пришлось бы.Ведь в этом случае событийный объект автоматически устанавливается в несигнальное
            // состояние, когда поток, ожидающий данное событие, возобновляет свое выполнение. Для опробования этой разновидности события замените в данной
            //программе все ссылки на объект типа ManualResetEvent ссылками на объект типа AutoResetEvent и удалите все вызовы метода Reset(). Видоизмененная
            //версия программы будет работать так же, как и прежде.

        }

    }

==========================================


--var--
------------------------------------------



==========================================


--Dynamic--динамическая типизация--когда перменнная на протяжении свой жизни может хранить значения ращличных типов
------------------------------------------
динамическая типизация это 

==========================================
==========================================
--IP сервер - клиент--
------------------------------------------

string ipAddr = "128.0.0.1";
string port = "8888";
IPEndPoint ip = IPEndPoint.Parse($"{ipAddr}:{port}");//преобразует строку в ip адрес и порт (IPv4-адрес 128.0.0.1, порт 8888)

------------------------------------------
привер работы асинхронных методов на клиенте/сервере

 //исплоьзуется для подтверждения что подклюлчение прошло успешно
public ManualResetEvent ConnectOk = new (false);

 //стартуем клиент
        public void StartClient(string ip = "127.0.0.1", int port = 8888)
        {
           //...работа описана в разделе TCP Client/Server

            ConnetcToSrver(RemotePoint, clientSoket);//RemotePoint содержит сведения об узле и локальном или удаленном порте,
            //необходимые приложению для подключения к службе на узле.Объединяя IP-адрес узла и номер порта службы,
            //IPEndPoint класс формирует точку подключения к службе,clientSoket низкоуровневый интерфейс для приема и отправки сообщений по сети - open/read или write/close
        
            //...работа описана в разделе TCP Client/Server
            
        }

 //Представляет сетевую конечную точку в виде IP - адреса и номер порта. в данном случае с точки зрения клиентa это сервер
void ConnetcToSrver(EndPoint remoteUnit, Socket client) 
        {
            
            client.BeginConnect(remoteUnit, new AsyncCallback(ConnectCalback), client);//асинхронный запрос для подключения у удаленному узлу, 
            //remoteUnit -представляет удаленный узел, он записывается в client, далее начинается асинх попытка подключения обьекта client к удаленному узлу, 
            //информация о соекте клиента для этого содержится в обьекте state - client

            //основной поток ждет сигнала от ConnectOk.Set и если подключение прошло успешно продолжает свое выполнение
            ConnectOk.WaitOne();
        }

void ConnectCalback(IAsyncResult arguent)
        {

            Socket client = (Socket)arguent.AsyncState;//получаем обьект сокета клиента из state 
            client.EndConnect(arguent);//это заблокирует поток пока обьект Socket clietn не установит соединение или не создаст исключение

            ConnectOk.Set();//подключение прощло успешно и мы ставим в сигналное положение, и даем добро на продолжение главному потоку ConnectOk.WaitOne(); 
            //выходит из сотояния ожидания
        }

==========================================



--пусстые перменные--empty variable--
------------------------------------------
переменные-заполнители (_), которые намеренно не используются в коде приложения, онни эквивалентны переменным, которым не присвоены значения;
 пустые переменные не имеют значений, оии указывают это свое намерениие (игнорироват результат выражения) комплиятору и рахзрабочикам

Так как пустая переменная по сути всего одна, этой переменной может даже не выделяться память.

------------------------------------------
_ также является допустимым идентификатором. При использовании вне поддерживаемого контекста _ считается не пустой, а действительной переменной. 

private static void ShowValue(int _)
{
   byte[] arr = { 0, 0, 1, 2 };
   _ = BitConverter.ToInt32(arr, 0);
   Console.WriteLine(_);//_ теер обычная перменная, но в таком случае не стоит использовать ее в текущем контескте в качетве обчной пустой перменной
}
 // The example displays the following output:
 //       33619968

------------------------------------------
в деконструкторе Deconstruct
public void Deconstruct(out string name, out int age, out int height)...//из этого деконструктора нам нужно только name и height, а age мы игнорируем
//как раз используя пустую перменную

var (name2, _, height2) = person;//пустые переменные можно применять с пользовательскими типами, чтобы игнорировать определенные элементы,
// возвращаемые методом Deconstruct

------------------------------------------
в свичах switch
Шаблон пустой переменной можно использовать при сопоставлении шаблонов с выражением switch. Каждое выражение, включая null, 
всегда соответствует шаблону пустой переменной.

static int Select(int op, int a, int b) => op switch
{
    1 => a + b,
    2 => a - b,
    3 => a * b,
    _ => throw new ArgumentException("Недопустимый код операции")//здесь исопльзуется пустая перменная вместоо оператора default 
};

------------------------------------------
при вызове метода с параметром out вы также можете сделать пустыми значения аргументов out.

В следующем примере вызывается метод DateTime.TryParse(String, out DateTime), который определяет, является ли строковое представление
 даты допустимым для текущего языка и региональных параметров. Так как этот пример связан только с проверкой строки даты и не включает
  анализ этой строки для получения самой даты, аргумент out метода является пустым.

string[] dateStrings = {"05/01/2018 14:57:32.8", "2018-05-01 14:57:32.8",
                      "2018-05-01T14:57:32.8375298-04:00", "5/01/2018",
                      "5/01/2018 14:57:32.80 -07:00",
                      "1 May 2018 2:57:32.8 PM", "16-05-2018 1:00:32 PM",
                      "Fri, 15 May 2018 20:10:57 GMT" };
foreach (string dateString in dateStrings)
{
    if (DateTime.TryParse(dateString, out _))//ннас не интересует выход данных сстроки, а только ее пригодоность нашему паттерну
        Console.WriteLine($"'{dateString}': valid");
    else
        Console.WriteLine($"'{dateString}': invalid");
}
// The example displays output like the following:
//       '05/01/2018 14:57:32.8': valid
//       '2018-05-01 14:57:32.8': valid
//       '2018-05-01T14:57:32.8375298-04:00': valid
//       '5/01/2018': valid
//       '5/01/2018 14:57:32.80 -07:00': valid
//       '1 May 2018 2:57:32.8 PM': valid
//       '16-05-2018 1:00:32 PM': invalid
//       'Fri, 15 May 2018 20:10:57 GMT': invalid

------------------------------------------
Вы можете использовать отдельную пустую переменную, чтобы указать, что переменную необходимо игнорировать

public static void Method(string arg)
{
    _ = arg ?? throw new ArgumentNullException(paramName: nameof(arg), message: "arg can't be null");//так можно организоват проверку на null
    //в случе если arg  не null мтеодд ничего не веррнет, а вслучае если null то высскочит исключение
    // Коду не требуется результат присваивания, поэтому используется пустая переменная. 

    // Do work with arg.

}
------------------------------------------

В следующем примере отдельная пустая переменная используется, чтобы игнорировать объект Task, возвращаемый асинхронной операцией.
 Назначение задачи приводит к подавлению исключения, созданного операцией перед завершением. Это делает ваше намерение явным:
  Вам нужно назначить Task пустой переменной и пропустить все ошибки, созданные в этой асинхронной операции.

private static async Task ExecuteAsyncMethods()
{
    Console.WriteLine("About to launch a task...");
    _ = Task.Run(() =>
      //если убратьт отсюда _ = то появится предупреждение CS4014: Because this call is not awaited, 
      //execution of the current method continues before the call is completed.
    // Consider applying the 'await' operator to the result of the call.
    {
        var iterations = 0;
        for (int ctr = 0; ctr < int.MaxValue; ctr++)
            iterations++;
        Console.WriteLine("Completed looping operation...");
        throw new InvalidOperationException();
    });
    await Task.Delay(5000);
    Console.WriteLine("Exiting after 5 second delay");
}
// The example displays output like the following:
//       About to launch a task...
//       Completed looping operation...
//       Exiting after 5 second delay

==========================================




--WinForm--ВинФорм--
------------------------------------------
 this.Tag.ToString(); получение тега кнопки

 Debug.WriteLine(cmd); так мождно проследить за выполнением команды в окне output например при нажатии кнопки

==========================================

 --Reflection--Рефлекция--

------------------------------------------

.dll содержит манифест 
1 сборки(описание сборки дает понимаени о ее имени о вермсии ксолкьо файлов в сборке)
2 метаданные (описание того что входи в сборку не реализация е программный код только описание)
3 ресурсы (файлы баз данных мцузка картинки и др)
4 програманный код
------------------------------------------
--метеданные

ониописывают все типы которые в сборке, все методы, все события(атрибуты поля private public и другое).
если я обращаюсь к сборке извне, метаднные дают понять могу я обратится к той или иной перменной или классу и когда.

тоесть даные это не реализация, а просто описание класса, без его реализации.


использование рефлексии для вывода метоописания элементов обьекта Student
------------------------------------------
using System;
using System.Reflection; //подключаем рефлексию

namespace visa
{
    public class Student
    {
        private int _temp = 7;

        public string Name { get; set; }
        public string Age { get; set; }
    }
}

namespace MyNamespace
{


    class Program
    {
        static void Main(string[] args)
        {
            Type type = Type.GetType("visa.Student");//GetType позволяет получить метоописание Student по его стоковому имени
                                                     //(нужно так же указать пространство имен), если не найдет visa.Student то type = null,

            var members = type?.GetMembers();//формуируем список элементов типа Student,в списке публичные меотды свойства события все элменты Student 

            var staticInstanceMembers = type?.GetMembers(BindingFlags.NonPublic | BindingFlags.Instance);//через перегрузку
            //формуируем список элементов типа Student,в списке непубличные и экземплярные поля, свойства и тд.

            if (members != null)
            {
                foreach (MemberInfo memberInfo in members)
                {
                    Console.WriteLine(memberInfo);
                    // { get; set; }геттер и сеттер свойства Name
                    //System.String get_Name()
                    // Void set_Name(System.String)

                    // { get; set; }геттер и сеттер свойства Age
                    //System.String get_Age()
                    // Void set_Age(System.String)

                    //стандартыне свойства влючены в любой тип данных System.Object
                    //System.Type GetType()
                    //System.String ToString()
                    //Boolean Equals(System.Object)
                    //Int32 GetHashCode()

                    //Void.ctor() - конструктор класса

                    //свойства
                    //System.String Name - public string Name
                    //System.String Age  - public string Age { get; set; }
                }
            }
                
            if (members != null)
            {
                 foreach (MemberInfo memberInfo in staticInstanceMembers)
                {
                    Console.WriteLine(memberInfo);
                    //защищенные элменты System.Object
                    //System.Object MemberwiseClone()
                    //Void Finalize()

                    //Int32 _temp - private int _temp = 7;

                    //поля которые скрывают автосвойство созданные свойством Name и Age
                    //System.String<Name> k__BackingField
                    //System.String<Age> k__BackingField
                }
            } 
        }
    }
}

при помощщи метаданных можно менять реальные данные
------------------------------------------
//студент взят из примера сверху
    class Program
    {
        static void Main(string[] args)
        {
            Student student = new Student();

            //еще один спороспоб получить метоописание не чреез строку а чреез объкет
            Type type = student.GetType();// GetType повзолдяет полуить метоописание обьекта student по его стоковому имени
            var fields = type.GetFields(BindingFlags.NonPublic | BindingFlags.Instance);//через перегрузку
            //формуируем список элементов типа Student,в списке непубличные и экземплярные поля, свойства и тд.

            foreach (var fieldInfo in fields)
            {
                if (fieldInfo.Name == "_temp")//если имя элемента совпадает с _temp те изменяем private int _temp = 7;
                {
                    //fieldInfo наследуется от memberInfo и дает описание только полей
                    var value = fieldInfo.GetValue(student);//получили зачение поля fieldInfo в тором сейча находится private int _temp = 7;
                    Console.WriteLine($"До {value}");

                    //
                    fieldInfo.SetValue(student, 12);//меняем значение этого поля, в обьекте student int _temp = 12;

                    value = fieldInfo.GetValue(student);
                    Console.WriteLine($"После {value}");
                }
            }
        }
    }

при помощщи метаданных можно менять релаьные данные
------------------------------------------

     static void Main(string[] args)
        {
            Type type = typeof(Student);//получаем метаописание типа по самому типу

            ConstructorInfo constructorInfo = type.GetConstructor(new Type[] {});//у метаописания получаем его конструктор,
            //он содержит описание тех пармтеров которые мы бы передавали в консткруото нашего экземпляра, передаем пустой массив тк
            //Student не имеет констурктора с параметрами

            //получаем нетипизированыый обьект мы работаем с метаописакнием типа вов время выполнения программы а типизация обьектов просиходит во время запуска программы
            var student = constructorInfo?.Invoke(new object[]{});//через Invoke вызываем реальный консткртор 
            //

            var fields = type.GetFields(BindingFlags.NonPublic|BindingFlags.Instance);

            foreach (var fieldInfo in fields)//если имя элемента совпадает с _temp те изменяем private int _temp = 7;
            {
                if (fieldInfo.Name == "_temp")
                {
                    //fieldInfo наследуется от memberInfo и дает описание только полей
                    var value = fieldInfo.GetValue(student);//получили зачение поля fieldInfo в тором сейча находится private int _temp = 7;
                    Console.WriteLine($"До {value}");

                    //
                    fieldInfo.SetValue(student, 12);//меняем значение этого поля, в обьекте student int _temp = 12;

                    value = fieldInfo.GetValue(student);
                    Console.WriteLine($"После {value}");
                }
            }


        }

создание словаря с определенгными элементами из класса
------------------------------------------
Type to = typeof(String);//дляклассов 
Type t = ss.GetType();//для переменных

     private void DictionaryAdd()
        {
          
            var type1 = typeof(Form1)//рефлексим класс по названию
            var type2 = type1.GetFields();// получаем все поля из него

            foreach (var types in type2)
            {
                
                if (types.FieldType.Name == "Button")// если имя типа элеменат == кнопке ... 
                {
                    elems.Add(types.Name, types.GetValue(this));//... то добаляем в словарь
                }
               
            }
            SafeGetComponent<Button>("CalcDelta").BackColor = Color.Red;
        }

         public T SafeGetComponent<T>(string name) where T : Component//присваивание типа определенному элменту 
         //тк рефлекшн возрващает обджекты 
        {
            return elems[name] as T;//.FirstOrDefault(e => e is T component && component.name == name ) as T;
        }

получение данных из приватной (private) перменной через рефлексию
------------------------------------------
  class Point
     {
         private int x;
 
         public void SetX(int x)
         {
             this.x = x;
         }
     }

  static void Main(string[] args)
        {
            Point p = new Point();
            p.SetX(3);

            var str = GetInstanceField(typeof(Point), p, "x");
            var ss = (int) str;
            Console.WriteLine(ss);
            Console.ReadLine();
        }

        //Type type -  для имени класса (typeof(имя класса),  object instance для экземпляраа класса object 
        //экз. класса, string fieldName - для имени перменной
        internal static object GetInstanceField(Type type, object instance, string fieldName)
        {
            //задаем параметр поиска 
            BindingFlags bindFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic
                                     | BindingFlags.Static;
            FieldInfo field = type.GetField(fieldName, bindFlags);
            //возвращаем значение искомой пермененной в виде object
            return field.GetValue(instance);
        }
    }


==========================================

------------------------------------------
--атрибут--attributes--

иногда тербуетс предетаь дополнительну информацию про тот или иной обьекта через механиз рефлексии, те это дополниельная инфа о том
или  ином объекте.
атрибуты это вроде как советы как выполнит код наилучшим образом(наиболе эффективно), атрибуты могуть быть добавлены 
к декларациям классов к методам к аругментнтам.
атрибуты сами по себе пассивыны (если в коде нигде не проверяются их значения)они не выполняются как код, а только содержат значения 
для упрвления работой кода



------------------------------------------
испльзовнание атрибутов в качестве расширения таблицы метаданых(атрибут в качестве метки )

using System;

namespace Experement
{
    public class MyFirstAttribute : Attribute//класс который наследуется от Attribute
    {
        //тк атрибут является просто доп инфой, то он может не собдержать вообще ничего
    }
    class Student
    {
        private int _temp = 7;

        //можно опускать Attribute при вызове атрибута.сейчас мы пометили свойство Age атрибутом MyFirst, те мы влючили в таблицу метаданных
        //сборки инфу о том что у класса student у свойства Age есть атрибут MyFirst
        [MyFirst]
        public string Age { get; set; }
        
        public string Name { get; set; }

    }
    class MainClass
    {
        public static void Main(string[] args)
        {
            var student = new Student();

            var type = student.GetType();

            var prop = type.GetProperties();//Возвращает все открытые свойства текущего объекта Type. в данном случае Age и Name

            foreach (var item in prop)//перебирваем все свойства из класса Student
            {
                var atributes = item.GetCustomAttributes(typeof(MyFirstAttribute),
                    false);//у каждого свойства вызывается GetCustomAttributes он получает атрибуты через их метоописания
                           //типа typeof(MyFirstAttribute, true для поиска атрибутов в цепочке наследования
                           //этого элемента. в противном случае — false. Этот параметр игнорируется для свойств и событий.

                if (atributes.Length>0)//если atributes массив с атрибутами не пустой то выводим все относящиеся к этому атрибуту свойства
                {
                    Console.WriteLine(item.Name);
                }
            }

        }
    }
}


------------------------------------------
можно расщирять атрибуты любым количеством свойств и присваивать их во время создания обьектов, но тк атрибуты существуют для метоопасания
а оно создается во времся создания сборки, то передача занчение свойства нельзя пердавать какието перменые свойста методы и тд,
можно передвать  ТОЛЬКО КОНСТНАНТЫ!


using System;

namespace Experement
{
    public class MyFirstAttribute : Attribute//класс который наследуется от Attribute
    {
        public int Num { get; set; }
    }
    class Student
    {
        private int _temp = 7;

        //можно опускать Attribute при вызове атрибута.сейчас мы пометили свойство Age атрибутом MyFirst, те мы влючили в таблицу метаданных
        //сборки инфу о том что у класса student у свойства Age есть атрибут MyFirst
        [MyFirst(Num = 1)]//если у атрибута есть свойство(Num) то можно во время помечания атрибутом свойства(Age) укзать его(Num), и
                          //присовить ему какоето занчение
        public string Age { get; set; }

        public string Name { get; set; }

    }
    class MainClass
    {
        public static void Main(string[] args)
        {
            var student = new Student();

            var type = student.GetType();

            var prop = type.GetProperties();//Возвращает все открытые свойства текущего объекта Type. в данном случае Age и Name

            foreach (var item in prop)//перебирваем все свойства из класса Student
            {
                var atributes = item.GetCustomAttributes(typeof(MyFirstAttribute),
                    false);//у каждого свойства вызывается GetCustomAttributes он получает атрибуты через их метоописания
                           //типа typeof(MyFirstAttribute, true для поиска атрибутов в цепочке наследования
                           //этого элемента. в противном случае — false. Этот параметр игнорируется для свойств и событий.

                if (atributes.Length > 0)//если atributes массив с атрибутами не пустой то выводим все относящиеся к этому атрибуту свойства
                {
                    var atribute = (MyFirstAttribute)atributes[0];//берем первй элмент массива приводим его к MyFirstAttribute потому что его мы и искали
                    
                    Console.WriteLine($"Имя свойства с атрибутом {item.Name}, значение свойства атрибута {atribute.Num}");//и выводим свойство Num = 1
                
                }
            }

        }
    }
}

------------------------------------------
ограничение области действия атрибутов (по умлочанию атрибут можно применять к чему угодно)

//задаем область дествия атрибута в даном случае целью нашего тарибута могут быть только свойтсва,
 //если применть кадтоа в иное место то получим ошибку компиляции
 [AttributeUsage(AttributeTargets.Property)]
    public class MyFirstAttribute : Attribute//класс который наследуется от Attribute
    {
        public int Num { get; set; }
    }

==========================================

 


--Циклы--
------------------------------------------

пример switch

  return key switch
            {
                "c" => new ChatClient(),
                "s" => new ChatServer(),
                _ => null
            };


public StopBits ConvertStopBits(int stopBit)
        {
            return stopBit switch
            {
                1 => StopBits.One,
                2 => StopBits.Two,
                _ => StopBits.One
            };
        }

        
==========================================




--Делегаты--
------------------------------------------
Делегаты представляют такие объекты, которые указывают на методы. 
То есть делегаты - это указатели на методы и с помощью делегатов мы можем вызвать данные методы.

Если делегат принимает параметры, то в метод Invoke передаются значения для этих параметров.

Другой пример анонимных методов - передача в качестве аргумента для параметра, который представляет делегат
о в одной используется ?
------------------------------------------
delegate void MessageHandler(string message);


    static void ShowMessage(string mes, MessageHandler handler) //handler теперь указывает на анонимный метод 
    //и по сути является им
    {
        handler(mes); Отсюда вызывается сообщение на консоль!
    }

     static void Main(string[] args)
    {
        ShowMessage("hello!", delegate(string mes)
        { 
        Console.WriteLine(mes); 
        });//Здесь всего лишь передаем параметры 
        //для функции
    }


------------------------------------------
использование делегатов в качестве парметров анонимного метода;
 int[] integers = { 2, 7, 3, 6, 5, 4, 7, 8, 9 };

            // найдем сумму чисел больше 5
            int result = Sum(integers, ss => ss > 5);//эта записаь аналогична нижеследующей...
            Console.WriteLine(result);

            // найдем сумму четных чисел
            int result2 = Sum(integers, delegate(int ss)//...эта записаь аналогична вышеследующей
            {
                if (ss % 2 == 0)
                {
                    return true;
                }

                return false;
            });
            Console.WriteLine(result2);
        }

        private static int Sum(int[] numbers, IsEqual funcx)
        {
            int result = 0;
            foreach (int i in numbers)
            {
                if (funcx(i))
                    result += i;
            }
            return result;
        }
------------------------------------------
Делегаты и метода со скобками и без скобок
 // Объявить тип делегата. 
    delegate string StrMod(string str);
    class StringOps
    {
        // Заменить пробелы дефисами. 
        public string ReplaceSpaces(string s)
        {
            Console.WriteLine("Замена пробелов дефисами.");
            return s.Replace(' ', '-');
        }
        // Удалить пробелы. 
        public string RemoveSpaces(string s)
        {
            string temp = "";
            int i;
            Console.WriteLine("Удаление пробелов.");
            for (i = 0; i < s.Length; i++)
                if (s[i] != ' ') temp += s[i];
            return temp;
        }
    }

    delegate int CountIt(int end);

    class VarCapture
    {
        public static CountIt Counter()//в том методе явно создавался новый анонимный
            //делегат, который потом возвращался этим методом
        {
           
            
            CountIt ctObj = delegate(int end)//создание ананоимного делегата
            {
                int sum = 0;
                for (int i = 0; i <= end; i++)
                {
                    Console.WriteLine(i);
                    sum += i;
                }

                return sum;
            };
            return ctObj;//возвращение анонимного делегата
        }
    }

    class DelegateTest
    {
        static void Main()
        {
            StringOps so = new StringOps(); // создать экземпляр 
            // объекта класса StringOps 
            string str;

            // Инициализировать делегат. 
            StrMod strOp = so.ReplaceSpaces;//Вот в этой строчке инициализируется делегат
            //ссылкой на метод, потому тут скобки не нужны.
            str = strOp("Это простой тест");// Вызвать методы с помощью делегатов. 
            Console.WriteLine("Результирующая строка: " + str);
            

            strOp = so.RemoveSpaces;//Вот в этой строчке инициализируется делегат
            //ссылкой на метод, потому тут скобки не нужны.
            str = strOp("Это простой тест");// Вызвать методы с помощью делегатов. 
            Console.WriteLine("Результирующая строка: " + str);
            
            CountIt count = VarCapture.Counter();//здесь вызывается метод, который создает
            //делегат, а не создается делегат, а если мы вызываем метод, то обязательно нужны скобки.

            int result;
            result = count(3);
            Console.WriteLine("Сумма 3 равна " + result);
            Console.WriteLine();
            result = count(5);
            Console.WriteLine("Сумма 5 равна " + result);
        }
    }
------------------------------------------
 обобщённый делегат;

delegate возвращаемый_тип имя_делегата<список_параметров_типа>(список_аргументов);
delegate T 				  Operation	  <T, K ,J>				  (K val, J value);

        class Program
        {
            static void Main(string[] args)
            {
                Operation<decimal, int, string> op = Square;

                Console.WriteLine(op(5, "2"));
                Console.Read();
            }

            static decimal Square(int n, string ss)
            {
                n += int.Parse(ss);
                return n * n;
            }
        }

------------------------------------------    
    View.OpenSettings += () => OpenSettings(); //так можно избежать требований сигнатуры метода при вызове экшана,
    но при этом -= отключит анонимный метод но не OpenSettings()


------------------------------------------
Ковариантность делегатов

Ковариантность позволяет возвращать из метода объект, тип которого является производным от типа, возвращаемого делегатом
(предпологается upcasting).

Ковариантность - выходящие из банка могут быть не просто людьми, но и клиентами банка.
Ковариантностью называется сохранение иерархии наследования исходных типов в производных типах в том же порядке.
 Так, если класс Cat наследуется от класса Animal, то естественно полагать, что перечисление IEnumerable<Cat> 
 будет потомком перечисления IEnumerable<Animal>. Действительно, «список из пяти кошек» — это частный случай «списка из 
 пяти животных». 
 В таком случае говорят, что тип (в данном случае обобщённый интерфейс) IEnumerable<T> ковариантен своему 
 параметру-типу T.


 class Person
    {
        public string Name { get; set; }
    }

    class Client : Person
    {
        public string LastName { get; set; }
    }

    delegate Person PersonFactory(string name);//делегат возвращает тип Person
    //который является базовым типом для производного типа Client


    class Programm
    {
        private static Person BuildPerson(string name)//этот метод у нас возвращает обьект 
        //Person что соотвтетвует делегату PersonFactory здесь нет необходимости  использовать
        //ковариантность делегатов
        {
            return new Person
            {
                Name = name
            };
        }

        private static Client BuildClient(string name) // этот метод возрващает
        //обьект класса Client, что недолжно бы соответовать делегату PersonFactory,
        //НО КОВАРИАНТНОСТЬ позволяет вставить этот метод в этот делегат и вернуть из метода
        //объект Client - тип который является ПРОИЗВОДНЫМ от типа  который возвращает делегат
        //PersonFactory (делегат Person PersonFactory(string name) возвращает тип Person 
        //который является базовым для Client)
        {
            return new Client//возвращаем из метода объект Client
            {
                Name = name
            };
        }
        static void Main(string[] args)
        {
            PersonFactory personDel; //создаем перменную делегата она предназначена для методов возвращающих 
            //обьекты класса Person

            personDel = BuildPerson;// инициализируем перменную делегата методом который возварщает
            //обьект Person те используем делегат стандартно без использованиря апкастов 
            Person p = personDel("Tom");
            Console.WriteLine($"{p.Name} {p.GetType()}");// Tom ExperementNetCore.Person
            
            personDel = BuildClient; // инициализируем перменную делегата методом который возварщает
            //обьект Client те используем делегат конвариантно
            Person p2 = personDel("Max"); // То есть здесь делегат возвращает объект Client и
            //апкастит его к обьекту класса Person 
            Console.WriteLine(p2.Name + " " + p2.GetType());//Max ExperementNetCore.Client

            Console.Read();
        }
    }


Ковариантность - выходящие из банка могут быть не просто людьми, но и клиентами банка.
Ковариантностью называется сохранение иерархии наследования исходных типов в производных типах в том же порядке.
 Так, если класс Cat наследуется от класса Animal, то естественно полагать, что перечисление IEnumerable<Cat> 
 будет потомком перечисления IEnumerable<Animal>. Действительно, «список из пяти кошек» — это частный случай «списка из 
 пяти животных». 
 В таком случае говорят, что тип (в данном случае обобщённый интерфейс) IEnumerable<T> ковариантен своему 
 параметру-типу T.


  class Car
    {
        public void Drive()
        {

        }
    }

    class Mersedes : Car
    {
        public string ClassName;//расширяем базовый функционалл класса Car
    }


    class Uaz : Car
    {
        public string MaxSpeed;//расширяем базовый функционалл класса Car
    }

    delegate T MyDelegate<out T>(); //указывает на то что тут будет использоватсяя ковариантность,
    //позволяет возвращать из метода обьект тип которого является производным от типа возращаемого делегатом
    //
    
    class Programm
    {
        static Mersedes MersedesBuilder()
        {
            return new Mersedes();
        }
        static Mersedes MersedesBuilderTwo()
        {
            return new Mersedes();
        }


        static Uaz UazBuilder()
        {
            return new Uaz();
        }


        static void Main(string[] args)
        {
            MyDelegate<Mersedes> mers = MersedesBuilder;//создаем делегат типизированный классом Mersedes,
            //ссвязываем этот делегат с методом MersedesBuilder  
            MyDelegate<Car> car = mers;//здесь происходит апкаст, тк мы присваеваем делегату car
            //типизированолму классом Car, делегат типизировный классом Mersedes, те произзводим
            //апкаст делегата

            mers().Drive();
            mers().ClassName = "S-class";

            car().Drive();
            //car().ClassName = "S-class"; это выдаст ошибку тк поле ClassName принадлежит к классу
            //Mersedes.И хотя теперь car и mers указывают на одно и то же место в памяти(MyDelegate<Mersedes>),
            // переменной car будет доступна только та часть, которая представляет функционал типа MyDelegate<Car>.
            // Это назыывается  восходящие преобразования или апкаст

            Console.WriteLine(mers.GetType() + " " + car().GetType());//mers.GetType() в этом примере делегат
            //инициализируется ссылкой на метод, потому тут скобки нет.
            //А здесь car().GetType() здесь через делегат вызываем метод static Mersedes MersedesBuilder(),
            //на который ссылается данный делегат, а не создаем делегат как в примере выше,
            //а если мы вызываем метод, то обязательно нужны скобки.

            MyDelegate<Uaz> uaz = UazBuilder;
            MyDelegate<Car> car2 = uaz;

            //car.Invoke().MaxSpeed = "15";//это выдаст ошибку тк поле MaxSpeed принадлежит к классу Uaz
            //а ссылочная перменная обьект car указывает сейчас на на клсасс в   

            Console.WriteLine();

        }
    }

------------------------------------------ 
Контрвариантность делегата 
Контрвариантность делегата предполагает, что типом параметра может быть более универсальный тип.(предпологается downcasting)
Контрвариантность - в банк могут входить люди. 

Так, если класс String наследуется от класса Object, а делегат Action<T> определён как метод, принимающий объект типа T, 
то Action<Object> наследуется от делегата Action<String>, а не наоборот. Действительно, если «все строки — объекты», 
то «всякий метод, оперирующий произвольными объектами, может выполнить операцию над строкой», но не наоборот.

Как и в случае с обобщенными интерфейсами параметр ковариантного типа применяется только к типу значения,
 которые возвращается делегатом. 
А параметр контравариантного типа применяется только к ВХОДНЫМ АРГУМЕНТАМ делегата.


class Person
{
    public string Name
    { 
      get; set;
    }
}
class Client : Person 
{
}


delegate void ClientInfo(Client client); //Несмотря на то, что делегат в качестве параметра принимает объект Client...


static void Main(string[] args)
{
    ClientInfo clientInfo = GetPersonInfo; //используем контравариантность
    Client client = new Client{Name = "Alice"};
    clientInfo(client);
    Console.Read();
}
private static void GetPersonInfo(Person p)//...ему можно присвоить метод, принимающий в качестве параметра объект базового типа Person.
{
    Console.WriteLine(p.Name);
}

Может показаться на первый взгляд, что здесь есть некоторое противоречие, то есть использование более универсального тип вместо более
производного. Однако в реальности в делегат при его вызове мы все равно можем передать только объекты типа Client,
а любой объект типа Client является объектом типа Person, который используется в методе

------------------------------------------
Делегаты Action, Predicate и Func

Делегат Action является обобщенным, принимает параметры и возвращает значение void:
------------------------------------------
public delegate void Action<T>(T obj);
 можно передать до 16 значений в метод.
public delegate void Action<T,T2,...T16>(T obj,T2 obj2,...T16 obj16);

Как правило, этот делегат передается в качестве параметра метода и предусматривает вызов определенных действий 
в ответ на произошедшие действия

static void Main(string[] args)
            {
                Action<int, int> op;
                op = Add;
                Operation(10, 6, op);//Оператион через экщен ор делает сумму 10 и 6
                op = Substract;
                Operation(10, 6, op);//Оператион через экщен ор делает умножение 10 и 6
            }

            static void Operation(int x1, int x2, Action<int, int> op)//один и тот же метод делает 
            //разные вещи в зависимости от значения экшена ор
            {
                if (x1 > x2)
                    op(x1, x2);
            }

            static void Add(int x1, int x2)
            {
                Console.WriteLine("Сумма чисел: " + (x1 + x2));
            }

            static void Substract(int x1, int x2)
            {
                Console.WriteLine("Разность чисел: " + (x1 - x2));
            }

         
------------------------------------------
Predicate

Predicate<int> isPositive = x => x > 0;

                Console.WriteLine(isPositive(20));
                Console.WriteLine(isPositive(-20));


------------------------------------------
Func

возвращает результат действия и может принимать 
параметры. Он также имеет различные формы: от Func<out T>(), где T - тип возвращаемого значения, 
до Func<in T1, in T2,...in T16, out TResult>(), то есть может принимать до 16 параметров.

TResult Func<out TResult>()
TResult Func<in T, out TResult>(T arg)
TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2)
TResult Func<in T1, in T2, in T3, out TResult>(T1 arg1, T2 arg2, T3 arg3)
TResult Func<in T1, in T2, in T3, in T4, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4)

Метод GetInt() в качестве параметра принимает делегат Func<int, int>, то есть ссылку на метод,
 который принимает число int и возвращает также значение int.
static void Main(string[] args)
          {
              Func<int, int> retFunc = Factorial;
              int n1 = GetInt(6, retFunc);
          }
static int GetInt(int x1, Func<int, int> retF)
  			{
  			    int result = 0;
  			    if (x1 > 0)
 			         result = retF(x1);
  			    return result;
  			}
 static int Factorial(int x)//Func<int, int> в качестве парметра принимает именно этот метод
 //где <int... - это значение в аргументе жаного мтеода, а  ...int> это возварщаемое из метода значение
            {
                int result = 1;
                for (int i = 1; i <= x; i++)
                {
                    result *= i;
                }

                return result;
            }

------------------------------------------
пример реализации делегатов

delegate void AccountStateHandler(string message);//создаем делегат
 class Person
    {
        private AccountStateHandler _del;//создаем перменную делегата

        private string name;
        public void RegisterHandler(AccountStateHandler del)//создаем регистратор перменной делегата 
        //чтобы потом записать в него метод который будет вызватся при произведении нашего действия
        {
            _del = del;
        }

        public string Name
        {
            get
            {
                return name;
            }
            set => name = value;
        }

        public void DisplayTo()//наше действие 
        {
            _del(name);//когда вызывается это метод происходит вызов делегата те вставленого туда в 
            //процессе регистрации метода и вставляем в аргумент этого метода перменную name
        }

    }
    class Employee : Person
    {

    }
    class Program
    {
        static void Main(string[] args)
        {

            Person p = new Person{Name = "Tomm"};
            p.RegisterHandler(new AccountStateHandler(Display));//регистарция и присвоение в делегат 
            //того мтоеда Display кторый будет вызватся при вызове делегата
            p.DisplayTo();//вызываем наш делегат 
            p = new Employee { Name = "Sam" };
            p.RegisterHandler(new AccountStateHandler(Display));
            p.DisplayTo();
           
           
            Console.Read();
        }

        static void Display(string name)//этот метод будет вызыватся при использовании делегата
        {
            Console.WriteLine(name);
        }
    }


------------------------------------------
пример реализации ивентов
delegate void AccountHandler(string message);
    class Person
    {
        public event AccountHandler _notify;
        private string name;
        string tempName;
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value != name)
                {
                    name = value;
                    DisplayTo();
                }
                
            }
        }

        public void DisplayTo()
        {
            _notify?.Invoke(name);
        }

    }
    class Employee : Person//этот класс будет реализовывать тот же функционал, что и класс Person
                           //Таким образом, наследование реализует отношение is-a (является),
                           //объект класса Employee также является объектом класса Person:
    {

    }
    class Program
    {
        static void Main(string[] args)
        {

            Person p = new Person();
            p._notify += Display;
            p.Name = "flfl";
            p = new Employee();//И поскольку объект Employee является также и объектом Person,
                               //то мы можем так определить переменную: Person p = new Employee().

            p._notify += Display;//но так как новый экземпляр всегода
            //создается с дефолтными значениями
            //нам нажно переподключится к ивенту
            p.Name = "Josh";
            Console.Read();
        }

        static void Display(string name)
        {
            Console.WriteLine(name);
        }
    }

==========================================

--String--
------------------------------------------
tring
Прежде всего, объект String представляет собой неизменяемую строку. 
Когда мы выполняем какой-нибудь метод класса String, система создает новый объект в памяти с 
выделением ему достаточного места.

------------------------------------------
Форматирование и интерополяция строк

эта запись аналогина
 Console.WriteLine("Имя: {0}  Возраст: {1}", person.Name, person.Age);
этой записи
string output = String.Format("Имя: {0}  Возраст: {1}", person.Name, person.Age);//Format принимает строку с плейсхолдерами типа {0}, {1} и т.д.,
// а также набор аргументов, которые вставляются на место данных плейсхолдеров. В итоге генерируется новая строка.
Console.WriteLine(output);

------------------------------------------
C / c - Задает формат денежной единицы, указывает количество десятичных разрядов после запятой

D / d - Целочисленный формат, указывает минимальное количество цифр

E / e - Экспоненциальное представление числа, указывает количество десятичных разрядов после запятой

F / f - Формат дробных чисел с фиксированной точкой, указывает количество десятичных разрядов после запятой

G / g - Задает более короткий из двух форматов: F или E

N / n - Также задает формат дробных чисел с фиксированной точкой, определяет количество разрядов после запятой

P / p - Задает отображения знака процентов рядом с число, указывает количество десятичных разрядов после запятой

X / x - Шестнадцатеричный формат числа

пример использования:

double number = 23.7;

string result = String.Format("{0:C}", number);
Console.WriteLine(result); // $ 23.7

string result2 = String.Format("{0:C2}", number);//указываем колво знаков после запятой - 2,
//При выводе также добавляется обозначение денежного знака для текущей культуры компьютера.
Console.WriteLine(result2); // $ 23.70

int number = 23;
string result = String.Format("{0:f}", number);//дробны чисел используется описатель F, число после которого указывает,
//сколько знаков будет использоваться после разделителя между целой и дробной частью. Если исходное число - целое, то к нему добавляются разделитель и нули.
Console.WriteLine(result); // 23,00
 
double number2 = 45.08;
string result2 = String.Format("{0:f4}", number2);
Console.WriteLine(result2); // 45,0800

------------------------------------------
ToString
Метод ToString() не только получает строковое описание объекта, но и может осуществлять форматирование. 
Он поддерживает те же описатели, что используются в методе Format:

ong number = 19876543210;
Console.WriteLine(number.ToString("+# (###) ###-##-##"));// +1 (987) 654-32-10
 
double money = 24.8;
Console.WriteLine(money.ToString("C2")); // $ 24,80

-----------------------------------------
интерполяция строк
Знак доллара перед строкой указывает, что будет осуществляться интерполяция строк. Внутри строки опять 
же используются плейсхолдеры {...}, 

Person person = new Person { Name = "Tom", Age = 23 };
 
Console.WriteLine($"Имя: {person.Name}  Возраст: {person.Age}");// внутри фигурных скобок уже можно напрямую писать те выражения, которые мы хотим вывести.
==========================================
--String.Intern--
------------------------------------------

==========================================

--StringBuilder--
------------------------------------------
Хотя класс System.String предоставляет нам широкую функциональность по работе со строками, все таки он имеет свои недостатки. 
Прежде всего, объект String представляет собой НЕИЗМЕНЯЕМУЮ строку, Когда мы выполняем какой-нибудь метод класса String, 
система создает новый объект в памяти с выделением ему достаточного места.

При создании строки StringBuilder выделяет памяти больше, чем необходимо этой строке:

StringBuilder sb = new StringBuilder("Привет мир");
            
Console.WriteLine($"Длина строки: {sb.Length}");//длина билдера 10 смиволов, но реально емкость будет составлять по умолчанию 16 символов
Console.WriteLine($"Емкость строки: {sb.Capacity}");//максимальное число знаков, которое может содержаться в памяти, назначенной для sb == 16

Если у нас заранее известен максимальный размер объекта, то мы можем таким образом сразу задать емкость и избежать 
последующих издержек при дополнительном выделении памяти.

пример работы биллдера


  StringBuilder sb = new StringBuilder("Название: ");
            Console.WriteLine($"Длина строки: {sb.Length}"); // 10
            Console.WriteLine($"Емкость строки: {sb.Capacity}"); // При создании объекта StringBuilder выделяется память по умолчанию для 16 символов, 
//так как длина начальной строки меньше 16.
 
            sb.Append(" Руководство");//Append - этот метод добавляет к строке подстроку
            Console.WriteLine($"Длина строки: {sb.Length}"); // 22
            Console.WriteLine($"Емкость строки: {sb.Capacity}"); //  Так как при объединении строк их общая длина - 22 символа - превышает начальную емкость в 16 символов, 
//то начальная емкость удваивается - до 32 символов.
 
            sb.Append(" по C# для чайников и прочих вынфишм1234567");
            Console.WriteLine($"Длина строки: {sb.Length}"); // 65
            Console.WriteLine($"Емкость строки: {sb.Capacity}"); // если длина строки выыше 64 символв то ее емкость будет продолжать расширятся до реальной
                                                                 // длины строки == 65

            
  StringBuilder sb = new StringBuilder("Привет мир");
            sb.AppendFormat("!");//AppendFormat*: добавляет подстроку в конец объекта StringBuilder 

            sb.Insert(7, "компьютерный ");//Insert: вставляет подстроку в объект StringBuilder, начиная с определенного индекса
            sb.Append("&");
            Console.WriteLine(sb);//Привет компьютерный мир&!
            
            // заменяем слово
            sb.Replace("мир", "world");//Replace: заменяет все вхождения определенного символа или подстроки на другой символ или подстроку
            Console.WriteLine(sb);//Привет компьютерный world!&

            // удаляем 13 символов, начиная с 7-го
            sb.Remove(7, 13);//Remove: удаляет определенное количество символов, начиная с определенного индекса
            Console.WriteLine(sb);//Привет world!&

*метод AppendFormat во многом аналогичен функции String.Format - он принимает набор параметров, которые добавляются в строку:
StringBuilder builder = new StringBuilder();
builder.AppendFormat("Число: {0}, срока: {1}", 23, "hello");
Console.WriteLine(builder.ToString());//приводим билдер к строке

Microsoft рекомендует использовать класс String в следующих случаях:

-При небольшом количестве операций и изменений над строками

-При выполнении фиксированного количества операций объединения. В этом случае компилятор может объединить все операции объединения в одну

-Когда надо выполнять масштабные операции поиска при построении строки, например IndexOf или StartsWith. Класс StringBuilder не имеет подобных методов.

Класс StringBuilder рекомендуется использовать в следующих случаях:

-При неизвестном количестве операций и изменений над строками во время выполнения программы

-Когда предполагается, что приложению придется сделать множество подобных операций

==========================================


--Enum перечисления--
------------------------------------------
По умолчанию первому элементу п ивается значение 0, а остальным элементам значения устанавливаются по схеме п+1.
enum ЕmmpТуре
{
Manager, //0
Grunt, //1
Contractor, //2 
VicePresident //3 
}


если нужно начать не с нуля тио можно написта так 

Manager =102, //102
Grunt, //103
Contractor, //104 
VicePresident //105
------------------------------------------
Нумерация в перечислениях не обязательно должна быть последовательной и содержать только уникальные значения.

enum ЕmpТуре

{ 
  Manager = 10, 
  Grunt = 1, 
  Contractor = 100, 
  VicePresident = 9
}

По умолчанию для хранения значений перечисления используется int
Перечисления в C# можно определять в похожей манере для любых основных системных типов 
(byte, short, int или long).
//На этот раз для элементов ЕтрТуре используется тип byte, 

enum ЕmpmТуре : byte

{ 
  Manager = 10, 
  Grunt = 1, 
  Contractor = 100, 
  VicePresident = 999// это вызовет ошибку тк занчение превышет диапоазон byte
}

вызов элемента перечисления
ЕmpТуре етр = ЕmpТуре.Contractor ;

Enum. GetUnderlyingType () возвращает тип данных, используемый для хранения значений перечислимого типа 
(System.Byte в текущем объявлении ЕтрТуре):

ЕтрТуре етр = ЕтрТуре.Contractor; 
// Вывести тип хранилища для значений перечисления.
Console.WriteLine("ЕтрТуре uses а {0} for storage", 
    Enum.GetUnderlyingType(етр.GetType())); //ЕтрТуре uses а System.Byte for storage
Console.ReadLine();

или так 

Enum.GetUnderlyingType(typeof(EmpType)));

------------------------------------------
Кроме метода Enum. GetUnderlyingType () все перечисления C# поддерживают метод по имени ToString (), 
который возвращает строковое имя текущего значения перечисления

 EmpType emp = EmpType.Contractor;
            Console.WriteLine("{0}", emp.ToString()); Console.ReadLine();// Выводит строку "Contractor",
                                                                         // те имя элемента перечисления

Если интересует не имя, а значение заданной переменной перечисления, то можно просто привести ее к лежащему в основе типу хранения, например:

static void Main(string[] args) {

EmpType emp = EmpType.Contractor;

Console.WriteLine("{0} = {1}", emp.ToString() , (byte)emp);// Выводит строку "Contractor = 100". 
==========================================


--IEnumerable--IEnumerator--
------------------------------------------
Как мы увидели, основной для большинства коллекций является реализация интерфейсов IEnumerable и IEnumerator.
 Благодаря такой реализации мы можем перебирать объекты в цикле foreach:

 foreach(var item in перечислимый_объект)
{
     
}

------------------------------------------
Интерфейс IEnumerable имеет метод, возвращающий ссылку на другой интерфейс - перечислитель:

public interface IEnumerable
{
    IEnumerator GetEnumerator();//А интерфейс IEnumerator определяет функционал для перебора внутренних объектов в контейнере:
}

public interface IEnumerator
    {
        bool MoveNext(); //Метод MoveNext() перемещает указатель на текущий элемент на следующую позицию в последовательности.
        //Если последовательность еще не закончилась, то возвращает true. Если же последовательность закончилась, то возвращается false.
        object Current { get; }  // текущий элемент в контейнере (объект в последовательности, на который указывает указатель)
        void Reset(); // перемещение в начало контейнера  (сбрасывает указатель позиции в начальное положение.)
    }

Каким именно образом будет осуществляться перемещение указателя и получение элементов зависит от реализации интерфейса.
 В различных реализациях логика может быть построена различным образом.
 
==========================================


--массив-array--
------------------------------------------
Массив - набор однотипных данных, обявление массива похоже на обявление пременной только с []

типПерменныхМассива[] названиеМассива;//одномерный, его можно предствить в виде горизонтального списка элементов

Ранг (rank): количество измерений массива.
Длина измерения (dimension length): длина отдельного измерения массива.
Длина массива (array length): количество всех элементов массива.

после обявления массива можно выделить ему место в памяти через new и присоить ему размер 

//массив состоит из 4 элементов 0,1,2,3 в каждом из них пока что null
int[] nums = new int[4];

------------------------------------------
можно сразу записать в этот массив какието данные

//массив состоит из элементов 1,2,3,5 (эти инициализации аналогичны)
int[] nums2 = new int[4] { 1, 2, 3, 5 };
 
int[] nums3 = new int[] { 1, 2, 3, 5 };
 
int[] nums4 = new[] { 1, 2, 3, 5 };
 
int[] nums5 = { 1, 2, 3, 5 };

------------------------------------------
для обращения к элементаам массива используются индексы, нумерация с 0

int[] nums = new int[4];
nums[0] = 1;
nums[1] = 2;
nums[2] = 3;
nums[3] = 5;
Console.WriteLine(nums[3]);  //в массиве nums по инддекус 3 будет значение 5

------------------------------------------
перебор массива foreach перебирает массив полностю от 1 элмента до последнего 
используется ТОЛЬКО для ЧТЕНИЯ

int[] numbers = new int[] { 1, 2, 3, 4, 5 };
//переберет весь масиив и вывед все го элменты в консолль
foreach (int i in numbers)
{

    Console.WriteLine(i);
}
------------------------------------------
перебор массива for() можно как чиать так и МЕНЯТЬ элменты массива

int[] numbers = new int[] { 1, 2, 3, 4, 5 };
//переберет весь массив умножит каждый элемент массива на 2 и выведет каждый элмент в консоль
for (int i = 0; i < numbers.Length; i++)
{
     numbers[i] = numbers[i] * 2;
    Console.WriteLine(numbers[i]);
}

------------------------------------------
--Многомерные массивы
у массивов есть измерения массив типа int[] arr одномерный, его можно предствить в виде горизонтального списка элементов,
но есть так же и многомерные массивы у таких массивов количество измерений больше 1 двумерный массив int[,] array,
это по сути такблица у кторой етсь столлбыцы и колонки

создадим одномерный и двухмерный массивы, которые имеют одинаковые элементы:
int[] nums1 = new int[] { 0, 1, 2, 3, 4, 5 };
int[,] array = {{0,1,2},{,3,4,5}};
 //                1 измерение
    //индексы      0        1      
    //          {     },{      }

    //             2 измерение
    //          {0,1,2}
    //индексы    0,1,2
------------------------------------------
обявлление двумерного массиваа
int[,] nums1;
int[,] nums2 = new int[2, 3];

------------------------------------------
инициализация двумерного массиваа
//массив состоит из элементов 1,2,3,4,5  (эти инициализации аналогичны)

int[,] nums3 = new int[2, 3] { { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums4 = new int[,] { { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums5 = new [,]{ { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums6 = { { 0, 1, 2 }, { 3, 4, 5 } };

------------------------------------------
Массивы могут иметь и большее количество измерений. Объявление трехмерного массива могло бы выглядеть так 
int[,,] nums3 = new int[2, 3, 4];

трехмерный массив по сути имеет трехмерный списко у него есть столлбцы колонки и глллубина в виде 3 измерения
int[,] nums5 = new [,]{ { 0, 1, 2 }, { 3, 4, 5 }, {6, 7, 8}};

------------------------------------------
перебор многомерного маассива, длина такого массива СОВОКУПНОЕ КОЛ-ВО ЭЛ-ТОВ

int[,] mas = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 }, { 10, 11, 12 } };
foreach (int i in mas)
{
    Console.Write($"{i} ");//1 2 3 4 5 6 7 8 9 10 11 12
    Console.WriteLine($"общая длина массива{ints.Length}");//12
}

--
public void ViewGetLength()
{
    int[,,] array =
    {
                    { { 1, 2 }, { 3, 4 }, { 5, 6 },{ 7, 8 } },
                    { { 9, 10 }, { 11, 12 },{ 13,14 },{ 15,16 } },
                    { { 17, 18 }, { 19, 20 },{ 21,22 },{ 23,24 } }
    };
    //                              1 измерение
    //            0 {                                       },
    //            1 {                                           },
    //            2 {                                            }

    //                             2 измерение
    //                    0         1        2          3           
    //                {      }, {      }, {      }, {      },   

    //                             2 измерение
    //                { 1, 2 }
    //                  0, 1

    //напрмиер число 6 находится по индексу 0, 2, 1 

    //int[,] array = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
    //возвращает длину массива(количество элементов), из которого необходимо вычесть 1, чтобы получить UpperBound
    int oneDimension = array.GetLength(0);//длина 3
    int twoDimension = array.GetLength(1);//длина 4
    int threeDimension = array.GetLength(2);//длина 2

    for (int i = 0; i < oneDimension; i++)
    {
        for (int j = 0; j < twoDimension; j++)
        {

            for (int k = 0; k < threeDimension; k++)
            {
                Console.Write($"{array[i, j, k]} \t");
                //1       2       3       4       5       6       7       8
                //9       10      11      12      13      14      15      16
                //17      18      19      20      21      22      23      24
            }
        }
        Console.WriteLine();
    }

}

--
 public void ViewUpperBound()
{
    int[,] mas = { { 1, 2 }, { 4, 5 } };
    //                  1 измерение
    //                    0        1      
    //                {      }, {      }

    //                  2 измерение
    //                { 1, 2 }
    //                  0, 1
    //напрмиер число 4 находится по индексу 1, 0 

    //GetUpperBound возвращает наивысший индекс в массиве в 0 измерении, а так как индекс с 0, а длина массива с 1,
    //к GetUpperBound нужно прибавлять 1
    //rows строки
    int rows = mas.GetUpperBound(0) + 1;

    //чтобы получить столбцы нужно длину маассива / длину строки
    //colums столбцы
    int columns = mas.Length / rows;

    // или получить столбцы через нивысший индекс 1 измерения
    //int columns = mas.GetUpperBound(1) + 1;

    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < columns; j++)
        {
            Console.Write($"{mas[i, j]} \t");
            //1 2
            //4 5
        }
        Console.WriteLine();
    }
}
------------------------------------------
--массив массивов или зубчатый массив на это указывают две группы квадратных скобок,  
причем длина массива указывается ТОЛЬКО В ПЕРВЫХ квадратных скобках, все последующие квадратные скобки должны быть ПУСТЫ

//массив nums содержит три массив
int[][] numbers = new int[3][];
numbers[0] = new int[2] {1, 2}; // выделяем память для первого подмассива
numbers[1] = new int[3] {3, 4, 5}; // выделяем память для второго подмассива
numbers[2] = new int[5] {6, 7, 8, 9, 10}; // выделяем память для третьего подмассива

//          списко списков
//      подмассив с индексом 0 {1,2}...
//         индекс в подмассиве  0,1
//например число 5 находящиеся в поддмассиве из 3 элементов можно найти так numbers[1][2] 
Console.WriteLine(numbers[1][2]); //5

//перебор по подмассивам foreach
foreach (int[] row in numbers)
{
    //в подмассиве перебор по элементам
    foreach (int number in row)
    {
        Console.Write($"{number} \t");
        //1       2
        //3       4       5
        //6       7       8       9       10
    }

    Console.WriteLine();
}
--
// перебор по подмассивам for
for (int i = 0; i < numbers.Length; i++)
{
    //в перебор по элементам в подмассиве, через индекс подмассива
    for (int j = 0; j < numbers[i].Length; j++)
    {
        Console.Write($"{numbers[i][j]} \t");
        //1       2
        //3       4       5
        //6       7       8       9       10
    }
    Console.WriteLine();
}

------------------------------------------
Причем мы можем использовать в качестве массивов и многомерные

int[][,] nums = new int[3][,]
                {
                    new int[,] { {1,2}, {3,4} },
                    new int[,] { {1,2,3}, {4,5,6}, {7,8,9}, {10,11,12}},
                    new int[,] { {1,2}, {3,5}, {8, 13} }
                };

                //число 6 находящиеся в поддмассиве из 4 элементов в пермом измерении, и 3 во втором измерении можно найти так numbers[1][1,3]
                //где numbers[1]... - индекс многомерного подмассива, [1,... индекс в первом измерении подмассива, ...3] индекс во втором измерении подмассива
                Console.WriteLine(nums[1][1, 2]);//6

                foreach (int[,] ints in nums)
                {
                    int OneDimentioin = ints.GetLength(0);
                    int TwoDimentioin = ints.GetLength(1);
                    Console.WriteLine($"общая длина массива{ints.Length}");
                    for (int i = 0; i < OneDimentioin; i++)
                    {
                        for (int j = 0; j < TwoDimentioin; j++)
                        {
                            Console.Write($"{ints[i, j]} \t");
                            //1       2       3       4
                            //1       2       3       4       5       6       7       8       9       10      11      12
                            //1       2       3       5       8       13
                        }

                    }
                    Console.WriteLine();
                }
==========================================



--Список--List<T>--
------------------------------------------
класс List<T> из пространства имен System.Collection.Generic 
редставляют собой удивительно гибкий инструмент по работе с коллекциями. Одной из главных особенностей списков является возможность 
использовать любой тип данных. 

------------------------------------------
обявление списка -List<Person> people = new List<Person>();
List<Person> people = new List<Person>(3);//Указание начальной емкости списка (capacity) позволяет в будущем увеличить производительность 
//и уменьшить издержки на выделение памяти при добавлении элементов

------------------------------------------
инициализация списка 
List<int> num = new List<int>() { 1, 2, 3 };

------------------------------------------
методы списка 

num.Add(T item) добавление нового элемента в список (в данном чллучае за T принимается int а за item какето целое число)

num.AddRange(ICollectioin collection) добавление в списко колкции или массива

num.BinarySearch(T item)  бинарный поиск элемента в списке. 
Если элемент найден, то метод возвращает индекс этого элемента в коллекции. 
При этом список должен быть отсортирован.(в данном чллучае за T принимается int а за item какето целое число)

num.IndexOf(T item)- возвращает индекс первого вхождения элемента в списке

num.Insert(int index, T item)- вставляет item в позицию index

num.Remove(T item);- если такой элменет есть в спике удаляет его, и выозвращает true

num.RemoveAt(int index)- удаление элемента по указанному индексу index

num.Sort()- сортировка списка по возрастанию 

------------------------------------------
в списко можно клатсть что угоддно в том числе классы
class ClassForList
{
    public string Name { get; set; }
    public int Age { get; set; }

    public ClassForList(string name, int age)
    {
        Name = name;
        Age = age;
    }
}

List<ClassForList> ClassInList = new List<ClassForList>();//инициаллизация

ClassInList.Add(new ClassForList("Max",12));//добавление клласса

foreach (var classForList in ClassInList)
{
    Console.WriteLine($"name {classForList.Name}, age {classForList.Age}");//полулчение из класса его данных
}
------------------------------------------
--Двусвязный список--LinkedList--

в нем хранится ссылка и на предыдущий и на следующий элемент

Если в простом списке List<T> каждый элемент представляет объект типа T, 
то в LinkedList<T> каждый узел представляет объект класса LinkedListNode<T>.

свойства связаного списка

Value- само значение узла представлленое T

Next -ссылка на следующий элемент типа LinkedListNode<T> в списке. если следующий элмент отсутсвует в Next будет null

Previous- ссылка на следующий элменет типа LinkedListNode<T> в списке. если следующий элмент отсутсвует в Previoius будет null

AddFirst(T value)- вставляет новый узел со значением value в начало списка

AddLast(LinkedListNode<T> node)- вставляет новый узел в конец списка

AddLast(T value)- вставляет новый узел со значением value в конец списка

RemoveFirst()- удаляет первый узел из списка. После этого новым первым узлом становится узел, следующий за удаленным

RemoveLast()- удаляет последний узел из списка

LinkedList<int> num = new LinkedList<int>();
{
    //возварщаемое значение любой из этих оперцаций  LinkedListNode<int> = num.AddLast(1);

    //запись 1 на последнее место в списке, тк список пуст последнее метсто == первое
    num.AddLast(1);//num {1}

    //запись 2 на первое место тк там нахолдится 1, то 1 передивагем на одно место вперед а на его местоставим 2
    num.AddFirst(2);//num {2,1}

    //запись 3 после последнего узла
    num.AddAfter(num.Last, 3);//num {2,1,3}
}
--
{
    //создаем nodeInList и добавляем его в спикок на последнее место(теперь этот nodeInList относится к списку num)
    LinkedListNode<int> nodeInList = num.AddLast(4);//num {2,1,3,4}

    //создаем newNodeAfter (этот newNodeAfter не относится к списку num)
    LinkedListNode<int> newNodeAfter = new LinkedListNode<int>(5);

    //вставляем в num newNode после уже сущесвтующего nodeInList
    //(nodeInList - должен относится к списку в который мы вставяем newNodeAfter - он не должен относится к этому скиску)
    num.AddAfter(nodeInList, newNodeAfter);//num {2,1,3,4,5}

    int val = 6;
    //вставляем в спискок T val после уже сущесвтующего в списке num nodeInList
    num.AddAfter(nodeInList, val);//num {2,1,3,4,6,5}

    //так тоже сработает тк num.AddAfter(nodeInList, newNodeAfter); мы добавили newNodeAfter в список num
    num.AddAfter(newNodeAfter, 6);//num {2,1,3,4,6,5}

    var newNodeBefore = new LinkedListNode<int>(12);

    //работает аналогично  num.AddAfter(nodeInList, newNodeAfter); только вставлят newNodeBefore ПОСЛЕ nodeInList
    num.AddBefore(nodeInList, newNodeBefore);//num {2,1,3,12,4,6,5}

    //работает аналогично  num.AddAfter(nodeInList, val); только вставлят val ПОСЛЕ nodeInList
    num.AddBefore(nodeInList, val);//num {2,1,3,12,6,4,6,5}
}
--
{
    //вставляет новый узел в начало списка
    num.AddFirst(new LinkedListNode<int>(0));
    //вставляет новое число в начало списка
    num.AddFirst(-1);

    //вставляет новый узел в конец списка
    num.AddLast(new LinkedListNode<int>(99));
    //вставляет новое число в конец списка
    num.AddLast(100);

}
--
{
    //удаляет первый узел из списка. После этого новым первым узлом становится узел, следующий за удаленным
    num.RemoveFirst();

    //удаляет последний узел из списка
    num.RemoveLast();
}
--

==========================================

--Dictionary--Словарь--ключ-значение
------------------------------------------
словарь хранит обьекты, которые пердставляют паару ключ-значение. Каждый такой обьект яляется 
обекттом структкуры KeyValuePair<TKey, TValue>. из словааря можно получать ключ и значение

 Dictionary<int, string> countries = new Dictionary<int, string>();
            {
                //добавление в countries ключа и значения
                countries.Add(1, "Russia");
                countries.Add(2, "USA");//countries{{1,Russia},{2,USA}}
                countries.Add(3, "France");//countries{{1,Russia},{2,USA}}
                //получение элмента по ключу
                var countrie = countries[1];//Russia

после добавления элменатаа не получится изменить его клюлч тольлко его значение - 

                //изменение обекта по ключу
                countries[2] = "America";//countries{{1,Russia},{2,America},{3,France}}

                // удаление по ключу
                countries.Remove(2);//countries{{1,Russia}}
            }


            {
                //перебор ключей
                foreach (var countriesKey in countries.Keys)
                {
                    Console.WriteLine(countriesKey);//1,3
                }

                //перебор значений
                foreach (var countriesValue in countries.Values)
                {
                    Console.WriteLine(countriesValue);//Russia, France
                }
            }

после добавления элменатаа не получится изменить его клюлч тольлко его значение,
 но можно изменить изменить ключ пересоздав его и остаавив старое значение

int maxValue = 10;

//(берется словарь из нео реебтся ключ  он увлиечивается на еденицу, пересоздается запись с новым ключем и старым значеним)
var newCountries = 
    countries.ToDictionary(d =>  d.Key + 1, d => d.Value);//newCountries{ { 2,Russia},{ 4,France} }

//так же можно иссопльзовать различные операторы по типу тернарногно
var newCountries2 = countries.ToDictionary(d => d.Key > maxValue ? d.Key : d.Key + 1, d => d.Value);

еще один способ инициализации

Dictionary<string, string> countries3 = new Dictionary<string, string>
{
    ["Франция"] = "Париж",
    ["Германия"] = "Берлин",
    ["Великобритания"] = "Лондон"
};

==========================================


--Queue--
------------------------------------------
Представляет коллекцию объектов, основанную на принципе «первым поступил — первым обслужен».

Dequeue: извлекает и возвращает первый элемент очереди

Enqueue: добавляет элемент в конец очереди

Peek: просто возвращает первый элемент из начала очереди без его удаления

//Очереди и стеки полезны, если для хранения данных требуется временное хранилище.
//то есть, когда может потребоваться отменить элемент после получения его значения.
//Используйте, Queue Если необходимо получить доступ к данным в том же порядке,
//в котором они хранятся в коллекции. 
static void Main(string[] args)
{
    Queue my = new Queue();

    //Enqueue Д.x\обавляет элемент в конец Queue 
    my.Enqueue("Hello");
    my.Enqueue("World");
    my.Enqueue("!");

    //возвращает ковло элементов хранащихся в списке
    Console.WriteLine(my.Count);

    foreach (var VARIABLE in my)
    {
        Console.WriteLine($"count elem - {VARIABLE}");
    }

    //Peek Возвращает самый старый элемент, который находится в начале, Queue но не удаляет его из Queue .
    var getOldElem = my.Peek();

    Console.WriteLine($"get old elem {getOldElem}");
    

    //Dequeue удаляет самый старый элемент из начала Queue .
    my.Dequeue();
    my.Dequeue();

    foreach (var VARIABLE in my)
    {
       
        Console.Write(VARIABLE);
        
    }
   

}



==========================================


--ObservableCollection--
------------------------------------------
это тот же List только с возиможностью известить внешние обььекты о том что коллекция была изменена

https://metanit.com/sharp/tutorial/4.13.php

class ObservableCollections
{
    public ObservableCollection<ClassForList> users = new ObservableCollection<ClassForList>();
    public void ObservableCollectionys()
    {
        //додбавление как в стандартный список
        users.Add(new ClassForList("Lex", 43));
        users.Add(new ClassForList("Max", 12));
        //ObservableCollection  определяет событие CollectionChanged, подписавшись на которое,можно обрааботать любое  из изменений коллекции
        users.CollectionChanged += ActionCollectionChanged;
    }
    //добавление в массив элемента NotifyCollectionChangedAction.Add
    public void AddToOC(ClassForList cfl)
    {
        users.Add(cfl);
    }
    //вставляет элмент в список со смещением  NotifyCollectionChangedAction.Add)
    public void InsertToOC(int index,ClassForList cfl)
    {
        users.Insert(index,cfl);
    }
    //удаляет элмент по инндексу NotifyCollectionChangedAction.Remove
    public void RemoveToOC(int index)
    {
        users.RemoveAt(index);
    }
    //заменяет элемент по указаному индексу NotifyCollectionChangedAction.Replace
    public void ReplaceToOC(int index, ClassForList cfl)
    {
        users[index] = cfl;
    }

    //Перемещает элемент с указанным индексом в новое место в коллекции. NotifyCollectionChangedAction.Move
    public void MoveToOC(int oldIndex, int newIndex)
    {
        users.Move(oldIndex, newIndex);
    }
    //исополльзуется в wpf
    public void ResetToOC(int index, ClassForList cfl)
    {
     
    }
    

    void ActionCollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
     
        if (e.Action == NotifyCollectionChangedAction.Add)
        {
           
            Console.WriteLine("Add");
        }


        if (e.Action == NotifyCollectionChangedAction.Remove)
        {
            Console.WriteLine("Remove");
        }


        if (e.Action == NotifyCollectionChangedAction.Replace)
        {
            Console.WriteLine("Replace");
        }

        
        if (e.Action == NotifyCollectionChangedAction.Move)
        {
            Console.WriteLine("Move");
        }
        

        if (e.Action == NotifyCollectionChangedAction.Reset)
        {
            Console.WriteLine("Reset");
        }
    }
}

static void Main(string[] args)
{
    ObservableCollections oc = new ObservableCollections();
    oc.ObservableCollectionys();

 
    string? input = Console.ReadLine();

    if (input == "n")
    {
        oc.AddToOC(new ClassForList(Console.ReadLine(), Int32.Parse(Console.ReadLine())));
    }
    else if (input == "i")
    {
        oc.InsertToOC(Int32.Parse(Console.ReadLine()), new ClassForList("Freddy", 10));
    }
    else if(input == "d")
    {
       oc.RemoveToOC(Int32.Parse(Console.ReadLine()));
    }
    else if (input == "r")
    {
        oc.ReplaceToOC(Int32.Parse(Console.ReadLine()),new ClassForList("Gleb",54));
    }
    else if (input == "m")
    {
        oc.MoveToOC(Int32.Parse(Console.ReadLine()), Int32.Parse(Console.ReadLine()));
    }
    else if (input == "re")
    {
        oc.ResetToOC(Int32.Parse(Console.ReadLine()), new ClassForList("Gleb", 54));
    }
}


==========================================



--Linq--
------------------------------------------

LINQ (Language-Integrated Query) представляет простой и удобный язык запросов к источнику данных. В качестве источника данных может выступать объект,
 реализующий интерфейс IEnumerable (например, стандартные коллекции, массивы),LINQ (Language-Integrated Query) 
представляет простой и удобный язык запросов к источнику данных. В качестве источника данных может выступать объект, 
реализующий интерфейс IEnumerable (например, стандартные коллекции, массивы),

------------------------------------------
Where, StartsWith, OrderBy

//пример БЕЗ LINQ - поиск по списку слов начинающихся с буквы H
string[] teams = {"Бавария", "Боруссия", "Реал Мадрид", "Манчестер Сити", "ПСЖ", "Барселона"};
 
var selectedTeams = new List<string>();
foreach(string s in teams)
{
    if (s.ToUpper().StartsWith("Б"))
        selectedTeams.Add(s);
}
selectedTeams.Sort();
 
foreach (string s in selectedTeams)
    Console.WriteLine(s);


//пример использования тех же действий с исопльзованием LINQ - поиск по списку слов начинающихся с буквы H
string[] teams = { "Hjje","Hehe", "Gege", "AOAOO", "Zad", "Hren", "Hahe" };

            //запись аналогичная нижеследующей
            //Выражение from t in teams проходит по всем элементам массива teams и определяет каждый элемент как t.
            // Используя переменную t мы можем проводить над ней разные операции.
            var select = teams.Where(t => t.ToUpper().StartsWith("H")).OrderBy(t => t);

            //записаь аналогичнаа вышеследующей
            var selectedTeams = from t in teams // определяем каждый объект из teams как t
                where t.ToUpper().StartsWith("H") //фильтрация по критерию
                orderby t  // упорядочиваем по возрастанию
                select t; // выбираем объект

            foreach (var VARIABLE in select)
            {
                Console.WriteLine(VARIABLE);//Hahe
                                            //Hehe
                                            //Hjje
                                            //Hren
            }

            foreach (var VARIABLE in selectedTeams)
            {
                Console.WriteLine(VARIABLE);//Hahe
                                            //Hehe
                                            //Hjje
                                            //Hren
            }

Выражения LINQ являются строго типизированными. То есть среда автоматически распознает, что набор teams состоит из объектов string,
 поэтому переменная t будет рассматриваться в качестве строки.

Например, используем стандартный синтаксис linq и метод расширения Count(), возвращающий количество элементов в выборке:
 int number = (from t in teams where t.ToUpper().StartsWith("H") select t).Count();//number = 4

------------------------------------------
Select

 var equalsToFive = integers.Select(delegate(int ss)//эта записаь аналогична нижеследующей
            {
                if (ss ==5)
                {
                    return true;
                }

                return false;
            }).ToArray();

var NotEqualsToFive = integers.Select(element => element != 5).ToArray();//эта записаь аналогична вышеследующей

------------------------------------------
Where, OrderByDescending, Distinct

  int[] num = { 10, 4, 2, -4, 1, 27, 4, 5, 7, 8, 908, 53 };
            // Выберем все четные элементы (i % 2 == 0), которые меньше 10 (i < 10), отсоротируем их по убыванию (.OrderByDescending(i => i)),
            // и удалим все повторояющиеся значения(.Distinct();)
            var selectedItems = num.Where(i => i % 2 == 0 && i < 10).OrderByDescending(i => i).Distinct();

            foreach (var item in selectedItems)
            {
                Console.WriteLine(item);//8
                                        //4
                                        //2
                                        //- 4
            }


------------------------------------------
выбоьрка сложный обьектов (классс)

//заготовка клаааса выыборку экземплляров кторого мы будет делать
 class Person
        {
            public string Name { get; set; }
            public int Age { get; set; }
            public List<string> Languages { get; set; }
            public Person()
            {
                Languages = new List<string>();
            }
        }


   static void Main(string[] args)
        {
            //создаем список экзпря класса ктороые мы будем сравнивать  
            List<Person> users = new List<Person>
            {
                new() {Name="пиу", Age=23, Languages = new List<string> {"анг", "нем" }},
                new Person {Name="аоаао", Age=27, Languages = new List<string> {"анг", "фр" }},
                new Person {Name="кусь", Age=9, Languages = new List<string> {""}},
                new Person {Name="кешо", Age=40, Languages = new List<string> {}}
            };
            //сперва мы проверяем последоватлььност на пыстые языки и если они ест дбавлям их в выходную последовтаелнлость, после чего через конкат 
            //прибавляем новую последователноссть в кторой уже через Метод SelectMany() в качестве первого параметра принимает последовательность,
            //которую надо проецировать, а в качестве второго параметра - функцию преобразования, которая применяется к каждому элементу. 
            //На выходе она возвращает 8 пар "пользователь - язык" (new { User = u, Lang = l }), к которым потом применяетс фильтр с помощью Where.
              var sel = users.Where(p => p.Age < 28 && p.Languages.Count == 0 || p.Languages == null).
                Concat(users.SelectMany(p => p.Languages, (p, l) => new
                {
                    Pers = p,
                    Lang = l
                }).Where(p => p.Pers.Age < 28 && p.Lang == "анг" || string.IsNullOrEmpty(p.Lang)).Select(p => p.Pers));


            foreach (Person person in sel)
                Console.WriteLine($"{person.Name} - {person.Age}");//Frenk - 10
                                                                   //пиу - 23
                                                                   //аоаао - 27
                                                                   //кусь - 9
                                                                   //FFFF - 80

        }
------------------------------------------

Список используемых методов расширения LINQ
Select: определяет проекцию выбранных значений

Where: определяет фильтр выборки

Select: используется для создания выходной последовательности одного типа элементов из входной последовательности элементов другого типа. Эти типы не обязательно должны совпадать.

SelectMany: используется для создания выходной последовательности с проекцией "один ко многим" из входной последовательности.

OrderBy: упорядочивает элементы по возрастанию
--
OrderByDescending: упорядочивает элементы по убыванию

 foreach (var ind in index.OrderByDescending(e => e))//удаление несольких элементов из массива,
                //OrderByDescending Сортирует элементы последовательности в порядке убывания, потому 
            {
                Files.RemoveAt(ind);
            }
--
ThenBy: задает дополнительные критерии для упорядочивания элементов возрастанию

ThenByDescending: задает дополнительные критерии для упорядочивания элементов по убыванию

Join: соединяет две коллекции по определенному признаку

GroupBy: группирует элементы по ключу

ToLookup: группирует элементы по ключу, при этом все элементы добавляются в словарь

GroupJoin: выполняет одновременно соединение коллекций и группировку элементов по ключу

Reverse: располагает элементы в обратном порядке

All: определяет, все ли элементы коллекции удовлятворяют определенному условию

Any: определяет, удовлетворяет хотя бы один элемент коллекции определенному условию

Contains: определяет, содержит ли коллекция определенный элемент

Distinct: удаляет дублирующиеся элементы из коллекции

Except: возвращает разность двух коллекцию, то есть те элементы, которые создаются только в одной коллекции

Union: объединяет две однородные коллекции

Intersect: возвращает пересечение двух коллекций, то есть те элементы, которые встречаются в обоих коллекциях

Count: подсчитывает количество элементов коллекции, которые удовлетворяют определенному условию

Sum: подсчитывает сумму числовых значений в коллекции

Average: подсчитывает cреднее значение числовых значений в коллекции

Min: находит минимальное значение

Max: находит максимальное значение

Take: выбирает определенное количество элементов

Skip: пропускает определенное количество элементов

TakeWhile: возвращает цепочку элементов последовательности, до тех пор, пока условие истинно

SkipWhile: пропускает элементы в последовательности, пока они удовлетворяют заданному условию, и затем возвращает оставшиеся элементы

Concat: объединяет две коллекции

Zip: объединяет две коллекции в соответствии с определенным условием

First: выбирает первый элемент коллекции

FirstOrDefault: выбирает первый элемент коллекции или возвращает значение по умолчанию

Single: выбирает единственный элемент коллекции, если коллекция содердит больше или меньше одного элемента, то генерируется исключение

SingleOrDefault: выбирает первый элемент коллекции или возвращает значение по умолчанию

ElementAt: выбирает элемент последовательности по определенному индексу

ElementAtOrDefault: выбирает элемент коллекции по определенному индексу или возвращает значение по умолчанию, если индекс вне допустимого диапазона

Last: выбирает последний элемент коллекции

LastOrDefault: выбирает последний элемент коллекции или возвращает значение по умолчанию




==========================================




--Частичные классы partial--
------------------------------------------


 public partial class Person//частичный класс
{
    public void Move()
    {
        Console.WriteLine("I am moving");
    }
    partial void DoSomethingElse();//частичный метод
}
А в другом файле определим следующий класс
а так же частичные классы могут содержать частичные методы

public partial class Person//частичный класс
{
    public void Eat()
    {
        Console.WriteLine("I am eating");
    }
     partial void DoSomethingElse()//частичный метод
    {
        Console.WriteLine("I am reading a book");
    }
}

 static void Main(string[] args)
    {
        Person tom = new Person();
        tom.Move();//I am moving
        tom.Eat();//I am eating
 
        Console.ReadKey();
    }
Таким образом, два файла в проекте содержит определение одного и того же класса Person, 
которые содержат два разных метода. И оба определенных здесь класса являются частичными. 
Для этого они определяются с ключевым словом partial.
==========================================

--События (EventHandler...)--
------------------------------------------
Свойства добавления / удаления в основном соответствуют той же логике использования свойств set / get с другими членами. 
Он позволяет вам создать дополнительную логику при регистрации на событие и инкапсулировать само событие.
Хороший пример того, ПОЧЕМУ вы хотите это сделать, - остановить дополнительные вычисления, когда они не нужны (никто не слушает событие).

Например, предположим, что события запускаются таймером, и мы не хотим, чтобы таймер работал, если на событие никто не зарегистрирован:

private System.Windows.Forms.Timer timer = new System.Windows.Forms.Timer();
private EventHandler _explicitEvent;
public event EventHandler ExplicitEvent 
{
   add 
   { 
       if (_explicitEvent == null) timer.Start();//задаем условие при подписке на событие
       _explicitEvent += value; 
   } 
   remove 
   { 
      _explicitEvent -= value; //задаем условие при отписке от события
      if (_explicitEvent == null) timer.Stop();//при отписке балгодаря -= value - в событии всегд будет null, потому мы отключаем таймер
   }
}
Вы, вероятно, захотите заблокировать добавление / удаление с помощью объекта (запоздалая мысль) ...


==========================================




<--WPF-->
------------------------------------------
--xalm

язык для описания дизайна фпа приложения

--события WPF
------------------------------------------
WPF в отличие от других технологий, например, от Windows Forms, предлагает новую концепцию событий - маршрутизированные события (routed events).

Для элементов управления в WPF определено большое количество событий, которые условно можно разделить на несколько групп:

События клавиатуры

События мыши

События стилуса

События сенсорного экрана/мультитач

События жизненного цикла

Подключить обработчики событий можно декларативно в файле xaml-кода,:
<Button x:Name="Button1" Content="Click" Click="Button_Click" />

а можно и в самом коде используя например такой вот перебор всех кнопок в сетке MainRoot

 public MainWindow()
        {
            InitializeComponent();
            foreach (UIElement elem in MainRoot.Children)//через UIElement мы перебираем все обьекты
                //которые находятся в нашей сетке MainRoot.Children обьекты оотносящиеся
                //к нашему Grid x:Name="MainRoot"
            {
                if (elem is Button)//теперь нужно прверить относится ли дочерний обьект к классу Button
                {
                    ((Button) elem).Click += Button_Click;//тк Button это производный класс от класса 
                    //UIElement необходимо произвести явное приведение (downcast), да
                }
            }
          
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show("Hi from Button_Click");
        }

Все маршрутизируемые события используют класс RoutedEventArgs (или его наследников), который представляет доступ к следующим свойствам:
Source: элемент логического дерева, являющийся источником события.
OriginalSource: элемент визуального дерева, являющийся источником события. Обычно то же самое, что и Source
RoutedEvent: представляет имя события
Handled: если это свойство установлено в True, событие не будет подниматься и опускаться, а ограничится непосредственным источником.

опции окон wpf
------------------------------------------

   AddNewBDWindow newBdWindow = new AddNewBDWindow();//вызываем экземпляр окна с которым буде работать
            newBdWindow.Owner = Application.Current.MainWindow;//определяем его как главное окно приложения
            newBdWindow.WindowStartupLocation = WindowStartupLocation.CenterOwner;//выводим окно по центру экрана
            newBdWindow.ShowDialog();//пока окно открыто мыы не можем перейти на коно его вызвавшее


------------------------------------------
пример работы с xaml
Grid

Это наиболее мощный и часто используемый контейнер, напоминающий обычную таблицу. 
Он содержит столбцы и строки, количество которых задает разработчик. 
Для определения строк используется свойство RowDefinitions, а для определения столбцов -
свойство ColumnDefinitions

    <Grid x:Name="MainRoot" Background="White">
        <!--grid здесь это основноая сетка, x:Name="" тут мы указываем название 
        через которое сможем в дальейшем обращатся к этому элеменрту и вытащит 
        из него все конпки и тд, Background отвечает за цвет фона-->
        <Grid.RowDefinitions>

            <!--создаем конструктор рядов -->
            <RowDefinition />
            <!--создаем 5 рядов -->
            <RowDefinition />
            <RowDefinition />
            <RowDefinition />
            <RowDefinition />
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <!--создаем конструктор столбцов -->
            <ColumnDefinition/>
            <!--создаем 4 стлбцов -->
            <ColumnDefinition/>
            <ColumnDefinition/>
            <ColumnDefinition/>

        </Grid.ColumnDefinitions>
        <TextBlock Grid.Row="0" Grid.Column="0" Text="" Grid.ColumnSpan="4" x:Name="textLabel" FontSize="48" FontFamily="Arial" Background="#FF999999" TextAlignment="Left" FontStretch="Normal" FontStyle="Normal" FontWeight="Normal" TextWrapping="NoWrap"/>
        <!--создаем тектовое поле в полях Grid.Row="0"(row это строка в таблице) Grid.Column="0" те в  адрес в ряде и в столбце соответсвенно 
        те верхний правый, Grid.ColumnSpan="4 обьединяем 4 столбца(Grid.RowSpan="4" так бы мы обьеденили 4 ряда)-->
        <Button x:Name="button1" Grid.Column="0" Grid.Row="1" Background="#FF191B17" Foreground="White" FontSize="16" FontFamily="Arial" >1</Button>
        <!--Background="#FF191B17" цвет кнопки, Foreground цвет текста, 1 это текст кнопки который будет отображатсня на ней, Grid.Column="0" Grid.Row="1" как уже показано 
        -->
        <Button x:Name="button2" Grid.Column="1" Grid.Row="1" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">2</Button>
        <Button x:Name="button3" Grid.Column="2" Grid.Row="1" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">3</Button>
        <Button x:Name="button4" Grid.Column="0" Grid.Row="2" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">4</Button>
        <Button x:Name="button5" Grid.Column="1" Grid.Row="2" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">5</Button>
        <Button x:Name="button6" Grid.Column="2" Grid.Row="2" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">6</Button>
        <Button x:Name="button7" Grid.Column="0" Grid.Row="3" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">7</Button>
        <Button x:Name="button8" Grid.Column="1" Grid.Row="3" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">8</Button>
        <Button x:Name="button9" Grid.Column="2" Grid.Row="3" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">9</Button>
        <Button x:Name="button0" Grid.Column="0" Grid.Row="4" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">0</Button>

        <Button x:Name="buttonAdd" Grid.Column="4" Grid.Row="1" Background="#FF464646" FontSize="16" FontFamily="Arial" Foreground="White">+</Button>
        <Button x:Name="buttonSubtraction" Grid.Column="4" Grid.Row="2" Background="#FF464646" FontSize="16" FontFamily="Arial" Foreground="White">-</Button>
        <Button x:Name="buttonMultiply" Grid.Column="4" Grid.Row="3" Background="#FF464646" FontSize="16" FontFamily="Arial" Foreground="White">*</Button>
        <Button x:Name="buttonDivide" Grid.Column="4" Grid.Row="4" Background="#FF464646" FontSize="16" FontFamily="Arial" Foreground="White">/</Button>
        <Button x:Name="buttonEqually" Grid.Column="1" Grid.Row="4" Background="#FF464646" FontSize="16" FontFamily="Arial" Foreground="White" >=</Button>
        <Button x:Name="buttonAC" Grid.Column="2" Grid.Row="4" Background="#FF464646" FontSize="16" FontFamily="Arial" Foreground="White">AC</Button>
    </Grid>
</Window>


auto - столбец станет настолько широким, насколько это необходимо для размещения его дочерних элементов

* (звездочка) занять все доступное оставшееся место

 <Grid.RowDefinitions>
            <RowDefinition Height="*"/>//занять все доступное место
            <RowDefinition Height="auto"/>//атоматический режим
 </Grid.RowDefinitions>


TextWrapping ="Wrap" - текст будет перескаиват но новую строчку при азполнение первой

------------------------------------------
в отличии от win form здесь мы использумем вот такой способ добычи элесентов из формы или сетки
 public MainWindow()
        {
            InitializeComponent();
            foreach (UIElement elem in MainRoot.Children) //через UIElement мы перебираем все обьекты
                //которые находятся в нашей сетке MainRoot.Children обьекты оотносящиеся
                //к нашему Grid x:Name="MainRoot"
            {
                if (elem is Button btn) //теперь нужно прверить относится ли дочерний обьект к классу Button
                {
                    btn.Click += Button_Click; //тк Button это производный класс от класса 
                    //UIElement необходимо произвести явное приведение (downcast), далее добалвем обрабочтик события к этому элементу
                }
            }

        }

        private void Button_Click(object sender, RoutedEventArgs e) //Все маршрутизируемые события используют класс
            //RoutedEventArgs (или его наследников), который представляет доступ к следующим свойствам:

            //Source: элемент логического дерева, являющийся источником события.

            //OriginalSource: элемент визуального дерева, являющийся источником события. Обычно то же самое, что и Source
            //OriginalSource У элемента управления могут быть другие элементы управления в качестве дочерних элементов. 
            //Когда вы подписываетесь на событие от элемента управления, родительский элемент, на который вы подписались,
            //скорее всего, будет тем, что, e.Source однако, если у элемента управления есть дочерние элементы,
            //а дочерний элемент - тот, который вызвал событие, то это OriginalSourceбудет дочерний элемент,
            //который вызвал событие.

            //RoutedEvent: представляет имя события

            //Handled: если это свойство установлено в True, событие не будет подниматься и опускаться, а ограничится непосредственным источником.
        {

получение данных из элементов реализовано так
            string str =
                ((Button) e.OriginalSource).Content.ToString(); // преборазовываем инвент к классу кнопки, и получаем
            //значение контента из кнопки <Button>1</Button> - 1 это и естть контент этой кнопки, и преобразуем его в строку

            if (temp == "=")
            {
                ss = true;
            }

            if (ss)
            {
                if (temp != "+" || temp != "-" || temp != "/" || temp != "*" || temp != "=")
                {
                    textLabel.Text = String.Empty;
                    temp = "";
                }
            }

            if (str == "AC")
            {
                textLabel.Text = String.Empty;
            }
            else if (str == "=")
            {
здесь используется сложение чисел строки
                string value = new DataTable().Compute(textLabel.Text, null)
                    .ToString(); //Compute повзволят нам выситвать значение праметра в качетве входного 
                //значения можно испольовать строку
                if (!string.IsNullOrWhiteSpace(value))
                {
                    textLabel.Text = value;
                }


            }

            else
            {
                textLabel.Text += str;
                temp = str;
            }


        }

        string temp;
        private bool ss = false;
    }
}

------------------------------------------
подключение внешник библилоттек порядок деействий:
solutioon manager=> Project right click => mannagger NuGet=> выбратть интересующую библиотеку=> 
а App.xalm нужно добавить чотто подобное 

<Application.Resources>
<ResourceDictionary>
            <ResourceDictionary.MergedDictionaries><!--при подключении библиотек через нуге нужно зайти на сайт производителя и добавитт оттуда код ресурсов вот сюда-->
                <ResourceDictionary Source="pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Light.xaml" />
                <ResourceDictionary Source="pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Defaults.xaml" />
                <ResourceDictionary Source="pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Primary/MaterialDesignColor.DeepPurple.xaml" />
                <ResourceDictionary Source="pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Accent/MaterialDesignColor.Lime.xaml" />
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>

    => в xalm файл разрабатываемого окна так же необходимо добавит ссылку не ресурсы xmlns:materialDesign="http://materialdesigninxaml.net/winfx/xaml/themes"

------------------------------------------ 
создание 
 <Grid x:Name="MainRoot" Background="#ffdadada">
        <Border MinWidth="40" MaxWidth="550" Background="White" Margin="15"  VerticalAlignment="Center" Padding="30"  CornerRadius="20">
        <!--создаем пллашку бордер, MinWidth и MaxWidth - минималльная и максималная ширина плашки (благодаря этому ширна будем менятся в зависомостти отт ширины окна),
        Margin растояние между элементом и его сосденими элменетами(внешние отсутпы),Padding внутринние отступы()VerticalAlignment расположение плашки
        по вертикали - в даном случае в центре,Padding устанавливает внутрение отступы - от внутреннего содержимого элемента до его границ,  -->
        <Border.Effect><!--тут можно создавать эффекты для нашего бордера-->
                <DropShadowEffect BlurRadius="30" Color="LightGray" ShadowDepth="1"/><!--создаем тень BlurRadius размер рассеивания теени,Color цвет тени 
            ,ShadowDepth то насолькьок далеко тенб будет отставатьт от обьека кторый ее оттбрасывает-->
        </Border.Effect>
        <StackPanel>
            <TextBlock Text="Hello Us" FontSize="30" FontWeight="Bold" Margin="0 0 0 20"></TextBlock>
            <Grid Margin=" 0 0 0 0">
                    <Button HorizontalAlignment ="Left" Content="Registration"/>
                    <!--HorizontalAlignment означает располложение кнопки чтобы она прилегала к левой стороне Grid,-->
                    <!-- эта записьь аналогична верхней (запись в Conttent аналогичен записи внутри тела обьектта)
                    <Button HorizontalAlignment ="Left">Registration</Button>-->

                    <Button HorizontalAlignment="Right" Content="Sign in" Style="{StaticResource MaterialDesignFlatButton}"/>
                    <!--Style позволяет подключить внешшние стили, через StaticResource MaterialDesignFlatButton-->
                </Grid>
                <TextBox materialDesign:HintAssist.Hint="Enter login" Style="{StaticResource MaterialDesignFloatingHintTextBox}"/><!--создание текстбокса с внешним материаал стилем-->
                <PasswordBox materialDesign:HintAssist.Hint="Enter password" Style="{StaticResource MaterialDesignFloatingHintPasswordBox}"/>
                <PasswordBox materialDesign:HintAssist.Hint="Repeat password" Style="{StaticResource MaterialDesignFloatingHintPasswordBox}"/><!--создание специплного текстбокса 
            для паролейт с внешним материаал стилем-->
                <TextBox materialDesign:HintAssist.Hint="Email" Style="{StaticResource MaterialDesignFloatingHintTextBox}"/><!--создание текстбокса с внешним материаал стилем-->
</StackPanel>
        </Border>
        
    </Grid>

==========================================


--MVC--
------------------------------------------
model - содержит или предтавлляет данные с которыми работают полльзователи, а так же логику которая связаня с данными, например логику 
валидаации данных, как правило обьект модели извлекают и сохраняют состояние модели в базе данных и переддает ихв в view или обновляет

view - компоненты которые формируют пользовательский интерфейс приложения. как правило, в пользовательском интерфейфсе(view) 
отображаются данные model, валидация входных данных

controller - кллассы ктороые обраюатывают запросы из моделли, получают данные модели, вызыают шаблоны преддставления вызово которе 
возвращают ответ в view

mvc позволяет разделить логику от представлления данных. 
==========================================

--команда--паттерн команда--
------------------------------------------
команда поведнческий паттерн, для гибкого механизма действий над чем ибо или команд. в этом механизме 
класс отправитьель команды и класс получаетль не зависят друг от друга

компоенты команды

command
базовый класс. объявляет интерфейс для выполнения операции(command)

concretteComand 
опредедляет связь междду обьектом получателем(Resiever) и действием.
реализует интерфейс, обявленный command

client
создает объект concretteCommand и задает для него поллучателя

invoker
обращаается к команде(command) для выполнения операции

reciever
распологает информацией о способах выполнения команды. в его 
роли может выступть любой класс


------------------------------------------
где используется паттерн команда

GUI кнопки и пункты меню
запись макросов
многоуровневая отмена операций
сети
индикааторы выполнения
пулы потоков
транзакции
мастера(устанговщики программ, мастера настроек)

пример реализаации c#


рассмотрим програамму для управления самолетом

class PowerSupply//reсiever распологает инфой о способах выполнения команды(command)
{
   public string Status { get; set; }//сюда будет положена командда (OutputOn или OutputOff)
}


тк у обеих команд общим является не только интерфейс но и там же reсiever (PowerSupply) и 
механизм инициализации, вместо интерфейса можно использовать простой абстрактный класс

abstract class Command//базовый класс, объявляет интерфейс или абстрактный класс для выполнения операции(comand)
{
    protected PowerSupply mySupply;
    public abstract void Execute();//выполнить команду
    public abstract void Undo();//отменить команду

    public Command(PowerSupply supply)
    {
        mySupply = supply;
    }
}

В обеих командах реализована одноуровневая отмена действия.

class OutputOn : Command//concretteComand опредедляет связь междду обьектом получателем(Resiever) и действием.
//реализует интерфейс, обявленный command
{
    public OutputOn(PowerSupply supply) : base(supply)
    {
    }
    public override void Execute()
    {
        mySupply.Status = "OutputOn";
    }
    public override void Undo()
    {
        mySupply.Status = "OutputOff";
    }
}

class OutputOff : Command//concretteComand опредедляет связь междду обьектом получателем(Resiever) и действием.
                             //реализует интерфейс, обявленный command
{
    public OutputOff(PowerSupply supply) : base(supply)
    {
    }
    public override void Execute()
    {
        mySupply.Status = "OutputOff";
    }
    public override void Undo()
    {
        mySupply.Status = "OutputOn";
    }
}

class Invoker
{
    private Command myCommand;//Сама команда задаётся через свойство типа Command, которое связано с закрытым полем myCommand.

    public Command Command
    {
        set
        {
            myCommand = value;
        }
    }

    public void Run()
    {
        myCommand.Execute();
    }

    public void Undo()
    {
        myCommand.Undo();
    }
}

class Programm
{
    static void Main(string[] args)
    {
        PowerSupply supply = new PowerSupply();
        Invoker supplyControl = new Invoker();
        int i = 0;
        while (i != 52)
        {
            i = SupplyControl(supply, supplyControl);
            Console.ReadLine();
        }
        
           
        
    }

    static int SupplyControl(PowerSupply supply, Invoker resiever)
    {
        Console.WriteLine("What to do power supply");

        int action = Console.Read();

        switch (action)
        {
            case 49:
                {
                    resiever.Command = new OutputOff(supply);
                    resiever.Run();
                }
                break;
            case 50:
                {
                    resiever.Command = new OutputOn(supply);
                    resiever.Run();
                }
                break;
            case 51:
                resiever.Undo();
                break;
        }

        Console.WriteLine(supply.Status);
        return action;
    }
}

==========================================


--MVVM--
------------------------------------------
Рассмотрение паттерна на примере №1: Сложение двух чисел с выводом результата

Методика написания программы используя подход «ModelFirst».

1. Разработать модель программы.
2. Нарисовать интерфейс программы.
3. Соединить интерфейс и модель прослойкой VM.

------------------------------------------
Модель

public class MathFuncs
    {
        public static int GetSum(int a, int b) => a + b;//создаем модель она состоит из сложения чисел
    }

------------------------------------------
интерфейс (View) будет написана на XAML


 Текстовые поля будут соединены с VM через механизм Binding. 
Cвязь всей View и VM осуществляется, когда мы создаем объект VM и присваиванием его свойству DataContext View.
...
 <Grid>
 //Binding соединяет текстовое поле со свойством VM, изменения от цели к источнику управляется свойством 
 //Binding.UpdateSourceTrigger(передача значения в VM в момент ввода), PropertyChanged - источник обновляется немедленно, 
 //когда изменяется целевое свойство
       <TextBox HorizontalAlignment="Left" Margin="75,84,0,0" Text="{Binding Num1, UpdateSourceTrigger= PropertyChanged}" TextWrapping="Wrap" VerticalAlignment="Top" Width="120"/>
        <TextBox HorizontalAlignment="Left" Margin="75,129,0,0" Text="{Binding Num2, UpdateSourceTrigger= PropertyChanged}" TextWrapping="Wrap" VerticalAlignment="Top" Width="120"/>
        //Mode=OneWay необходим для призязки свойства только для чтения
        <TextBox HorizontalAlignment="Left" Margin="75,174,0,0" Text="{Binding Num3, Mode=OneWay}" TextWrapping="Wrap" VerticalAlignment="Top" Width="120" IsReadOnly="True"/>

    </Grid>
...
OneWay Обновляет свойство целевого объекта привязки (цели) в случае изменения исходного объекта привязки (источника).
 Этот тип привязки подходит, если привязываемый элемент управления неявно доступен только для чтения. 

------------------------------------------
теперь реализуме VM, чтобы она автобматом обновлял наше View, нужно релищовать интерфейс INotifyPropertyChange, 
именно так Viev и полуает уведомление что в Vm чтот изменилось и треубется обновитиь данные


public class MainVM : INotifyPropertyChanged //Чтобы наша VM «автоматически» обновляла View,
                                                 //требуется реализовать интерфейс INotifyPropertyChange.
    {
        public event PropertyChangedEventHandler PropertyChanged;

        [NotifyPropertyChangedInvocator]
        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        private int num1;

        public int Num1
        {
            get { return num1; }
            set
            {
                num1 = value;
                //Затем для каждого свойства, которому потребуются уведомления об изменениях, вы вызываете OnPropertyChanged при
                //каждом обновлении свойства.
                OnPropertyChanged("Num3");//изменяем Textbox привязаный к Num 3 немедленно как только изменили значение в Num1
            }
        }

        private int num2;

        public int Num2
        {
            get { return num2; }
            set
            {
                num2 = value;
                OnPropertyChanged("Num3");
            }
        }

        public int Num3
        {
            get
            {
                return MathFuncs.GetSum(Num1, Num2);
            }
        }

    }
}

при измении в оддном из свойств призяхзаных к текстбоксску(1 и 2) то эта строка кода  OnPropertyChanged("Num3");
через событие PropertyChanged извещает систему об изменении свойства. А система обновляет все привязанные объекты 
в данном случае текбокс 3 который привязан к Num3

------------------------------------------



------------------------------------------

подключаем к проекту фраймворк Prism 

создкем прослойку между view и model

VM

using System.Collections.ObjectModel;
using Prism.Commands;
using Prism.Mvvm;
using WpfApp1.Model;

namespace WpfApp1.ViewModel
{
    public class MainVM : BindableBase
    {
        public MyMathModel model = new MyMathModel();
        
        public MainVM()
        {
            //таким нехитрым способом мы пробрасываем изменившиеся свойства модели во View
            model.PropertyChanged += (s, e) => { RaisePropertyChanged(e.PropertyName); };
            AddCommand = new DelegateCommand<string>(str => {
                //проверка на валидность ввода - обязанность VM
                int ival;
                if (int.TryParse(str, out ival)) model.AddValue(ival);
            });
            RemoveCommand = new DelegateCommand<int?>(i => {
                if (i.HasValue) model.RemoveValue(i.Value);
            });
            //привязка кнопки к команде(управляем делегатом через кнопку)
            HaveSignal = new DelegateCommand<bool?>(b =>
            {
                {
                    model.signal = !model.signal;//изменяем состояние булвева значения при нажатии кнопки
                    RaisePropertyChanged(nameof(s));//ищет толко в этом классе (вызывает событие изменения свойства с указанным именем свойства)
                    //Когда объект класса изменяет значение свойства, то он через событие PropertyChanged извещает систему об изменении свойства
                }
            });
        }
        public DelegateCommand<string> AddCommand { get; }

        public DelegateCommand<int?> RemoveCommand { get; }

        public DelegateCommand<bool?> HaveSignal { get; }//обявляем делегат привязки
        public int Sum => model.Sum;
        public bool s//булево значение кторое пойдет в результат операции на которое срагирует xalm система
        {
            get { return model.signal; }
        }

        public ReadOnlyObservableCollection<int> MyValues => model.MyPublicValues;

       
    }
}


создаем модель в которой будет просиходит вся бизнес логика

M

using System.Collections.ObjectModel;
using System.Linq;
using Prism.Mvvm;

namespace WpfApp1.Model
{
    public class MyMathModel : BindableBase
    {
        private readonly ObservableCollection<int> _myValues = new ObservableCollection<int>();//Но нередко в качестве источника применяется
        //класс ObservableCollection, который находится в пространстве имен System.Collections.ObjectModel. Его преимущество заключается в
        //том, что при любом изменении ObservableCollection может уведомлять элементы, которые применяют привязку, в результате чего
        //обновляется не только сам объект ObservableCollection, но и привязанные к нему элементы интерфейса.
        public readonly ReadOnlyObservableCollection<int> MyPublicValues;
        
        public bool signal { get; set; } = false; //это булое значеине которым мы управляем с помощью делегата HaveSignal и с
                                                  //которого мы ситываем значчение чтобы потом отправит его в биндинг кнопки посредством
                                                  //RaisePropertyChanged

        public MyMathModel()
        {
            MyPublicValues = new ReadOnlyObservableCollection<int>(_myValues);
        }
        //добавление в коллекцию числа и уведомление об изменении суммы
        public void AddValue(int value)
        {
            _myValues.Add(value);
            RaisePropertyChanged(nameof(Sum));
        }
        //проверка на валидность, удаление из коллекции и уведомление об изменении суммы
        public void RemoveValue(int index)
        {
            //проверка на валидность удаления из коллекции - обязанность модели
            if (index >= 0 && index < _myValues.Count) _myValues.RemoveAt(index);
            RaisePropertyChanged(nameof(Sum));
        }

       
        public int Sum => MyPublicValues.Sum(); //сумма
    }
}

дополняем view кнопками с биндингами и условиями для изменения визуала(в часности цвета)
V

<Window...
 <Window.DataContext>
        <viewModel:MainVM/>
        <!-- Устанавливаем DataContext -->
    </Window.DataContext>
    <DockPanel>
        <!-- Число для добавления в коллекцию -->
        <StackPanel DockPanel.Dock="Top" Orientation="Horizontal">
            <TextBox x:Name="TheNumber" Width="50" Margin="5"/>
            <Button Content="Add" Margin="5" Command="{Binding AddCommand}"
                    CommandParameter="{Binding ElementName=TheNumber, Path=Text}"/>
            <!--упра -->
            <Button Content="Color" Margin="5" Command="{Binding HaveSignal}" 
                    CommandParameter="{Binding s}"/>
            <!--CommandParameter им мы управалем через триггер, прарметр метода -->

            <StackPanel.Style>
                <Style TargetType="StackPanel">
                    <Setter Property="Background" Value="Green"/>
                    <Style.Triggers>
                        <DataTrigger Binding="{Binding s}">
                            <!--изменяем состояние через триггер HaveSignal-->
                            <DataTrigger.Value>
                                <system:Boolean>False</system:Boolean>
                            </DataTrigger.Value>
                            <DataTrigger.Setters>
                                <Setter Property="Background" Value="Red"/>
                            </DataTrigger.Setters>
                        </DataTrigger>
                    </Style.Triggers>
                </Style>
            </StackPanel.Style>
        </StackPanel>
        <!-- Сумма -->
        <TextBox DockPanel.Dock="Bottom" IsReadOnly ="True" Text="{Binding Sum, Mode=OneWay}" Margin="5"/>
        <!-- Кнопка удаления из коллекции -->
        <Button DockPanel.Dock="Right" VerticalAlignment="Top" Content="Remove"
                Width="130" Margin="5"
                Command="{Binding RemoveCommand}"
                CommandParameter="{Binding ElementName=TheListBox, Path=SelectedIndex}" ToolTip="Remove Select"/>
        <!-- Коллекция -->
        <ListBox  x:Name="TheListBox" ItemsSource="{Binding MyValues}"/>
    </DockPanel>
</Window>


==========================================

--Json.Serializer--serializer-deserializer--сериализация--
------------------------------------------

//создаем иерархию классов ктороые бду сериализованы
public class DeepZuzlik
{
    public decimal Price { get; set; }
}
public class Zuzl
{
    public DeepZuzlik deep = new DeepZuzlik(){Price = 100};
    public string Name;
}

public class Product
{
    public Zuzl Zuzl = new Zuzl(){Name = "Zuzlik"}; 
    public string Name;
    public DateTime ExpiryDate { get; set; }
    public decimal Price { get; set; }
    public string[] Sizes { get; set; }
    
}

using Newtonsoft.Json;

//проверяем существует ли файл Product.json если нет создаем его, если да дерериазиум файл и получаем все данные обратно
//в виде <T>
var product2  = 
File.Exists("Product.json")? JsonConvert.DeserializeObject<Product>(File.ReadAllText("Product.json")): new Product
{
    Name = "Apple",
    ExpiryDate = new DateTime(2008, 12, 28),
    Price = 3.99M,
    Sizes = new string[] {"Small", "Medium", "Large"}
};


//создаем файл продукт и после преобразования Product и всех влоджненных в него элментов
//через json всталяем в этот файл.
File.WriteAllText("Product.json", JsonConvert.SerializeObject(product2));



==========================================

--sql--базы данных--Entity Framework
------------------------------------------
бд это
- база данных место для хранения данных. используется в клинет сверверной архитеуктре.
бд это хранилище куда приложение скалдывает свои данные. если приложение небольшое, отдельная бд ненужна,
но елси большое то это удобнее и выгоднее с точки зрения памяти.

------------------------------------------
реляционная бд 
- набор таблиц хранящихся в одном пространстве, например как xls файллы в одной папке.
например если данные хранятс я json это не реляционная бд.

------------------------------------------
как получить данные из бд
запросы к базе данных производятся на языке sql Structured Query Language язык общения с бд

select - выбор колонки
from - выбор таблицы
where - выбор конкретной информации

например я хочу получить информацию о клиенте Азазин Зузликович. Составляю ТЗ

Дай мне информацию по клиенту, у которого ФИО = «Азазин Зузликович»

//select выбери мне все колонки(можно конкретные можно сразу все), 
//from clients - из таблицы clients, where name = '...' где поле имеет значение '...'
select * from clients where name = 'Азазин Зузликович';

//-- здесь пишется комментарий
///* здесь пишется комментарий */
select -- выбери мне
* -- все колонки (можно выбирать конкретные, а можно сразу все)
from clients -- из таблицы clients
where name = 'Азазин Зузликович'; -- где поле name имеет значение 'Азазин Зузликович'
--
вышенаписаное аналогично этому

Открыть файл формата Excel (xlsx) с нужными данными (clients)
Поставить фильтр на колонку «ФИО» — «Назина Ольга».

--
А в базе данных вы внутри запроса SQL указываете, какие колонки из каких таблиц вам нужны. 
И результат запроса их отрисовывает. 
Скажем, мы хотим увидеть заказ, который сделал клиент, ФИО клиента, и его номер телефона.
 И всё это в разных таблицах! А мы написали запрос и увидели то, что нам надо
select * from Pupils where name = 'Лена'

id name   class
 7  Лена    3

--
можно исопльлзовать знаки > или < тогда выведет все имена по аллфавиту до лены

select * from Pupils where name > 'Лена'

id name   class
2   Ваня    2
3   Глеб    1
5   Витя    5
6   Костя   6
8   Ваня    5
...

--
аналогично верхней записи толлько выведет всего два первых по алфавиту имени 

select * from Pupils where name < 'Лена' LIMIT 2

id name   class
2   Ваня    2
3   Глеб    1
------------------------------------------
получение из таблицы униклаьных имен 

select DISTINCT name FROM Pupils

Макс
Ваня
Глеб
Саша

--
получение из таблилцы всех значени отортированых по имени в обратном порядке те от 'я' до 'а'

SELECT DISTINCT name FROM Pupils ORDER BY name DESC 


------------------------------------------
поллучение из таблицы по id 

select * from Pupils where id = 3

можно исопльлзовать знаки > или <
------------------------------------------
получение таблицы с опредделенными названиями

SELECT id AS 'инденификатор', name as 'имя' FROM Teacher

индентификатор имя

1   София
2   Сергей
3   Елена
...
------------------------------------------
получние сортивроки по определенному полю
сортировка по имени

SELECT  * FROM Pupils ORDER BY  name

2   Ваня    2
8   Ваня    5
5   Витя    5
...

--
аналогично тоьлко сверху вниз
SELECT  * FROM Pupils ORDER BY  name DESC

1   София
2   Сергей
3   Елена
------------------------------------------
добввалвение поля в сущевтующую таблицу

ALTER TABLE Teacher ADD age INT

1   София  nul 
2   Сергей  
3   Елена   

------------------------------------------
включение шаблонов в поиск ЧУВСТВИТЕЛЬНО К РЕГИСТРУ, здесь будут выбраны все имен уителей зканаивающеся на "на"

SELECT * FROM Teacher WHERE name like "%на";

3   Елена   40
5   Екатерина   65
7   Елена   35
--
SELECT * FROM Teacher WHERE name like "В%р";

4   Виктор  55
--
SELECT * FROM Teacher WHERE name like "Е%";

3   Елена   40
5   Екатерина   65
7   Елена   35
------------------------------------------
логические операторы 

--И 
поллучаем резуьлтат равный и левому условию и правому
SELECT * FROM Teacher WHERE name like "Е%" AND id > 3;

5   Екатерина   65
7   Елена   35

--ИЛИ
получаем результат равный и левому условию и правому
SELECT * FROM Teacher WHERE name like "Е%" OR id > 3;

--НЕТ
SELECT * FROM Teacher WHERE NOT id = 3;

1   София   20
2   Сергей  25
4   Виктор  55
...

--
SELECT * FROM Teacher WHERE NOT id = 3 AND NOT id = 4 AND NOT id = 6;

1   София   20
2   Сергей  25
5   Екатерина   65
7   Елена   35

--МЕЖДУ
SELECT * FROM Teacher WHERE age BETWEEN 20 AND 30;

1   София   20
2   Сергей  25
6   Сергей  30

------------------------------------------
изменение записей в таблице 

UPDATE Teacher SET age = 20 WHERE id = 1;

1   София   20
2   Сергей  
3   Елена   

--
если не указывать where изменены бдут все хзааписи в таблице

UPDATE Teacher SET age = 20

1   София   20
2   Сергей  20
3   Елена   20

------------------------------------------
удаление записей из таблицы

DELETE FROM Teacher where id = 2

1   София   20
3   Елена   40
4   Виктор  55
5   Екатерина   65
...

------------------------------------------
добавить в таблицу 

INSERT INTO Subject (name, Teacher_id) VALUES ("Maтематика",4),("ОБЖ",1),("Естествознание", 1); 

...
9   Биология    3
13  Maтематика  4
14  ОБЖ 1
15  Естествознание  1

------------------------------------------
обедеиниене таблиц 

--INNER Join внутреене обединение , в исходную таблицу попадут те записи где для каждого уителя етьс урок,
те учителя кторые не ведут уроки в исходную табллицу не попадут.

SELECT колонки каткорые попадают в исходную таблицу (Teacher.id, Teacher.Name, Subject.id, Subject.Name), 
FROM указываем левую таблицу с кторой будет происходить обединение (Teacher) 
INNER JOIN правая таблица с кторой происходит обединение(Subject),
ON столбцы по которым будет происходить обидинение (из таблицы Subject - Teacher_id  а из таблицы Teacher - id)

SELECT Teacher.id, Teacher.Name, Subject.id, Subject.Name FROM Teacher INNER JOIN Subject on Teacher.id = Subject.Teacher_id 

3   Елена   1   Литература
1   София   2   ОБЖ
...
7   Елена   8   Азазлолгия
3   Елена   9   Биология
--

--OUTER join
левосторнне обидинение в исходную талицу попадут вспе Teacher невважно ведут они уроки или нет если не ведут в табллилце уроков будет NULL


SELECT Teacher.id, Teacher.Name, Subject.id, Subject.Name FROM Teacher LEFT JOIN Subject ON Subject.Teacher_id = Teacher.id

1   София   3       Естествознание
1   София   2       ОБЖ
2   Сергей  NULL    NULL    
...

правосторонне (для него просо меняем левую и в правую талицу местами) попадут все Subject невважно есть учительл кторый ведет урок или нет

SELECT Teacher.id, Teacher.Name, Subject.id, Subject.Name FROM Subject LEFT JOIN Teacher ON Subject.Teacher_id = Teacher.id

3   Елена   1   Литература
1   София   2   ОБЖ
...
7   Елена   8   Азазлолгия
3   Елена   9   Биология
--

--FULL join
в исходную таблицу попадают все значения и Teacher и Subject

SELECT * FROM Teacher UNION SELECT * FROM Subject;
id  Name        age
1   Литература  3
1   София       20
2   ОБЖ         1

как видно есть проблема в именованием колонок

------------------------------------------
функции 

avg - ворвращает среднее числовое значение поля выбраной таблицы
SELECT avg(age) FROM Teacher 

38.5714285714286

------------------------------------------
возвращате количество преподаллаветелй с одинаковым возрастом
SELECT age, count(age) FROM Teacher GROUP BY age;

София   20  1
Сергей  25  2
Алексей 30  2
Елена   35  1

------------------------------------------
Чтобы избежать дублей, таблицы принято разделять:

ученики отдельно

преподаватели отдельно

предметы отдельно 
------------------------------------------


------------------------------------------
Но надо при этом их как-то связать между собой, мы ведь всё еще хотим знать, 
чей конкретно был заказ. Для связи таблиц используется foreign key, внешний ключ

--нотация для бд--
------------------------------------------
https://www.vertabelo.com/blog/crow-s-foot-notation/
Первый (часто называемый множественностью ) относится к максимальному количеству раз, когда экземпляр одной сущности может быть связан с экземплярами в связанной сущности. Это может быть один или несколько .


------------------------------------------
Entity Framework

НП хзапрещает создание пустых строк,ПК первычный ключ ключ который при удалении не удаляется , АИ автоматически нумерует строки, У уникальное поле

базы данных принято называть во мнножественном числе наприм. Users, Systems и тд

утановить через nuget пакет  system.data.sqlite в проект, скачать https://sqlitebrowser.org/ с сайта
программу баз.
------------------------------------------
или ииспользоватьт Entity Framework Core 
добавить в проект пакет Entity Framework Core, using Microsoft.EntityFrameworkCore;

Для взаимодействия с базой данных для контекста данных должна быть определена конфигурация подключения. Для ее установки можно применять  способ

  public class ApplicationContext : DbContext
    {
        //представляет набор сущностей, хранящихся в базе данных
        public DbSet<User> Users { get; set; }

        //Переопределение у класса контекста данных метода
        protected override void OnConfiguring(DbContextOptionsBuilder options)
            => options.UseSqlite(@"Data Source=C:\Users\specadmin\source\repos\ExcelParser\ExcelParser\Users.db");//В этот метод передается объект DbContextOptionsBuilder,
            // который позволяет создать параметры подключения. Для их создания вызывается метод UseSqlServer, в который передается строка подключения.
            
    }

 

создадим класс кторый мы будем предавать в базу данных
 public class User 
    {
        public int id { get; set; }

        public string login { get; set; }
        public string password { get; set; }
        public string email { get; set; }

        public User()
        {

        }

        public User(string login, string password, string email)
        {
            this.login = login;
            this.password = password;
            this.email = email;
        }
    }

==

private ApplicationContext db;//перменная для ипсолзования баз данных
        public MainWindow()
        {
            InitializeComponent();

            db = new ApplicationContext();//в конструкторе главного окна вызовем экземпляр баз данных 

        }

private void Button_Reg_Click(object sender, RoutedEventArgs e)//для примера оздааим несолкько полей в котороые мы запишем 
//значения кторый пойдут в нашу базу данных 
      {
          string login = loginTextBox.Text.Trim();//возмем их из ткстовых полей
          string pass = passTextBox.Password.Trim();
          string passRepeat = passRepeatTextBox.Password.Trim();
          string email = EmailTextBox.Text.ToLower().Trim();

db.Add(new User(login, pass, email) );//создадим базу данных с новым жкеземпляром класса и добавим туда значнея из тектовых полей
                db.SaveChanges();//сохраним изменения

      }

private void Delete_account(object sender, RoutedEventArgs e)
    {
        var users = db.Users.OrderBy(b => b.id).First();//выберем первый элемент из списка базы данных
         (users);//удалим первый эземпляр из базы даных
        db.SaveChanges();//сохарним изменения
   
private void View_accounts_Click(object sender, RoutedEventArgs e)
{
    var users = db.Users.OrderBy(b => b.id);//выберем первый элемент из списка базы данных
    foreach (var user in users)
    {
        Debug.WriteLine($"{user.id} {user.login} {user.password} {user.email}");//выведем на коносль элемент из списка базы данных
    }
    db.SaveChanges();//
}
    
private void Update_Account_Click(object sender, RoutedEventArgs e)
{
    var users = db.Users.OrderBy(b => b.id).ToList();
    users[0].email = "KEKE@ya.ru";
    users[0].login = "KESHAS";
    db.SaveChanges();
}



==========================================

--EEPlus--
------------------------------------------


namespace ExcelTable
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        private ExcelReport exRep;
        public MainWindow()
        {
            InitializeComponent();
            ExcelPackage.LicenseContext = LicenseContext.NonCommercial;

        }

        private void Report()
        {
            var reporter = new ExcelReporter().GetReport();
            var crtTable = new CreateExcelTable().Generate(reporter);
            
            File.WriteAllBytes("Report.xlsx",crtTable);
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            Report();
        }
    }

    public class ExcelReport
    {
        public OwerLoad Load;
        public OwerLoadSpecifications[] OwerSpecifications;
    }
   
    public class ExcelReporter
    {
        
        public ExcelReport GetReport()
        {
            return new ExcelReport
            {
                Load = new OwerLoad
                {

                    Name = "OwerLoad ZZ",
                    Height = 50.14
                },
                OwerSpecifications = new[]
                {
                    new OwerLoadSpecifications
                        {SerialNumber = "FGGF20", Power = 50.1, Date = new DateTime(2021, 10, 2)},
                    new OwerLoadSpecifications {SerialNumber = "FGGF20", Power = 50.1, Date = new DateTime(2021, 10, 2)}
                }
            };
        }
    }

    public class OwerLoad
    {
        public string Name { get; set; }
        public double Height { get; set; }
    }

    public class OwerLoadSpecifications
    {
        public string SerialNumber;
        public Double Power { get; set; }
        public DateTime Date { get; set; }
    }

    public class CreateExcelTable
    {
        public byte[] Generate(ExcelReport report)
        {
            var pack = new ExcelPackage();
            var sheet = pack.Workbook.Worksheets.Add("Load Report");
            sheet.Cells["B2"].Value = "Load:";
            sheet.Cells[2, 3].Value = report.Load.Name;
            sheet.Cells["B3"].Value = "Other:";
            sheet.Cells["C3"].Value = $"{report.Load.Height}";
            pack.Workbook.Protection.LockStructure = true;
            pack.Workbook.Protection.SetPassword("password");
            return pack.GetAsByteArray();
        }
    }
}

==========================================
--Общая информация--

------------------------------------------
*sql, *базы данных, *кортежи
Для представления одного набора данных. Например, кортеж может представлять запись базы данных, 
а ее компоненты могут представлять отдельные поля записи.

*рефакторинг - это контролируемый процесс улучшения кода, без написания новой функциональности. 
Результат рефакторинга — это чистый код и простой дизайн.

*структруы, *list
если создаешь структуру, и в ней есть List то копируя структуры ты не копируешь List а копируешь ССЫЛКУ на 
ТОТ же List. используя контукркцию List<int>intList; создаемссылку на спикос без выделения памяти
используя контукркцию List<int>intList = new List<int>(); создаем ссылку на спикос и выделяем память под его экземпляр

*list, *сравнение *SequenceEqual
сравнение списков по муолчанию (именно содержимого а не ссылок)ListName1.SequenceEqual(ListName2);

public static bool SequenceEqual<T>( 
       this IEnumerable<T> first, 
       IEnumerable<T> second);
Эта операция перечисляет каждую входную последовательность параллельно, сравнивая элементы с помощью метода
 System.Object.Equals. Если элементы эквивалентны, и последовательности содержат одинаковое количество элементов, 
 операция возвращает true. Иначе она возвращает false.

*List, *сравнение *IEqualityComparer *Linq *SequenceEqual
static void Main(string[] args)
        {
            string[] strArr1 = {"0012", "130", "0000019", "4"};
            string[] strArr2 = {"12", "0130", "019", "0004"};
            
            bool eq = strArr1.SequenceEqual(strArr2, new MyStringifiedNumberComparer());//используем наш класс в качесвте опции сравнения

            Console.WriteLine(eq);
        }

        public class MyStringifiedNumberComparer : IEqualityComparer<string>//в генерик пишем знаение кторое идет в сравниаемых обьектах
        {
            public bool Equals(string x, string y)//переопределяем метод Equals взятый из IEqualityComparer
            {
                return (Int32.Parse(x) == Int32.Parse(y));//очищаем от лишних 00 впрееди наши строки преобразовоывая из в int 
                //тк 0012 нитов не бывает есть тольо 12 и тд
            }

            public int GetHashCode(string obj)//это необходимо для того чтобы сравнивать хеши обьектов те например хеш инта
                                              //12 и еще одного инта 12 будут равны
            {
                return Int32.Parse(obj).ToString().GetHashCode();
            }

        }

*Linq *Skip
filter = filter.Skip(page * PageSize).Take(PageSize);//Метод Skip() пропускает определенное количество элементов,
// а метод Take() извлекает определенное число элементов. Нередко данные методы применяются вместе для создания постраничного вывода.

*.NET *типы 
В мире .NET
тип — это просто общий термин, применяемый для ссылки на член из набора (класс,
интерфейс, структура, перечисление, делегат). 
==========================================


--Язык_программирования_C#_7_и_платформы_NET_и_NET_Core,_8_е_изд_Эндрю--
------------------------------------------

--CLR CTS CLS
------------------------------------------
CLR

CLR (Common language runtime) — общеязыковая исполняющая среда. Она обеспечивает интеграцию языков и позволяет объектам
благодаря стандартному набору типов и метаданным), созданным на одном языке, быть «равноправными гражданами» кода, написанного на другом.

CLR действительно управляет процессом выполнения команд (машинного кода, если хотите) и решает, какой кусок кода (функцию) от куда взять
 и куда подставить прямо в момент работы программы. Процесс компиляции представлен нииже:

файл с исходным кодом на C#, Fortran, Basic, JSccript => компилятор C#, Fortran, Basic, JSccript => управляемый модуль (IL и метдананные)

IL (Intermediate Language) — код на специальном языке, напоминающим ассемблер, но написанном для .NET. 
В него преобразуется код из других языков верхнего уровня (c#, VisualBasic). 
Вот тогда-то и пропадает зависимость от выбранного языка. Ведь все преобразуется в IL

Метаданные это таблицы, в которых есть поля, говорящие о том, что такой-то метод находится в таком-то файле и
 принадлежит такому-то типу(классу).

TypeDef — это запись, для каждого типа, определенного в модуле

Сперва, перед выполнением Main() среда CLR находит все объявленные типы (например тип Console).
Затем определяет методы, объединяя их в записи внутри единой “структуры» (по одному методу определенному в типе Console).
Записи содержат адреса, по которым можно найти реализации методов (т.е. те преобразования, которые выполняет метод).

CTS

CTS (Common Type System) — общая система типов в CLR (тип, по-видимому — это аналог класса C#). Это — стандарт,
 признанный ECMA* который описывает определение типов и их поведение.
Также определяет правила наследования, виртуальных методов, времени жизни объектов. После регистрации ECMA* стандарт получил название 
CLI ( Common Language Infrastructure):

— CTS поддерживает только единичное наследование (в отличие от С++)
— Все типы наследуются от System.Object (Object — имя типа, корень все остальных типов, System — пространство имен)

Основные члены поддерживаемые CTS:

Поле — переменная, часть состояния объекта. Идентифицируются по имени и типу.
Метод — функция, выполняющая действие над объектом. Имеет имя, сигнатуру(число параметров, последовательность, 
  типы параметров, возвр. значение функции) и модификаторы.
Свойство — в реализации выглядит как метод (get/set) а для вызывающей стороны как поле ( = ).
 Свойства позволяют типу, в котором они реализованы, проверить входные параметры и состояние объекта.
Событие — обеспечивает механизм взаимного уведомления объектов.

Модификаторы доступа:

Public — метод доступен любому коду из любой сборки
Private — методы вызывается только внутри типа
Family (protected) — метод вызывается производными типами независимо от сборки
Assembly (internal) — метод вызывается любым кодом из той же сборки
Family or Assembly
(protected internal) — метод вызывается производными типами из любой сборки и + любыми типами из той же сборки.


CLS (Common Language Specification) — спецификации выпущенная Майкрософт. Она описывает минимальный набор возможностей,
которые должны реализовать производители компиляторов, чтобы их продукты работали в CLR. 

Атрибут [assembly: CLSCompliant(true)] заставляет компилятор обнаруживать любые доступные извне типы,
 содержащие конструкции, недопустимые в других языках.

[assembly: CLSCompliant(true)]

namespace ExperementNetCore
{
    public class SS
    {
        public UInt32 Abc()//Warning CS3002  Return type of 'SS.Abc()' is not CLS-compliant  

        {
            return 0;
        }
    }
...
данное предупреждение: UInt32 Abc() возвращает целочисленное целое без знака. Visaul Basic, например, не работает с такими значениями.



*ECMA основанная в 1961 году ассоциация, деятельность которой посвящена стандартизации информационных и коммуникационных технологий.
 Изначально ассоциация называлась ECMA — European Computer Manufacturers Association, однако она сменила название в 1994 году 
 в связи с глобализацией её деятельности. Вследствие этого название Ecma перестало быть аббревиатурой и больше не пишется заглавными буквами.

Ассоциация преследует три цели:

Создавать (в сотрудничестве с организациями аналогичной направленности, но локального масштаба) стандарты и технические отчёты в 
порядке поддержки и стандартизации использования информационных и сетевых систем.
Поощрять правильное использование стандартов путём влияния на контекст их употребления.
Публиковать стандарты и технические отчёты в электронном и бумажном виде. Распространение документов должно быть 
бесплатно и неограниченно.

.NET предоствляет библиотеку базовых классов, которая доступна всем языкам программирования .NET.

Библиотеки базовых классов определяют типы, которые можно использовать для построения программного приложения любого вида. 
Например, инфраструктуру ASP.NETможно применять для создания веб-сайтов и служб REST, инфраструктуру WCF — для
построения распределенных систем, инфраструктуру WPF — для написания настольных приложений с GUI


--основные спецификации с#
------------------------------------------
--что привносит c#

- Указатели необязательны! В программах на C# обычно не возникает потребность
в прямых манипуляциях указателями 

-Автоматическое управление памятью посредством сборки мусора

- Аналогичная языку C++ возможность перегрузки операций для специальных типов без особой сложности

- Поддержка программирования на основе атрибутов. Разработка такого вида позволяет аннотировать типы и
 их члены для дополнительного уточнения их поведения. Например, если пометить метод атрибутом [Obsolete], то при попытке его
использования программисты увидят ваше специальное предупреждение.

-Возможность создания обобщенных типов и обобщенных членов.

-Поддержка анонимных методов, которые позволяют предоставлять встраиваемую
функцию везде, где требуется тип делегата и анонимных типов()

-Возможность определения одиночного типа в нескольких файлах кода(partial)

-Поддержка строго типизированных запросов (например, LINQ)

-Возможность расширения функциональности существующего типа(расширяющие методы)

-Включение лямбда-операции (=>) и реализация однострочных методов 

-Новый синтаксис инициализации объектов, позволяющий устанавливать значения свойств во время создания объекта

-Поддержка необязательных параметров и именованных аргументов в методах

-ковариантность и контравариантность.

-async, await значительно упрощают многопоточное и асинхронное программирование. 

-Встраиваемая инициализация для автоматических свойств, а также поддержка
автоматических свойств, предназначенных только для чтения.

-Поддержка статического импортирования для предоставления прямого доступа к
статическим членам внутри пространства имен

-пи 11-условная операция, которая помогает проверять параметры на предмет
null в реализации метода

-интерполяцией строк

-Использование await в блоках catch и finally.

-Выражения nameOf для возвращения строкового представления символов

-Инициализаторы индексов.

-локлаьные функци

-Обобщенные асинхронные возвращаемые типы

-Новые маркеры для улучшения читабельности числовых констант.

-Легковесные неименованные типы (называемые кортежами), которые содержат
множество полей.

-Возвращение ссылки на значение вместо только самого значения
(ссылочные локальные переменные и возвращаемые ссылочные значения)

- Введение одноразовых переменных (называется отбрасыванием)

-Выражения throw, позволяющие размещать конструкцию throw в большем числе
мест — в условных выражениях, лямбда-выражениях и др.

-Возможность иметь асинхронный метод Main () программы.

-Новый литерал default, который делает возможной инициализацию любого типа.

-Подобно анонимным методам имена кортежей могут выводиться из проекции, которая их создает.
==

--
язык C# может применяться только для построения программного обеспечения, которое функционирует под управлением исполняющей среды .NET

------------------------------------------
управляемый неуправмый код

Выражаясь официально, для обозначения кода, ориентированного на исполняющую среду .NET, используется термин управляемый код. Двоичный
модуль, который содержит управляемый код, называется сборкой. 

Код, который не может напрямую обслуживаться исполняющей средой .NET, называется неуправляемым кодом


--Другие языки програмированаия ориентировпные на .NET
------------------------------------------
Изначально среда Visual Studio предлагает пять управляемых
языков — 
С#,
Visual Basic, 
C++/СLI, 
JavaScript 
F#

F# является языком .NET, основанным на синтаксисе функциональных языков. Нарядус тем, что F# можно использовать как чистый
 функциональный язык, он также поддерживает конструкции объектно-ориентированного программирования (ООП) и библиотеки базовых
классов .NET. 

--главные конструкции програмировния
------------------------------------------
defalt

Литерал default является новым средством в версии C# 7.1, которое позволяет присваивать переменной стандартное значение ее типа данных. 
Литерал default работает для стандартных типов данных, а также для специальных классов (глава 5) и обобщенных типов (глава 9).

------------------------------------------
--встроенные типы данных и операция new

используя ключевое слово new, что автоматически устанавливает переменную в ее стандартное значение:

-переменные типа bool устанавливаются в false;

-переменные числовых типов устанавливаются в 0 (или в 0 . О для типов с плавающей точкой);

-переменные типа char устанавливаются в пустой символ;

-переменные типа Biglnteger устанавливаются в 0;

-переменные типа DateTime устанавливаются в 1/1/0001 12:00:00 AM;

-объектные ссылки (включая переменные типа string) устанавливаются в null.


------------------------------------------


------------------------------------------



==========================================
==========================================

--Solid--солид--
------------------------------------------

--принцип единственной отстоветвенности--srp
------------------------------------------
у класса должна быть только одна причина для изменения весь класс должен выполнять
одну задачу например класс для датчика температуры в коором содержитьься методы
температуры и вермени должен быть разбит на два класса


Допустим, нам надо определить класс отчета, по которому мы можем перемещаться
 по страницам и который можно выводить на печать. На первый взгляд мы могли бы определить следующий класс
public class Report
{
    public string Text { get; set; }

    #region эти методы относятся к навигаци по отчету и преддстявлют единыцй функционал

    public void GoToFirstPade()
    {
        Console.WriteLine("Go to first pade");
    }

    public void GoToLastPade()
    {
        Console.WriteLine("Go to last pade");
    }

    public void GoToPade(int padeNum)
    {
        Console.WriteLine($"Go to pade {padeNum}");
    }

    #endregion

    #region этот метод отличается по функционалу
//что еесли нам понядоится печать отчет наа консоль или пердать его на принтер для физической печати на бумаге
//или вывести в файл или сораниьт в формате тесктовом 

//тогда примедтся менять для этого метод print однака это врятли затронет методы навигации

//так же если будут менятся методы постраничной навигации это не затронет метод print
    public void Print()
    {
        Console.WriteLine("Print report");
        Console.WriteLine(Text);
    }

    #endregion
    
}

в этом случае можно вывести метод в отдельный класс и применить агрегацию

public interface IPrinter
{
    void Print(string text);
}

//вывод в отдельный класс
class ConsolePrinter : IPrinter 
{
    public void Print(string text)
    {
        Console.WriteLine("Print report");
        Console.WriteLine(text);
    }
}

public class Report
{
    public string Text { get; set; }
    
    public void GoToFirstPade()
    {
        Console.WriteLine("Go to first pade");
    }

    public void GoToLastPade()
    {
        Console.WriteLine("Go to last pade");
    }

    public void GoToPade(int padeNum)
    {
        Console.WriteLine($"Go to pade {padeNum}");
    }
    
    //применить агрегацию к методу Print
    
    //теперь метод print получает ссылку на обьект IPrinter который используется для печатии 
    public void Print(IPrinter printer)
    {
        printer.Print(this.Text);
    }
}




using SolidPrincipals;

IPrinter printer = new ConsolePrinter();
Report report = new Report();

report.Text = "Hello world";
report.Print(printer);

побочным положительным действие является что тперб функционал печати инкапсулируется в оодном месте
и теперь его можно использовать длля обьектов других классов а не только Report :


public class MyBook
{
    public string Text { get; set; }

    public void WriteMyBook()
    {
        Console.WriteLine("Write my book");       
    }

    public void Print(IPrinter printer)
    {
        printer.Print(Text);
    }
}


MyBook myBook = new MyBook();

myBook.Text = "Bla bla";
myBook.Print(printer);

--

обязанности в классах не всегде группируются по методам ингогда бывает что в одном методе сгруппировано 
несолько обязанностий

namespace SolidPrincipals;

public class Soda
{
    public string Taste { get; set; }
    public int Price { get; set; }
}

//класс знает абсоолютн все как получать данные как валилдировать как созранять как записывать это суперклас
public class SodaMarket
{
    private List<Soda> sodasList = new List<Soda>();
    
    //класс имеет всего один метод но это метод имеет 4 обязанности ввод данных, валидация, создание обьекта, сохранение 
    public void Process()
    {
        Console.WriteLine("Write taste");
        string? taste = Console.ReadLine();

        Console.WriteLine("Write price");
        int price = 0;
        bool result = Int32.TryParse(Console.ReadLine(), out price);
        if ( !result || price <= 0|| string.IsNullOrEmpty(taste))
        {
            Console.WriteLine("Неверно введеныы данные"); 
        }
        else
        {
          sodasList.Add(new Soda{Taste = taste, Price = price});

          using StreamWriter writer = new StreamWriter("store.txt", true);
          writer.WriteLine(taste);
          writer.WriteLine(price);
          Console.WriteLine("Данные успешно ообработаны");
        }
    }
}

using SolidPrincipals;

SodaMarket sodaMarket = new SodaMarket();

sodaMarket.Process();


--принцип открытости закрытости--ocp
------------------------------------------
суть принципа в том что сиистем должна бытьь построена таким образом что все ее последующие изменения должны быть 
реализованы новым кодом а не изменением старого

namespace SolidPrincipals;

public class Cook
{
    public string Name { get; set; }

    public Cook(string name)
    {
        Name = name;
    }

    public void MakeDinner()
    {
        Console.WriteLine("Чистим картошку");
        Console.WriteLine("Ставим очищеную картошку на огонь");
        Console.WriteLine("сливаем осоатки воды разминаем кареный картофельь в пюре");
        Console.WriteLine("Картофельное пюре готово");
    }
}

Cook Bob = new Cook("Bob"); 
Bob.MakeDinner();

однако однгого умени готовить пюре недоостаочнго для повара и тут возникает необходимость изменить уже сущетвующий класс
повара. но в соответсвии с рассматриваемым принципом это не подходит.

для рещение этой пробелмы используется паттерн стратегия, сперва вывести из класса и инкапсулировать часть кторая
представляет изменяющееся поведение - MakeDiner(), но это не всегда удается просо седлать. Может в классе много метотов
и на начальном этапе сложно оперделить какие из них будут изменять и как измеенять свое поведение.
поэтому нужно проаналихироват это и основвась на результатах анализа все что поддается изменению выносится из класса
и нкапсулируется во внешних сущнгостях

 namespace SolidPrincipals;

public class Cook
{
    public string Name { get; set; }

    public Cook(string name)
    {
        Name = name;
    }

    public void MakeDinner(IFood food)
    {
        food.Make();
    }
}

//теперь приготовление еды абстрагировано в это интерфейсе 
public interface IFood
{
    void Make();
}

//и реализации приготовление еды определены в реализациях этого  интерфейса
class PotatoFood : IFood
{
    public void Make()
    {
        Console.WriteLine("Чистим картошку");
        Console.WriteLine("Ставим очищеную картошку на огонь");
        Console.WriteLine("сливаем осоатки воды разминаем кареный картофельь в пюре");
        Console.WriteLine("Картофельное пюре готово");
    
    }
}

//и реализации приготовление еды оппределены в реализациях этого  интерфейса
class SaladFood:IFood
{
    public void Make()
    {
        Console.WriteLine("Нарезаем помидоры");
        Console.WriteLine("Посыпаем зеленью, солью и специями");
        Console.WriteLine("Поливаем подсолечным маслом");
        Console.WriteLine("Салат готов");

    }
}


Cook Bob = new Cook("Bob"); 
Bob.MakeDinner(new PotatoFood());
Bob.MakeDinner(new SaladFood());

тепперь класс Cook заищищен от изменений зато можно легко расщиртять его функциональность определив доп реализации
интерфейса IFood

--
другим распостраненым методом принменения принципа osp является паттерн шаблоный метод

namespace SolidPrincipals;

//абстрактный класс создает шаблоный метод Make отдельные части которого реализуются классами наследниками
public abstract class FoodBase
{
    public void Make()
    {
        Prepare();
        Cook();
        FinalSteps();
    }

    protected abstract void Prepare();
    protected abstract void Cook();
    protected abstract void FinalSteps();
}

public class Cook
{
    public string Name { get; set; }

    public Cook(string name)
    {
        Name = name;
    }

    //теперь класс Cook принимает набор FoodBase  ввиде меню
    public void MakeDinner(FoodBase[] menu)// Если повар готовит из некоторого набора блюд,
    //  то вполне можно установить набор блюд как внутреннее свойство повара.
    {
        foreach (var foodBase in menu)
        {
            foodBase.Make();
        }
    }
}

class PotatoFood : FoodBase
{
    protected override void Prepare()
    {
        Console.WriteLine("Чистим картошку");
    }

    protected override void Cook()
    {
        Console.WriteLine("Ставим очищеную картошку на огонь");
        Console.WriteLine("Сливаем остатки воды разминаем вареный картофель в пюре");
    }

    protected override void FinalSteps()
    {
        Console.WriteLine("Картофельное пюре готово");
    }
}

class SaladFood : FoodBase
{
    protected override void Prepare()
    {
        Console.WriteLine("Моем овощи");
    }

    protected override void Cook()
    {
        Console.WriteLine("Нарезаем помидоры");
        Console.WriteLine("Посыпаем зеленью, солью и специями");
        Console.WriteLine("Поливаем подсолечным маслом");
    }

    protected override void FinalSteps()
    {
        Console.WriteLine("Салат готов");
    }
}

в данном случае расширение класса производится за счет наследования классов которые определяют требуемый функционал

Cook Bob = new Cook("Bob");
FoodBase[] foodBases = new FoodBase[]{new PotatoFood(), new SaladFood()};
Bob.MakeDinner(foodBases);

------------------------------------------
--принцип подстановки лисков--lsp

должна быть возможность вместо базового типа подставлять любой его подтип

lsp - объекты дочернего класса должны иметь возможность заменять объекты родительского класса без ущерба 
для целостности приложения. По сути, это означает, что мы должны приложить усилия для создания таких объектов 
производного класса, которые могут заменить объекты базового класса без изменения его поведения. 
Если мы этого не сделаем, наше приложение может оказаться сломанным.

проблема ктороую рещает lsp можно наглядно продемонстрировать на примере двух классов прягоугольника и квадрата

namespace SolidPrincipals;

public class Rentagle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }

    public int GetArea()
    {
        return Width * Height;
    }
}
//как правило квадрат представляют как частный случай прямоугольниика теже углы, 4 стороны,
//только ширина обязательно равна высоте
class Square : Rentagle
{
    public override int Width
    {
        get => base.Width;
        set
        {
            //тк ширина и высота равны тут сразу устанаваливается сразу и ширина и высота
            base.Width = value; 
            base.Height = value;
        }
    }

    public override int Height
    {
        get => base.Height;
        set
        {
            //тк ширина и высота равны тут сразу устанаваливается сразу и ширина и высота
            base.Height = value;
            base.Width = value;
        }
    }
}

на первый взгляд все правильно но елси представить следующую ситауцию


Rectangle rectangle = new Square();
TestRentagleArea(rectangle);

//ожиждается что переданнаый в свойство обььект будет вести себя как прямоугольник, но однако
//квадрат будуичи заисаным сюда ведет себя не как прямоугольник хотя и наследует от него
static void TestRentagleArea(Rectangle rectangle)
{
    rectangle.Height = 5;
    rectangle.Width = 10;
    //в итоге програма выдат ошибку тк запишет сюда не умноденние 5*10,
    // а умножение последнего присвоеного значитения те 10*10
    if (rectangle.GetArea() != 50)
    {
        throw new Exception("Неккоректная площадь");
    }
}

ждя выхода из такой ситуации можно ввести вот такую конструкцию, но она не отменяет факт что 
с архитектрутой классов чото не так

Rectangle rectangle = new Square();
TestRentagleArea(rectangle);

static void TestRentagleArea(Rectangle rectangle)
{
    //проверка на соответствие типу 
    if (rectangle is Square)
    {
        rectangle.Height = 5;
        if (rectangle.GetArea() != 25)
        {
            throw new Exception("Неккоректная площадь");
        }
    }
    else if (rectangle is Rectangle)
    {
        rectangle.Height = 5;
        rectangle.Width = 10;
        if (rectangle.GetArea() != 50)
        {
            throw new Exception("Неккоректная площадь");
        }
    }
}

в данном примере клас Sqwaer не ведет себя как базовый класс Rentagle и поэтому его неследует наследоать
от этого класса.

чтобы решить эту пробелму сущетвует набор правил 

правило контракта это интерфейс базового класса, нектороые соглашение ктороым должен следовать класс наследник
контракт создаеет ряд ограничениий и клас наследник выполнятьь эти ограничения
--
--предусловия (Preconditions) не могут быть усилены в подклассе - подклассы не должны создавать больше предусловий
чем есть в базовом классе.

предусловия это набор условий необходимый для безошибочного выоплнения метода

public virtual void SetCapital(int money)
{
    //без выполнения этого предусловия не будет выполнятсся остальныые действия
    if (money < 0)
        throw new Exception("Нельзя положить на счет меньше 0");
    this.Capital = money;
}

--
обьектами предусловий могут быть только общедоступные свойсвта или поля или пармтеры метода, данное выыражение 
не является предусловием, тк isValid приватный

private bool isValid = false
public virtual void SetCapital(int money)
{
    if (isValid == false)
        throw new Exception("Валидация не пройдена");
    this.Capital = money;
}

--
есть два класса Account и MicroAccount который переопределяет SetCapital из Account

public class Account
{
    public int Capital { get; set; }

    public virtual void SetCapital(int money)
    {
        if (money < 0)
        {
            throw new Exception("нельзя положить на счет меньше 0");
        }

        Capital = money;
    }
}

class MicroAccount : Account
{
    //в этом случае подкласс MicroAccount добавляет дополнительное предусловие, те усиливает то что недопустимо

    public override void SetCapital(int money)
    {
        if (money < 0)
        {
            throw new Exception("нельзя положиьь на счет менше 0");
        }
//это нарушет принцип лискова тк при вызове наследника в мпето родителя при money >1000 выскочит исключение
        if (money > 1000)
        {
            throw new Exception("нельзя положить на счет больше 1000");
        }

        base.SetCapital(money);
    }
}
тк MicroAccount добавил доп предусловие то можно столкунтся с проблемой

Account account = new MicroAccount();
InitializeAccount(account);

//с точки зрения Account этом метод вполне работоспособен, однако при передаче в него MicroAccount 
//в нем будет ошибка, и принцип Лисков будет нарушен.
static void InitializeAccount(Account account)
{
    account.SetCapital(2000);
    Console.WriteLine(account.Capital);
}

--
--постусловия не могут быть ослаблены в подклассе, подклассы должны выполнять все постусловия
которые определены в базовом классе

постусловия проверяют состояние возвразаемого обьекта на выходе из функции:

 public static float GetMedium(float[] nums)
    {
        if (nums.Length == 0)
        {
            throw new Exception("длина массива равна 0");
        }

        float result = nums.Sum() / nums.Length;

        //это выражение является постусловием
        if (result < 0)
        {
            throw new Exception("результат меньше 0");
        }

        return result;
    }

--
исходя из логики Account в методе CalculateInterest ожидается получить в качествее результата 1200 
однако логика класса MicroAccount показывает другой результат, в итоге опять нарушение принципа лисков 

namespace SolidPrincipals;

public class Account
{
    public int Capital { get; set; }

    
    public virtual decimal GetInterest(decimal sum, int month, int rate)
    {
        //предусловие
        if (sum < 0 || month > 12 || month < 1 || rate < 0)
        {
            throw new Exception("неккоректные данные");
        }

        decimal result = sum;

        for (int i = 0; i < month; i++)
        {
            result += result * rate / 100;
        }

        //постусловие
        //в классе MicroAccount это условиее не исопльзуется и тем самым нарушается принцип лисков
        if (sum >= 1000)
        {
            //доавбляем к результату бонус
            result += 100;
        }

        return result;
    }
}

class MicroAccount : Account
{
  
    public override decimal GetInterest(decimal sum, int month, int rate)
    {
        if (sum < 0 || month > 12 || month < 1 || rate < 0)
        {
            throw new Exception("неккоректные данные");
        }

        decimal result = sum;

        for (int i = 0; i < month; i++)
        {
            result += result * rate / 100;
        }

        return result;
    }
}

Во всех трех вышеперечисленных случаях проблема решается в общем случае с помощью абстрагирования и
выделения общего функционала, который уже наследуют классы Account и MicroAccount.
То есть не один из них наследуется от другого, а оба они наследуются от одного общего класса.

Таким образом, принцип подстановки Лисков заставляет задуматься над правильностью построения иерархий
классов и применения полиморфизма, позволяя уйти от ложных иерархий наследования и делая всю систему 
классом более стройной и непротиворечивой.

В этом примере у нас будет массив чисел и базовая функциональность для суммирования всех чисел из этого массива.
Но допустим, нам нужно суммировать только четные или только нечетные числа.

public class SumCalculator
{
    protected readonly int[] _numbers;
    public SumCalculator(int[] numbers)
    {
        _numbers = numbers;
    }
    public int Calculate() => _numbers.Sum();
}

public class EvenNumbersSumCalculator: SumCalculator
{
    public EvenNumbersSumCalculator(int[] numbers)
        :base(numbers)
    {
    }
    public new int Calculate() => _numbers.Where(x => x % 2 == 0).Sum();
}

Теперь, если мы проверим это решение, вычислим ли мы сумму всех чисел или сумму
только четных чисел, мы обязательно получим правильный результат

 var numbers = new int[] { 5, 7, 9, 8, 1, 6, 4 };
        SumCalculator sum = new SumCalculator(numbers);
        Console.WriteLine($"сумма всех чисел: {sum.Calculate()}");//сумма всех чисел: 40
        Console.WriteLine();
        EvenNumbersSumCalculator evenSum = new EvenNumbersSumCalculator(numbers);
        Console.WriteLine($"сумма всех четных чиел: {evenSum.Calculate()}");//сумма всех четных чиел: 18

Почему мы пытаемся это исправить?

Ну, как мы все знаем, если дочерний класс наследуется от родительского класса, 
то дочерний класс является родительским классом. Имея это в виду, мы должны иметь возможность хранить ссылку
на EvenNumbersSumCalculatorкак SumCalculator переменную, и ничего не должно измениться. Итак, давайте проверим это:

umCalculator evenSum = new EvenNumbersSumCalculator(numbers);
Console.WriteLine($"сумма всех четных чисел: {evenSum.Calculate()}");//сумма всех четных чиел: 40

Как мы видим, мы не получаем ожидаемого результата, потому что наша переменная evenSum имеет тип,
SumCalculator который является классом более высокого порядка (базовым классом). 
Это означает, что Countметод из SumCalculatorкласса будет выполнен.
Итак, это, очевидно, неправильно, потому что наш дочерний класс не ведет себя как замена родительского класса.

public abstract class Calculate
{
    protected int[] getValues;

    public Calculate(int[] getValues)
    {
        this.getValues = getValues;
    }

    public abstract int SumAllValues();
}

class SumAll : Calculate
{
    public SumAll(int[] getValues) : base(getValues)
    {
    }


    public override int SumAllValues()
    {
       return getValues.Sum();
    }
}

class SumAllEven : Calculate
{
    public SumAllEven(int[] getValues) : base(getValues)
    {
    }

    public override int SumAllValues()
    {
        return getValues.Where(val => val % 2 == 0).Sum();
    }
}


--

namespace SolidPrincipals;

public abstract class Employee
{
    public virtual string GetWorkDetails(int id)
    {
        return "Base Work";
    }

    public virtual string GetEmployeeDetails(int id)
    {
        return "Base Employee";
    }
}

public class SeniorEmployee : Employee
{
    public override string GetWorkDetails(int id)
    {
        return "Senior Work";
    }

    public override string GetEmployeeDetails(int id)
    {
        return "Senior Employee";
    }
}

public class JuniorEmployee : Employee
{
    // Допустим, для Junior’a отсутствует информация
    public override string GetWorkDetails(int id)
    {
        throw new NotImplementedException();
    }


    public override string GetEmployeeDetails(int id)
    {
        return "Junior Employee";
    }
}

List<Employee> list = new List<Employee>
{
    new JuniorEmployee(),
    new SeniorEmployee()
};

foreach (Employee emp in list)
{
    emp.GetEmployeeDetails(985);
    emp.GetWorkDetails(985);// Для JuniorEmployee невозможно вернуть информацию о работе,
    // поэтому вы получите необработанное исключение, что нарушит принцип LSP 
}

рещение этой проблемы в том что нужно разбить функцинал на два интерфейса  IWork и IEmployee

namespace SolidPrincipals;

//разделение функциона на два интерфейса

//общие для всех разработчиков данные вынесены в общий интерфейс от кторого
//наследуются уже конктерные интерфейсы
public interface IPerson
{
    string GetEmployeeName(int employeeName);
    string GetEmployeeAge(int employeeAge);
}
//специфичные для конкретного разработчика данные вынесены в отдельный интерфейс
public interface IEmployee : IPerson
{
    string GetEmployeeDetails(int employeeId);
}

public interface IWork : IPerson
{
    string GetWorkDetails(int employeeId);
}

//конктрентыйразработчик наследуется от конкретного интрефейса
public class SeniorEmployee : IEmployee, IWork
{
   
    public string GetEmployeeName(int employeeName)
    {
        return "Andrey";
    }

    public string GetEmployeeAge(int employeeAge)
    {
        return "20";
    }
    
    public string GetWorkDetails(int id)
    {
        return "Senior Work";
    }

    public string GetEmployeeDetails(int id)
    {
        return "Senior Employee";
    }

}

public class JuniorEmployee : IEmployee
{
    public string GetEmployeeName(int employeeName)
    {
        return "Alex";
    }

    public string GetEmployeeAge(int employeeAge)
    {
        return "25";
    }
    public string GetEmployeeDetails(int id)
    {
        return "Junior Employee";
    }
}



--принцип разделения интерфейсов--isp
------------------------------------------
в случае прегружености интерфейса функционалом необходимо применять принцип isp - клиенты(классы наледниеки интерфейса)
не должны вынуждено зависеть от меотодов ктоороыми не польлзуются.

при нарушении клиент станоовится восприимчив от методов кторыми не пользуюется - жесткая зависимость между разными частями 
интерфейсов ктороы могут быть не связаны с его реализациями


namespace SolidPrincipals;

//интерфейс определяет все основное что нужно для отправки сообщения
interface IMessage
{
    public string Message { get; set; }
    public string Subject { get; set; }
    public string ToAddress { get; set; }
    public string FromAddress { get; set; }
    public byte[] Voice { get; set; }

    void Send();
}

//с точки зрения lsp этот класс удволетворяет всем требования
public class EmailMessage : IMessage
{
    public string Message { get; set; }
    public string Subject { get; set; }
    public string ToAddress { get; set; }
    public string FromAddress { get; set; }
    public byte[] Voice
    {
        get => throw new NotImplementedException();
        set => throw new NotImplementedException();
    }

    public void Send()
    {
        Console.WriteLine($"Отправка сообщения по Email {Message}");
    }
}

class SmsMessage : IMessage
{
    public string Message { get; set; }

    //здесь полявляется проблема тк в смс не указыывается тема, те полявляется избыточная функциональность
    public string Subject
    {
        get => throw new NotImplementedException();
        set => throw new NotImplementedException();
    }

    public string ToAddress { get; set; }
    public string FromAddress { get; set; }

    public byte[] Voice
    {
        get => throw new NotImplementedException();
        set => throw new NotImplementedException();
    }

    public void Send()
    {
        Console.WriteLine($"Отправка сообщений по смс {Message}");
    }
}

class VoiceMesage : IMessage
{
    public string Message { get; set; }
    public string Subject { get; set; }
    public string ToAddress { get; set; }

    public string FromAddress { get; set; }

    //тут появляется еще одно свойства представлющее глосовое сообщение которое добавляетя и в интерфейс,
    //и опять ненужные совйства в емейл и смс это явное нарушение принципа isp
    public byte[] Voice { get; set; }

    public void Send()
    {
        throw new NotImplementedException();
    }
}
--
для рещения такой проблемы нужно выделить из классов группы связаных методов и свойств и определить для 
каждой группы свой интерфейс

namespace SolidPrincipals;
//общий интерфейс для всех сообщений
interface IMessage
{
    public string ToAddress { get; set; }
    public string FromAddress { get; set; }

    void Send();
}
//интерфейс дл емейлов и тд..
interface IEmailMessage : ITextMessage
{
    public string Subject { get; set; }
}

interface IVoiceMessage : IMessage
{
    public byte[] Voice { get; set; }
}

interface ITextMessage : IMessage
{
    public string Text { get; set; }
}

//тееперь можно удалить все ненужные члены из классов
public class EmailMessage : IEmailMessage
{
    public string Text { get; set; }
    public string Subject { get; set; }
    public string ToAddress { get; set; }
    public string FromAddress { get; set; }

    public void Send()
    {
        Console.WriteLine($"Отправка сообщения по Email {Text}");
    }
}

class SmsMessage : ITextMessage
{
    public string Text { get; set; }
    public string ToAddress { get; set; }
    public string FromAddress { get; set; }

    public void Send()
    {
        Console.WriteLine($"Отправка сообщений по смс {Text}");
    }
}

class VoiceMesage : IVoiceMessage
{
    public string Subject { get; set; }
    public string ToAddress { get; set; }
    public string FromAddress { get; set; }
    public byte[] Voice { get; set; }

    public void Send()
    {
        Console.WriteLine("передача голосовой почты");
    }
}


--принцип инверсии зависимостей--dip
------------------------------------------
для создание слабосвязаных сущностей котороые легко тестировать, модфицирвать и обновлять - 
модули верхнего уровня не должны зависеть от модулей ниженго уровня. и те и другие должны заивсеть от абстакиций/
абстаркции не должны зависеть от деталей.а детали должны зависеть от асбтаркций



namespace SolidPrincipals;
//класс Book использует для печати класс MyConsolePrinter тем самым завись от него 
public class Book
{
    public string Text { get; set; }
    public MyConsolePrinter Printer { get; set; }

    public void Print()
    {
        Printer.Print(Text);
    }
}

public class MyConsolePrinter
{
    public void Print(string text)
    {
        Console.WriteLine(text);
    }
}

те тут жестко определено что книгу модно напечатать только на консоли с помощть MyConsolePrinter, другие варинеты
например вывод на принтер или вывод в файл с ипользованием какихто эдмеентов GUI все это исключено в данном случае
это нарушает принцип dip
--
решение проблемы - отделив абстаркции от низкуровневеой реализации теперь dip соблюден

namespace SolidPrincipals;

public interface IMyPrinter
{
    public void Print(string text);
}
public class Book
{
    public string Text { get; set; }
    public IMyPrinter Printer { get; set; }

    public Book(IMyPrinter printer)
    {
        Printer = printer;
    }

    public void Print()
    {
        Printer.Print(Text);
    }
}

class MyConsolePriniter : IMyPrinter
{
    public void Print(string text)
    {
        Console.WriteLine($"печатаем текст в консоль {text}");
    }
}

class MyHtlPrinter : IMyPrinter
{
    public void Print(string text)
    {
        Console.WriteLine($"печать в html {text}");
    }
}

Теперь абстракция печати книги отделена от конкретных реализаций. В итоге и класс Book и класс
 ConsolePrinter зависят от абстракции IPrinter. Кроме того, теперь мы также можем создать 
 дополнительные низкоуровневые реализации абстракции IPrinter и динамически применять их в программе

Book book = new Book(new MyConsolePriniter());

book.Print();

book.Printer = new MyHtlPrinter();

book.Print();

==========================================


--Паттерны програмирования--patterns--
------------------------------------------
--основные понятия для паттернов

------------------------------------------
--Наследование 

позволяет одному классу (наследнику) унаследовать функционал другого класса (родительского). 
Нередко отношения наследования еще называют генерализацией или обобщением. 
Наследование определяет отношение IS A, то есть "является". Например менеджер ЯВЛЯЕТСЯ юзером:

class User
{
    public int Id { get; set; }
    public string Name { get; set; }
}
 
class Manager : User
{
    public string Company{ get; set; }
}

------------------------------------------
--Реализация 
предполагает определение интерфейса и его реализация в классах
(это контракт что какой-то определенный тип обязательно реализует некоторый функционал). 
Например, имеется интерфейс IMovable с методом Move, который реализуется в классе Car 
:

public interface IMovable
{
    void Move();
}
public class Car : IMovable
{
    public void Move()
    {
        Console.WriteLine("Машина едет");
    }
}
public class Horse : IMovable
{
    public void Move()
    {
        Console.WriteLine("Лошадть скачет");
    }
}
------------------------------------------
--Ассоциация 
это когда один класс включает в себя другой класс в качестве одного из полей. 
Ассоциация описывается словом «имеет».  имеет двигатель. 
Например, объект одного типа содержит или использует объект другого типа. Например,
игрок играет в определенной команде:

class Team
{
 
}
class Player
{
    public Team Team { get; set; }
}

Нередко при отношении ассоциации указывается кратность связей. 
В данном случае единица у Team и звездочка у Player на диаграмме отражает связь 1 ко многим. 
То есть одна команда будет соответствовать многим игрокам.

------------------------------------------
--Композиция 
определяет отношение HAS A, то есть отношение "имеет". Например, в класс автомобиля 
содержит экземпляр класса электрического двигателя, умирает автомобиль умирает и двигатель:

public class ElectricEngine
{ }
 
public class Car
{
    ElectricEngine engine;
    public Car()
    {
        engine = new ElectricEngine();//это копмозиция, при каждом создании экземпляра типа car мы через
        // констркутор создаем экземпляр класса ElectricEngine,каждой отдельной машине по отдельному движку
    }
}
При этом класс автомобиля полностью управляет жизненным циклом объекта двигателя. 
При уничтожении объекта автомобиля в области памяти вместе с ним будет уничтожен и объект двигателя. 
И в этом плане объект автомобиля является главным, а объект двигателя - зависимой.
в даном примере двигател не может сущетсвовать отдельно от автомобиля
------------------------------------------
--Агрегация 
От композиции следует отличать агрегацию. Она также предполагает отношение HAS A,
когда умрет автмобиль engine может жить дальше, и реализуется она иначе

public abstract class Engine
{ }
 
public class Car
{
    Engine engine;//обьявляем обьььект те создаем его
    public Car(Engine eng)
    {
        engine = eng;//присваиваем ссылку на созданый обьект
    }
}

При агрегации реализуется слабая связь, то есть в данном случае объекты Car и Engine будут равноправны. 
В конструктор Car передается ссылка на уже имеющийся объект Engine. 
И, как правило, определяется ссылка не на конкретный класс, а на абстрактный класс или интерфейс, 
что увеличивает гибкость программы.
------------------------------------------
виды паттернов
--
--Порождающие паттерны

Эти паттерны отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.

--Абстрактная фабрика (Abstract Factory)
------------------------------------------
задает иинтерфейс создания всех доступных типов продуктов, а каждая конкретная реализация фабрики порождает продукты 
одной из вариаций, клиентский код вызывает методы фабрики для получения продуктов, вместо самостоятельного создания 
с помощью оператора new, при этом сама фабрика следиит за тем чтобы создать продукт нужной вариации

когда использовать - когда система не должна зависет от способа создания и компоновки новых обьектов
- когда создаваемые обьекты долджны исопльзоватся вместе и явщяютсся взаимосвязанными

прооблема - в электронном магазине - продаются резистор конденсатор предохранитель ,
есть несолько вариаций этих  элементов например стили Smd и Dip

задача - найти способ создавать элементы чтобы они сочетались с другими элементами по признаку Smd/Dip, можно
вносить изменения в существующий код при добавлении новых элементов или семейств(например Sod) в магазин.

решение - создать общие интерфейсы для отдельных продуктов конденсатор, резистор, предохранитель

namespace Pattern;

//интерфейс абстрактной фабирки обьявляет набор методов 
public interface IAbstractFactory
{
    //эти методы возвращают асбтарктные резисторы и тд.эти методы называются семеством и связаны одной темой 
    //(в данном случае все это радиоэлменты), они могут взаимодейтсовать между собой и иметь вариации
    //(в данном случае резисторы конденсаторы и предохранители несовместимы)
    IAbstractResistor CreateResistor();
    IAbstractCapacitor CreateCapacitor();
    IAbstractFuse CreateFuse();
}

//конкретаня фабрика производит семейство элменетов одной вариации (в данном случае smd)
//фабрика гарнтирует совестимость полученых продуктов,
class FactorySmd : IAbstractFactory
{
    //методы фабрики возварщаюст абстакртные элменты,
    public IAbstractCapacitor CreateCapacitor()
    {
        //при этом внутри мтеода создается экз конкретного элемента(в данном случае SmdCapacitor)
        return new SmdCapacitor();
    }

    public IAbstractResistor CreateResistor()
    {
        return new SmdResistor();
    }

    public IAbstractFuse CreateFuse()
    {
        return new SmdFuse();
    }
}

//каждая вариация фабрикии имеет соответвующую вариацию продукта (те FactorySmd - SmdCapacitor и др,
//а FactoryDip - DipCapacitor)
class FactoryDip : IAbstractFactory
{
    public IAbstractCapacitor CreateCapacitor()
    {
        return new DipCapacitor();
    }

    public IAbstractResistor CreateResistor()
    {
        return new DipResistor();
    }

    public IAbstractFuse CreateFuse()
    {
        return new DipFuse();
    } 
}
#region каждый отдельный элемент семейства должен иметь базовый интрефейс, все вариаци элмента реализуют этот интерфейс 
public interface IAbstractResistor
{
    string Type(string type);
}

//все продукты могут взаимодействать друг с другом но правильное возмонжно только между одной 
//и той же вариацией например Smd
public interface IAbstractCapacitor
{
    //IAbstractCapacitor способен работать самостоятельно...
    string Type(string type);
 //...но также и взаимодействовать с прдуктами Fuse той же вариации те например Smd 
    string AnotherUsefulType(IAbstractFuse collaborator);
}

public interface IAbstractFuse
{
    string Type(string type);
}

#endregion

#region конкретные элементы создаются соответсующими фабриками эти будут созданы с помощью DipFactory

class DipFuse : IAbstractFuse
{

    public string Type(string type)
    {
        return "Это предохранитьель в dip корпусе";
    }
}

class DipResistor : IAbstractResistor
{

    public string Type(string type)
    {
        return "Это резистор в dip корпусе";
    }
}

class DipCapacitor : IAbstractCapacitor
{

    public string Type(string type)
    {
        return "Это конденсатор в dip корпусе";
    }

    //элемент DipCapasitor может работать корректно только с DipFuse темнеменее он принимает любой экземпляр 
    //IAbstractFuse в качестве аргумента
    public string AnotherUsefulType(IAbstractFuse collaborator)
    {
        var result = collaborator.Type("");
        return $"Это коллаборация DipCapasitor и {result}";
    }
}


#endregion

#region конкретные элементы создаются соответсующими фабриками эти будут созданы с помощью SmdFactory 

class SmdFuse : IAbstractFuse
{

    public string Type(string type)
    {
        return "Это предохранитель в smd корпусе";
    }
}

class SmdResistor : IAbstractResistor
{

    public string Type(string type)
    {
        return "Это резистор в smd корпусе";
    }
}

class SmdCapacitor : IAbstractCapacitor
{

    public string Type(string type)
    {
        return "Это конденсатор в smd корпусе";
    }

    //элемент SmdCapasitor может работать корректно только с SmdFuse темнеменее он принимает любой экземпляр 
    //IAbstractFuse в качестве аргумента
    public string AnotherUsefulType(IAbstractFuse collaborator)
    {
        var result = collaborator.Type("");
        return $"Это коллаборация DipCapasitor и {result}";
    }
}

#endregion

public class Client
{
    //фабрика записаная сюда будет решать какой тип элмента(Smd или Dip) вернут ее методы
    public void ClientMethod(IAbstractFactory factory)
    {
        var capacitor = factory.CreateCapacitor();
        var fuse = factory.CreateFuse();
        var resistor = factory.CreateResistor();

        Console.WriteLine(capacitor.Type(""));
        Console.WriteLine(capacitor.AnotherUsefulType(fuse));
        Console.WriteLine(resistor.Type(""));
    }
}


using Pattern;

Client client = new Client();
// Клиентский код может работать с любым конкретным классом фабрики.

client.ClientMethod(new FactorySmd());
Console.WriteLine();

client.ClientMethod(new FactoryDip());


Это конденсатор в smd корпусе
Это коллаборация DipCapasitor и Это предохранитель в smd корпусе
Это резистор в smd корпусе

Это конденсатор в dip корпусе
Это коллаборация DipCapasitor и Это предохранитьель в dip корпусе
Это резистор в dip корпусе

по сути: класс/интерфейс не содержащий собственной логики(public interface IAbstractFactory),
все его методы (IAbstractResistor CreateResistor(),
IAbstractCapacitor CreateCapacitor(),IAbstractFuse CreateFuse()) возварщают экземпляры других 
интерфейсов(IAbstractResistor,IAbstractCapacitor,IAbstractFuse) и вызыываются внешними копонентами
(DipFuse и др). этот паттер позволяет подменив реализацию одногго иинтерфейса(IAbstractFactory), 
подменитиь набоор реализаций ограниченого множества интерфейсов(FactorySmd,FactoryDip). 

==

--Строитель (Builder)
это порождающий паттер проектировния, который позволяет создавать сложные обьекты пошаговою. 
дает возможность использовать один и тот же код строительства для получения разных представлений обьектов
- сложный обьект требующий кропотливой пошаговой инициализации множества полей
и вложеннх обьектов. 
код инициализации таких обьектов обычно спрятан внутри монструозногго констурктора с десятком параметров. 
либо, что еше хуже распылен по всему клиенсткеому коду. 

когда использовать - когда процесс создания нового объекта не должен зависеть от того, 
из каких частей этот объект состоит и как эти части связаны между собой
-когда необходимо обеспечить получение различных вариаций объекта в процессе его создания

прооблема - как создать объект дом, нужно соптаить 4 стены установить двери, всатвить пару окон и положить 
крышу. но чо если требутеся дом помбольше, имеющий сад, бассейн, джакузи и прочее добро.

!решение - расширить клас дом, создвая подклассы для всех комбинаций параметров дома, ПРОБЛЕМА такого 
решения это громадное колво классов которые придется создать. каждый новый парметр, вроде цвета обоев или 
материала кровли, заставит создать все больше и больше класов для перечисления всех восзможных вариантов.

!решение -  или можно создать гиганский констурктор с множеством парамтеров, но тогда придется в в случае
если например у дома нет басейна ставить в этот парамтер null

решение - можно вывести создаение обььекта за пределы его сообственного класса, поручив это отдельным
обьектам- строителям они разобьт контсруирование обьекта на отдельные шаги 
(построить стены, вставит двери и тд), чтобы моздадть обьект, нужно поочередно вызывать метооды строоителя.

причем можно запускат только те шаги которые нужна для производства дома текущей конфигурации.

приэтом даже один и тот же шаг строительства может иметь разные вариации
(деревяный дом - деревянные стены, кирпичный дом - кирпичные стены). в этом случае моожно создать несольтко
строитиелей выполняющих оддни и те же шаги по-разному. 

namespace Pattern;

//интерфейс или абстрактный класс обьявляет создающие методы для чайстей обьектов
//продуктов
public interface IBuilderPencil
{
    /// <summary>
    /// создаем стрержень
    /// </summary>
    public abstract void BuildShaft();

    /// <summary>
    /// создаем корпус 
    /// </summary>
    public abstract void BuildCase();

    /// <summary>
    /// создаем стриралку
    /// </summary>
    public abstract void BuildEraser();
}

//классы конкретного строителя следуют интерффейсу строителя и предоостявляют 
//конкретные реализаци шагов построения ваша программа должна иметь несолтко 
//вариантов строителелй реализованных по разному
public class BuilderPlasticPencil : IBuilderPencil
{
    //обьект каарндаша с которым будут производится манипуляции
    public Pencil pencil { get; private set; }

    //создать новый (пустой) экземпляр обьекта который мы будем строить с 
    // помощьью методов ниже
    public BuilderPlasticPencil()
    {
        CreatePencil();
    }

    //метод создающий новый экземпляр
    protected void CreatePencil()
    {
        pencil = new Pencil();
    }

    #region методы стротели для экземпляра класса который был создан выше

    public void BuildShaft()
    {
        pencil.Add("Shaft");
    }

    public void BuildCase()
    {
        pencil.Add($"Case in plastic");
    }

    public void BuildEraser()
    {
        pencil.Add("Earser");
    }

    #endregion

    //конкретный строители должны предоставит собственне методы получения результатов
    //изза того что различне типы строителей могут создавать соверщено разные продукты
    //с разными интерфейсами.
    
    //метод возварщающий результат - построенный обьект
    public Pencil GetPencil()
    {
        var result = pencil;
        //обычно ппосле возварщения результата клиенту, экземпляр строителя
        //должен быть готов к созданию нового продукта, но неообязательно
        CreatePencil();
        return result;
    }
}

public class BuilderWoodPencil : IBuilderPencil
{
    //обьект каарндаша с которым будут производится манипуляции
    public Pencil pencil { get; private set; }

    //создать новый (пустой) экземпляр обьекта который мы будем строить с 
    // помощьью методов ниже
    public BuilderWoodPencil()
    {
        CreatePencil();
    }

    //метод создающий новый экземпляр
    protected void CreatePencil()
    {
        pencil = new Pencil();
    }
    
    public void BuildShaft()
    {
        pencil.Add("Shaft");
    }

    public void BuildCase()
    {
        pencil.Add($"Case in wood");
    }

    public void BuildEraser()
    {
        pencil.Add("Earser");
    }

    public Pencil GetPencil()
    {
        var result = pencil;
        CreatePencil();
        return result;
    }
}

public class Pencil
{
    private List<string> pencilParts = new();

    public void Add(string shaft)
    {
        pencilParts.Add(shaft);
    }

    public string ListParts()
    {
        var str = string.Empty;

        for (int i = 0; i < pencilParts.Count; i++)
        {
            str += pencilParts[i] + ", ";
        }

        str = str.Remove(str.Length - 2);

        return $"Product parts {str} \n";
    }
}
//директор отвечает только за вполнение шагоов построения в определеной последовательности,
//и в опредлеенной конфигурации, он необязателен тк клиент сам может упралвятьб староителем
public class Director
{
    private IBuilderPencil builderPencil;

    public IBuilderPencil BuilderPencil
    {
        set => builderPencil = value;
    }
    //без ластика
    public void BuildWithoutEraser()
    {
        builderPencil.BuildShaft();
        builderPencil.BuildCase();
    }
    public void BuildEraser()
    {
        builderPencil.BuildShaft();
        builderPencil.BuildCase();
        builderPencil.BuildEraser();
    }
}



//клиентский код создает обьекты строители
var pencilWoodBuilder = new BuilderWoodPencil();

var pencilPlasticBuilder = new BuilderPlasticPencil();
//создает обьект диерктора
var pencilDirector = new Director();
//затем передает нужный обьект стротеля директору
pencilDirector.BuilderPencil = pencilPlasticBuilder;
//и далее диреткор используя предустановки строит определеный карандаш
pencilDirector.BuildEraser();
Console.WriteLine(pencilPlasticBuilder.GetPencil().ListParts());

pencilDirector.BuilderPencil = pencilWoodBuilder;
pencilDirector.BuildWithoutEraser();
Console.WriteLine(pencilWoodBuilder.GetPencil().ListParts());

//так же можно вызывать класс строителя без использования директора
pencilWoodBuilder.BuildCase();
Console.WriteLine(pencilWoodBuilder.GetPencil().ListParts());

по сути: класс конструктора берет пустой обьект продукта, накидывает в него
элементы и озваращает клас с добавлеными элементами клиенту, так же может существоать класса
директора который отвечает за предустановаленные пресеты создания продуктов

==

--Фабричный метод (Factory Method)
------------------------------------------
порождающие паттерн проектирования, коотороый определяет общий интерфейс для созания обьектов(ITransport) через
асбтсрактный/вирутальный метод (public abstract ITransport Transport())в суперклассе(Logistic),
позволяя подклассам(SeaLogistic, AirLogistic) изменять тип создаваемых обьектов (SeaTransport ,AirTransport).

когда использовать - когда зарванее неизвестно обььекты каких типов нужно создавать
- когда система должна быть независимой от процесса создания новых обьектов и при этом расщиряемой
те в нее можно легко вводить новые классы обььекты которых система должна создаваться

проблема - есть система управления грузовыми перевозками сперва в ней превозятся тольько по морю
поэтому класс работает с оьбектами класса SeaTransport, вкакойто момент требуется добавить превозки по возуху

решение - паттерн фабричный метод созадет обьекты не напрямую исопльзуя оператор new  а через выбор особого
фабричногго метода, создавать обьчекты через new будет сам фабричный метод.

namespace Pattern;

//определяет интерфейс классов кторы надо создавать
public interface ITransport
{ 
    public string CompanyName { get; set; }
    void Operation();
    
}


//класссы ктороые надо создавать, предствлюящие рализацию класса Itransport их может быть множество
public class SeaTransport : ITransport
{
    public string CompanyName { get; set; }

    public void Operation()
    {
        Console.WriteLine($"Доставляется по морю, компанией {CompanyName}");
    }
    
}
//класссы ктороые надо создавать, предствлюящие рализацию класса Itransport
public class AirTransport : ITransport
{
    public string CompanyName { get; set; }

    public void Operation()
    {
        Console.WriteLine($"Доставляется по воздуху {CompanyName}");
    }
}

//этот абстакртный класс определяет абстарктный метод который возрващает обьекты интерфейса Transport
public abstract class Logistic
{
    protected Logistic(string name)
    {
        NameLogistic = name;
    }

    public string NameLogistic { get; }
    //этот метод возварщает бьекты интерфейса ITransport...
    public abstract ITransport Transport();
}

//класссы ктороые надо создавать, предствлюящие рализацию класса Logistic они определяют кажддый свою
//реализацию метода Transport(), причем метод Transport() кадждого отдельного класса создателя
//(в данном случае SeaLogistic) возварщает определенный тип продукта(в данном случае SeaTransport),
//для каждого конкретногго класса трансспорта определяется конкретный класс лигоистики
public class SeaLogistic : Logistic
{
    private string companyName;
    public SeaLogistic(string name) : base(name)
    {
        companyName = name;
    }

    public override ITransport Transport()
    {
        //SeaLogistic определяет какой конкретыный тип тракнспорта ему создаать
        var sea = new SeaTransport
        {
            CompanyName = companyName
        };
        return sea;
    }
}
public class AirLogistic : Logistic
{
    private string companyName;
    public AirLogistic(string name) : base(name)
    {
        companyName = name;
    }

    public override ITransport Transport()
    {
        var air = new AirTransport
        {
            CompanyName = companyName
        };
        return air;
    }
}
//определяем класс создателя
Logistic logistic = new SeaLogistic("морская 1");

//он определяет какой тип троанспорта вернется из метода
var transport = logistic.Transport();
//вызываем у опрееленногго транспорта его метод
transport.Operation();//Доставляется по морю, компанией морская 1

logistic = new AirLogistic("Воздушная 1");

var transport2 = logistic.Transport();

transport.Operation();//Доставляется по морю, компанией морская 1

по сути: есть некий класс (Logistic) ктороый выполняет свою специйфическую 
фкнцию(оперделяет какой вид трансорпта исопльзуется), часть своей функциональности он делегирует 
внешнему интерфейсу (public abstract ITransport Transport()) который инсталируется
через вирутальный или абстаркатный метод этоого класса. наследники этого класса(SeaLogistic,AirLogistic),
 перекрыв этот метод( public override ITransport Transport()) могут вернуть другие реализаци интерфейса,
 ( var air = new AirTransport), используемого основным алгоритмом класа.
==


--Прототип--Prototype--
порождающий паттерн проектирования который повзволяет скопировать обьектыы не вдаваясь в подробности 
их релаизации

когда использовать - когда конкретный тип создаваемого обьекта должен определятся динамически по время выполнения
-когда нежелятелно создание отдельнлой иерархии классов фабрик для создания обьектов продуктов из парельной иерархии
классов (как например в абстрактоной фабрике)
-когда клинирвание обьекта предпочтительнее нежели его создание и инициализация с помощью конструктора, особено 
когда известно что обьект может принимать неболььшое огранченное число возможных состояний. 


проблема - етсь обьект ктороый нужно скопировать,

!решение - для этого нужно создать пустой обьект тогоже класса и поочередно скпировать значения
полей из старого обьект в новый. ПРОБЛЕМА такого решения - не каждый обьект удастся скопировать
таким образом, ведь часть состояния может быть привятной, а значит недоступной для остального кода программы,
ПРОБЛЕМА так же копирующий код станет заувисим от класов копируемых обьектов, ведь чтобы перебрать все поля
обьекта нужно привязаться к его классу. изза этого вы не сможете кпировать обьекты зная только их интерфейсы,
а не конкретные класы, также Поскольку классы представляют ссылочные типы,
 то это накладывает некоторые ограничения на их использование. В частности


  Person p1 = new Person { Name = "Tom", Age = 23 };
            Person p2 = p1;//p2.Name = "Tom" В данном случае объекты p1 и p2 будут указывать на один и тот же объект 
            //в памяти,поэтому изменения свойств в переменной p2 затронут также и переменную p1.
            p2.Name = "Alice";//как толлько имя запишется по ссылке в оьект р2 оно запишется так же и в обьект р1
            // тк у них сейчас один адреc, чтобы этого избежать может исопльзоватся копирование оьектов ссылочного 
            //типа (с сохранением всех даннных первоначального обьекта)
            Console.WriteLine(p1.Name); // Alice


решение - прототип поручает создание копий самим копиируемым обьектам. он выводит общий интрефейс для всех обьектов
пооддерживающих клонироовения. это позволяет копировть обьекты не привязвыясь к их кнкретнм классам. олбычно такон
интефрейа имеет всего один мето Clone()

использование клонирвания

Чтобы переменная p2 указывала на новый объект, но со значениями из p1,
 мы можем применить клонирование с помощью реализации интерфейса ICloneable:


      
    
    public interface ICloneable //Чтобы переменная p2 указывала на новый объект, но со значениями из p1,
    // мы можем применить клонирование с помощью реализации интерфейса ICloneable
    {
        object Clone();
    }

    class Person
    {

        public string Name { get; set; }
        public int Age { get; set; }
    }
//неглубокое копирование
    class SurfacePerson : ICloneable//реализуем интерфейс 
    {
        
        public string Name { get; set; }//Поверхностное копирование работает только для свойств, 
        //представляющих примитивные типы
        public int Age { get; set; }

        public Company Work { get; set; }//в случае если реализуетсся неглубокое копирвание 
        //В этом случае при копировании новая копия будет указывать на тот же объект Company

        public object Clone()
        {
            return this.MemberwiseClone();//добавляем специальный метод MemberwiseClone(), который возвращает копию объекта,
                                          //но этот метод реализует неглубокое копирование 
        }
    }
//глубокое копирование
    class DeepPerson : ICloneable//реализуем интерфейс 
    {
        public string Name { get; set; }
        public int Age { get; set; }
        public Company Work { get; set; }

        public object Clone()//пр использовании метода клон мы...
        {
            
            Company company = new Company { Name = this.Work.Name };//...вмемсто использоваания метода MemberwiseClone 
            //мы при создании DeepPerson экземмпляраа создаем новый экземпляр сложного типа и копируем туда
            // название поля из DeepPerson.Work...


            return new DeepPerson
            {//.. далее мы при создании экземмпляраа DeepPerson создаем новый экземпляр DeepPerson со СКОПИРИОВАНЫМИ 
                //туда значениями из этого экземпляра,далее в Work мы записываем КОПИЮ из первоначального экземпляра,
                //чтобы потом ее эту КОПИЮ можно было поменят не за рагивая ОРИГИНАЛ
                Name = this.Name,
                Age = this.Age,
                Work = company
            };
        }
    }

    class Company
    {
        public string Name { get; set; }
    }

//неглубокое (поверхсностоне копировние)
SurfacePerson p3 = new SurfacePerson { Name = "Tom", Age = 23, Work = new Company { Name = "Microsoft" } };
SurfacePerson p4 = (SurfacePerson)p3.Clone();
p4.Work.Name = "Google";
p4.Name = "Alice";
Console.WriteLine(p3.Name);//здес MemberwiseClone СРАБОТАЛ тк name это простой тип -> Tom 
Console.WriteLine(p3.Work.Name);//здес MemberwiseClone НЕ сработал тк name это сложный тип -> 
//Google - а должно быть Microsoft

//глубоуоке копирование
DeepPerson p5 = new DeepPerson { Name = "Tom", Age = 23, Work = new Company { Name = "Microsoft" } };
DeepPerson p6 = (DeepPerson)p5.Clone();
p6.Work.Name = "Google";
p6.Name = "Alice";
Console.WriteLine(p5.Name); // Tom
Console.WriteLine(p5.Work.Name); //Microsoft

Console.Read();


или так (более наглядно)
--

using System.Dynamic;

namespace Pattern;

public class Person
{
    public int Age;
    public DateTime BrithDate;
    public string Name;
    public IdInfo IdInfoPerson;
    private int indexPerson;

    public void SetIndex(int index)
    {
        indexPerson = index;
    }
    public int GetIndex()
    {
        return indexPerson;
    }
    //неглубокое копирование 
    public Person ShallowCopy()
    {
        //рабоотает только для примитивыных типов вроде int, string и тд
        return (Person) MemberwiseClone();
    }

    //глубокое клонирование
    public Person DeepCopy()
    {
        var clone = (Person) MemberwiseClone();
        clone.IdInfoPerson = new IdInfo(IdInfoPerson.IdNum);
        clone.Name = Name;
        return clone;
    }
}

public class IdInfo
{
    public int IdNum;

    public IdInfo(int idNum)
    {
        IdNum = idNum;
    }
}




using System.Threading.Channels;
using Pattern;

Person p1 = new Person();
p1.Age = 10;
p1.BrithDate = Convert.ToDateTime("2000-01-01");
p1.Name = "Max";
p1.IdInfoPerson = new IdInfo(34);
p1.SetIndex(100700);

var p2 = p1;
var p3 = p1.ShallowCopy();
p1.Age = 20;
p1.IdInfoPerson.IdNum = 10;
p1.SetIndex(400300);
Console.WriteLine(p2.Age);//p2 берет данные няпрямую по ссылке потоому ту будет 20
Console.WriteLine(p2.GetIndex());//400300
Console.WriteLine(p3.Age);//p3 клинирует данные потоому ту будет 10
Console.WriteLine(p3.GetIndex());//100700
Console.WriteLine(p3.IdInfoPerson.IdNum);//но при этом используя негулобокое клонирование даные из подклассов 
//р3 будет брать по ссылке на них
var p4 = p1.DeepCopy();
p1.IdInfoPerson.IdNum = 49;//изменим значение в подкласе на 49
Console.WriteLine(p3.IdInfoPerson.IdNum);//49
Console.WriteLine(p4.IdInfoPerson.IdNum);//р4 исполььзуя глубокое клоонирование здесь получит 10


так же можно использовать сериализацию
--

Product product = new Product();
product.Name = "Apple";
product.ExpiryDate = new DateTime(2008, 12, 28);
product.Price = 3.99M;
product.Sizes = new string[] {"Small", "Medium", "Large"};
//копируем класс в json строку
var jsonStingInProduct = JsonConvert.SerializeObject(product);
//получаем его обратно в виде типа записаного в <T>
var productClone = JsonConvert.DeserializeObject<Product>(jsonStingInProduct);

productClone.Name = "Max";
Console.WriteLine(product.Name);//Apple
Console.WriteLine(productClone.Name);// Max


--singleton--одиночка
------------------------------------------
Создает единственный экземпляр своего класса и обеспечивает доступ к нему. 
Гарантирует существование единственного экземпляра.

Например ведение отладочной информации, реализация сессий, кэш приложения, менеджер печати, доступ к аппаратному 
обеспечению.

--минусы 
-Многие части приложения становятся зависимы от него и, косвенно, друг от друга. Это усложняет внесение изменений в д
альнейшем. Облегчить ситуацию можно используя Внедрение зависимостей.

-Приложение становится сложнее тестировать, т.к. данные, полученные от Одиночки, могут быть созданы в другом модуле.
==

--Альтернативой Одиночке является статический класс, который имеет следующие ограничения

-он не может быть наследником других классов и реализовывать интерфейсы;
-нельзя создать экземпляр статического класса. Следовательно, его невозможно использовать в качестве параметра или 
возвращаемого значения.
-статический класс нелзя сериализовать.

--Как видно из описания, Одиночка является более универсальным решением. 
Но если необходимо просто собрать ряд методов "под одной крышей", то для такой задачи лучше подходит статический класс.
==

public sealed class Service<T> where T : class
{
    static T _instance;

    /// <summary>
    /// Gets global instance of T type.
    /// </summary>
    /// <param name="createIfNotExists">If true and instance not exists - new instance will be created.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Get(bool createIfNotExists = true)
    {
        if (_instance != null)
        {
            return _instance;
        }
        if (createIfNotExists)
        {
            //Создает экземпляр указанного типа, используя конструктор этого типа без параметров.
            _instance = (T)Activator.CreateInstance(typeof(T), true);
        }
        return _instance;
    }

    /// <summary>
    /// Sets global instance of T type.
    /// </summary>
    /// <param name="instance">New instance of T type.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Set(T instance)
    {
        _instance = instance;
    }
}

class MyFancyObject
{
    public int A { get; set; }
    public int b { get; set; }

    public void Get()
    {
        Console.WriteLine($"{b} + {A}");
    }
}

 class Program
{
   
    static void Main(string[] args)
    {
        MyFancyObject mFO1 = new();
        MyFancyObject mFO2 = new();

        mFO1= Service<MyFancyObject>.Get();
        mFO1.A = 10;
        mFO1.b = 122;
        mFO1.A = 18;
        mFO1.Get(); //122 + 18

        mFO2 = Service<MyFancyObject>.Get();
        mFO2.A = 1;
        mFO2.b = 21;
        mFO2.A = 90;
        с.Get();//21 + 90 
        mFO1.Get();//21 + 90 - значния в обьекте mFO1 становятся аналогичны значениям из mFO2 
        //что отражает концепцию синглтона
    }
}

--Multition--мультитон--Пул одиночек
------------------------------------------
https://andrey.moveax.ru/post/patterns-oop-creational-multiton
Шаблон "Пул одиночек" позволяет создать определенное число своих экземпляров и предоставляет точку доступа для работы
с ними. 
При этом каждый экземпляр связан с уникальным идентификатором.

Число экземпляров класса может (и даже должно) быть ограничено и они глобальные для всего приложения.

public class Multition
{
    //экземпляры класса хранятся в контейнере instance
    private static readonly ConcurrentDictionary<int, Multition> Instance =
        new ConcurrentDictionary<int, Multition>();

    private int i = 0;

    //создать самостоятельно экземпляр не возможно, т.к. конструктор закрыт
    private Multition(int key)//на конструктор возложена обязанность создавать экземпляры в зависимости от индентификатора int key
    {

    }

    // метод GetInstance() возвращает экземпляр по указанному ключу.
    public static Multition GetInstance(int key)
    { 
        //При этом вызываемый им метод GetOrAdd() проверяет есть ли готовый объект в контейнере и, если такой не найден, создает новый.
        return Multition.Instance.GetOrAdd(key, (mul) => new Multition(mul));
    }

    public void Do(int id)
    {
        i += 1;
        Console.WriteLine($"id - {id} Do = {i}");
    }
}

public class MyClass
{
    //Остается добавить в класс нужную функциональность и использовать его в деле
    public Multition Multition1 = Multition.GetInstance(1);
    public Multition Multition2 = Multition.GetInstance(2);

    public void UsingMultition()
    {
        Multition1.Do(1);// id - 1 Do = 1
        Multition2.Do(2);// id - 2 Do = 1
    }
}

class Program
{

    static void Main(string[] args)
    {
        MyClass mc = new MyClass();
        mc.UsingMultition();

        mc.Multition2.Do(2);// id - 2 Do = 2
        mc.Multition1.Do(1);// id - 1 Do = 2
    }
}

==========================================


--Паттерны структурные--
------------------------------------------

--Адаптер
------------------------------------------
позволяет обьектам с несовместимыми интерфейсами рабоать вместе, адаптируя определеннй класс под целевой
дабы класс клиента мог рабоаоть с этим определенным классом

когда использовать - когда необходим исполььзовать имеющийся клас но его интерфейс не соответвует потребностям
-когда надо исоплльзоват уже сущетвующий класс совместно с другими классами, интерфейсы которыйх несовместимы

проблема - . Допустим, у нас есть путешественник, который путешествует на машине. 
Но в какой-то момент ему приходится передвигаться по пескам пустыни, где он не может ехать на машине.
 Зато он может использовать для передвижения верблюда. Однако в классе путешественника использование 
класса верблюда не предусмотрено, поэтому нам надо использовать адаптер

решение- В данном случае в качестве клиента применяется класс Driver, который использует объект ITransport.
 Адаптируемым является класс верблюда Camel, который нужно использовать в качестве объекта ITransport. 
 И адптером служит класс CamelToTransportAdapter.

//интерфейс к которому нужно будет привети вреблюда чтобы он смог быть вызван в драйвере
//(класс клиент) для реализации своих задач
interface ITransport
{
    void Drive();
}
// класс машины который перначально используется клиентом(драйвер реализует метод драйв)
class Auto : ITransport
{
    public void Drive()
    {
        Console.WriteLine("Машина едет по дороге");
    }
}
//в классе драйвер не предусмотрено использование верблюда, потому необходимо исопльзовать адаптер
class Driver
{
    //вызываем метод драйв у транспорта
    public void Travel(ITransport transport)
    {
        transport.Drive();
    }
}
// интерфейс животного
interface IAnimal
{    void Move();
}
// класс верблюда  (не подходит для реализации в классе драйвер без
// использоваания адаптера или изменеия самого класса драйвер)
class Camel : IAnimal
{
    //если машина ежет то верблюд идет
    public void Move()
    {
        Console.WriteLine("Верблюд идет по пескам пустыни");
    }
}
// Адаптер от Camel к ITransport (создаем класс котороый использует класс верблюда и
// реализует интерфейс ITransport) те просто позволяет рабоотать с обьектами верблюлда как с обьектами авто
class CamelToTransportAdapter : ITransport
{
    IAnimal camel;
    public CamelToTransportAdapter(IAnimal c)
    {
        camel = c;
    }
    
    //подменяем функционал райв на мов в случае верблюда
    public void Drive()
    {
        camel.Move();
    }
}


using System.Threading.Channels;
using Pattern;

Driver driver = new Driver();
//авто
ITransport auto = new Auto();
//драйвер использует обььекты авто для ралиазации задачи перемещения
driver.Travel(auto);
//верблюд
IAnimal camel = new Camel();
//не удается преборазовать IAnimal в Itransport
//driver.Travel(camel);

//адаптируем интерфейс верблюда(IAnimal) в интерфейс транспорта (ITransport) чтобы 
//драйвер мог исопльзовать его
ITransport camelAdapter = new CamelToTransportAdapter(camel);
//теперь драйвер может исопльзовать адаптированый под него класс верблюда
driver.Travel(camelAdapter);


--Мост
------------------------------------------
рездаеляет один или несолько классов на две отдельные иерархии - абстракцию и реализацию, позволяя изменят
их независимо друг от друга. паттерн обьявляет классыы абстакиций и реализаций в отдельных палаельных иерархиях
классов.

Асбтракция это образнй слой управления чемто(напрмиер графический интерфейс программы), он не делает работу 
самостооятельно, а делегирует ее слою Реализации(например АРI). 

Даже если мы отделим абстракцию от конкретных реализаций, то у нас все равно все наследуемые классы будут 
жестко привязаны к интерфейсу, определяемому в базовом абстрактном классе. Для преодоления жестких связей и служит 
паттерн Мост.

когда использовать - когда надо избежать постоянной привязки абстаркции к реализации
-когда наряду с реализацией надо измеять и асбтсракцию независимо друг от друга. те изменения в абстаркции не должн 
привести к измненеиям в реализации.

проблема есть класс приборов который имеет подклассы блок питания и вольтметр, нужно раширить иерархию приборов по 
внешним интерфейсам например com и ethernet, нго чтобы это обьеденить придется создать 4 комбинации подклассов
вроде SupplyCom и SupplyEthenet при добавлении новых устройств и интерфейсов колво кобминаций будет расти

корень прооблемы в том что пытаемся расширить классы приборов сразу в двух независимых плоскосях - по виду и по
интерфейсу именно это и приводит к разрастанию дерева классов

решение - мост предлагает заменить наследование аагрегацией или композицией. для этого нужно выделить одну из 
независимых плоскойсте (вид приборов или их интерфейс)в отдельную  иеразрхию и ссылатся на обьект этой иерархии, вместо
хранения его состояния и поведения внутри одного класса.

таки образов можно сдлеать интерфейс отдельным классом с подкласами ком и юзернет. класс приборов полчит ссылку на 
обьект цвета и асмотжет делегировать ему работу если потербуется. такая связь станет мостом между приборами 
и интерфейсами


namespace Pattern;

public interface IOutConnector
{
    string OutConnectorConnect();
}

class RectangleConnector : IOutConnector
{
    public string OutConnectorConnect()
    {
        return "Rectangle connector";
    }
}

class OvalConnector : IOutConnector
{
    public string OutConnectorConnect()
    {
        return "Oval connector";    
    }
}
//реализация(IConnectInterface) задает общий интерфейс для всех своих реализаций(ComInterface,GpioInterface и др),
//все мтоды которые здесь описны будут доступны классау абтсракции(Device) и всех ее поддклассов(Supply и VoltMeter)
//описывает интерфейс подключения
public abstract class ConnectedInterface
{
    protected IOutConnector outConnector;

    protected ConnectedInterface(IOutConnector outConnector)
    {
        this.outConnector = outConnector;
    }

    public abstract void Connect();
    public abstract void SendData();
}

//конкретная реализация
//описывает какие интерфейсы подключения
class GpioInterface : ConnectedInterface
{
    //содержит платформозависимый код
    public override void Connect()
    {
        Console.WriteLine($"Conect to gpio {outConnector.OutConnectorConnect()}");
    }

    public override void SendData()
    {
        Console.WriteLine($"Send data to gpio ");
    }

    public GpioInterface(IOutConnector outConnector) : base(outConnector)
    {
    }
}
//конкретная реализация
//описывает какие интерфейсы подключения
class ComInterface : ConnectedInterface
{
    //содержит платформозаписимый код
    public override void Connect()
    {
        Console.WriteLine($"Conect to comport {outConnector.OutConnectorConnect()}");
    }

    public override void SendData()
    {
        Console.WriteLine($"Send data to comrort ");
    }

    public ComInterface(IOutConnector outConnector) : base(outConnector)
    {
    }
}
//конкретная реализация
class EthernetInterface : ConnectedInterface
{
    public override void Connect()
    {
        Console.WriteLine($"Conect to ethernet {outConnector.OutConnectorConnect()}");
    }

    public override void SendData()
    {
        Console.WriteLine($"Send data to ethernet ");
    }

    public EthernetInterface(IOutConnector outConnector) : base(outConnector)
    {
    }
}

//Abstraction(Абстракция) определяет базовыфй интерфейс и хранит ссылку на обьект Implementor(Реализатор)
//выполонение операций в абстракции делегируется методам обьекта реализатора
//описыывает девайс
public abstract class Device
{
    //обьект реализатора (характеристика абстрактный интерфейс подключения)который 
    protected ConnectedInterface connectedInterface;
    public ConnectedInterface ConnectedInterface
    {
        set => connectedInterface = value;
    }
    
    /// <summary>
    /// консткрутор для абстрации
    /// </summary>
    /// <param name="connectedInterface">сюда записиывается обьект реализатора</param>
    protected Device(ConnectedInterface connectedInterface)
    {
        this.connectedInterface = connectedInterface;
       
    }

    //здесь происходити выполннение операций из реализатора 
    public virtual void DoWork()
    {
        connectedInterface.Connect();
        connectedInterface.SendData();
    }
    public abstract void ReceiveData();
}

//расширеные абстракции содержат различные вариаци управляющей логики
//работаео с реализациями через общий интерфей реализации
//описывает какие девайсы
public class Supply : Device
{
   

    public override void ReceiveData()
    {
        Console.WriteLine("resieve data about supply");
    }

    public Supply(ConnectedInterface connectedInterface) : base(connectedInterface)
    {
    }
}
//оописывает какие девайсы
public class VoltMeter : Device
{
  

    public override void ReceiveData()
    {
        Console.WriteLine("resieve data about voltage");
    }

    public VoltMeter(ConnectedInterface connectedInterface) : base(connectedInterface)
    {
    }
}


IOutConnector outConnectorOval = new OvalConnector();
ConnectedInterface connectedInterfaceComOval = new ComInterface(outConnectorOval);
Device deviceSupply = new Supply(connectedInterfaceComOval);
deviceSupply.DoWork();
deviceSupply.ReceiveData();

//чтобы добаивитьь новый интерф подключения досатоочно просто присвоить в класс 
//deviceSupply новый интерфейс 
deviceSupply.ConnectedInterface = new EthernetInterface(new RectangleConnector());
deviceSupply.DoWork();
deviceSupply.ReceiveData();


Device deviceVolt = new VoltMeter(new EthernetInterface(new OvalConnector()));
deviceVolt.DoWork();
deviceVolt.ReceiveData();

IOutConnector outConnectorRectangle = new RectangleConnector();
ConnectedInterface connectedInterfaceGpioRectangle = new GpioInterface(outConnectorRectangle);
deviceVolt.ConnectedInterface = connectedInterfaceGpioRectangle;
deviceVolt.DoWork();
deviceVolt.ReceiveData();

// Conect to comport Oval connector
//Send data to comrort
//resieve data about supply
//Conect to ethernet Rectangle connector
//Send data to ethernet
//resieve data about supply
//Conect to ethernet Oval connector
//Send data to ethernet
//resieve data about voltage
//Conect to gpio Rectangle connector
// Send data to gpio
// resieve data about voltage

--компоновщик
------------------------------------------
группирует множество обьектов в древовидную структуру, а затем работать с этий стуркуторй как с одним обьектом
имеет смысл только когда основная модель программы может быть сконструирована в виде дерева ветка и лист

проблема: напрмииер два обьекта: продукт и коробка или ветка и лист - 
коробка может содержать несолькоко обьектов и коробок поменьше, а корбки поменьше может содержат либо продукты
 либо коробки поменье и тд

предположим продукты и коробки могут быть частью заказов. каждый заказ может содержать как простые продукты без 
уппаковки так и составные коробки

задача: узнать цену всех товаров в этой конструкции, если решать в лоб то потребуется открывть
все корбки заказа и посчитать их суммарную стоимость, это сложно тк типы коробок и их содержимое неизвестно
так же как и колво вложеностей коробок, тем самым циклом не выйдет


решение: компоновщик предлагает рассматриать продукт и коробкку через единый интерфейс с общим методом получения стоимости
продукт просто вернет свою цену, коробка спросит цену кажого предмента внутри себя и вренет сумму результатов. если один 
из внутренних предметов окается коробка помньше она так же начент перебирать свое содержимое и тд пока не будут
подсчитаны все составне части


namespace ConsoleApp1;

//базовый класс компонент обьявляет общие операции как для простых так и для
//сложных обьектов структуры
public abstract class Component
{
    public Component()
    {
    }

    //базовый обьект может см реалищиовывать каоето поведение по умолчанию
    //или поручить это конкретным классам обьявив метод содержащий повдение 
    //асбтрактным
    public abstract string Operation();

    //в нектороых случаях целесообразно определить операци управления потомкам
    //прямо в базовом классе Component. таки образом не нужно будет рпедоствлять
    //конкретные классы компнентов клиентсвому коду. недостаток в том что эти методы
    //будут пустыми для компонентов уровня листа
    public virtual void Add(Component component)
    {
        throw new NotImplementedException();
    }

    public virtual void Remove(Component component)
    {
        throw new NotImplementedException();
    }

//можно добавить метод дающий клиенсткому коду понять может ли компонет иметь
//вложнеые обьекты
    public virtual bool IsComposite()
    {
        return true;
    }
}

//класс LEaf преждставляет соой конечные бьекты структуры. лист не может
//иметь вложенных компонентов что и сигнализиурет IsComposite()
//обычно обьектые листеьв выполняют фактическую работы тогда как обьеты контейнер 
// только лишь деоегируют работу своим подкомпонентам(в данном пример листьям)
class Leaf : Component
{
    public override string Operation()
    {
        return "Лист";
    }

    //тк этот обьект претсавляет кончечные обьекты структуры он не может содержжать в себе
    //вложенные обьекты
    public override bool IsComposite()
    {
        return false;
    }
}

//Composite содержит в себе сложные компоненты которые могут иметь вложенные компоненты
//(в данном случае листы). обычно Compositе (контейнеры) делегируют фактическую работу
//своим детям а затем суммируют результат
class Composite : Component
{
    protected List<Component> Children = new();
    
    public override void Add(Component component)
    {
        Children.Add(component);
    }

    public override void Remove(Component component)
    {
        Children.Remove(component);
    }
    
    public override string Operation()
    {
        int i = 0;
        string result = "Ветка(";

        foreach (var component in Children)
        {
            result += component.Operation();
            if (i != Children.Count -1)
            {
                result += "+";
            }

            i++;
        }

        return result + ")";
    }
}

class Client
{
    // Клиентский код работает со всеми компонентами через базовый
    // интерфейс.
    public void ClientCode(Component leaf)
    {
        Console.WriteLine($"Результат {leaf.Operation()}\n");
        
    }

    // Благодаря тому, что операции управления потомками объявлены в базовом
    // классе Компонента, клиентский код может работать как с простыми, так
    // и со сложными компонентами, вне зависимости от их конкретных классов.
    public void ClientCode2(Component component1, Component component2)
    {
        //проверка на возможность хранвения в сеебе других элементов
        if (component1.IsComposite())
        {
            component1.Add(component2);
        }

        Console.WriteLine($"Результат {component1.Operation()}");
    }
}

--декоратор--Decorator--
------------------------------------------
позволяет динамически добавлять обьектам номую функциональность оборачивая их в полезные обертки, может далее снимать 
с обьектов эту функциональность, что наследование сделать не может
заменяет собой наследование, и так же может эмулировать множесвтено наследование. 

построен на принципе агрегации или композиции когда один обьект1 содеражит ссылку на другой обьект2 и делегирует обьекту2 
работу вемето наследования от обьекта2.
потому он и имеет альтернативное название обертка, помещаем целевой обьект2 в другой 
обьект1 обертку, потом обьект1 запускает базвоое поведение обьекта2, а затем обьект1 добавляет к результату полученому
из обьекта2 чтот свое.

Одним из способов обойти эти проблемы является замена наследования агрегацией либо композицией .
Это когда один объект содержит ссылку на другой и делегирует ему работу, 
вместо того чтобы самому наследовать его поведение. Как раз на этом принципе построен паттерн Декоратор.

Любая одежда — это аналог Декоратора. Применяя Декоратор, вы не меняете первоначальный класс и не создаёте дочерних
классов. Так и с одеждой — надевая свитер, вы не перестаёте быть собой, но получаете новое свойство — защиту от холода. 
Вы можете пойти дальше и надеть сверху ещё один декоратор — плащ, чтобы защититься и от дождя.

пробелма: есть библиотека оповещений которую можно полключать к разным программам, чтобы получать 
уведомления о важных событиях
Сторонняя программа должна создать и настроить этот объект, указав кому отправлять оповещения, 
а затем использовать его каждый раз, когда что-то случается пользователям через емейл. 
в один нужно добавить например в виде сообзщений в фейзбук или вк

Сначала вы добавили каждый из этих типов оповещений в программу, унаследовав их от базового класса Notifier. 
Теперь пользователь выбирал один из типов оповещений, который и использовался в дальнейшем.

Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу? 
Ведь если вдруг в вашем доме начался пожар, вы бы хотели получить оповещения по всем каналам, не так ли?

Вы попытались реализовать все возможные комбинации подклассов оповещений. 
Но после того как вы добавили первый десяток классов, стало ясно, что такой подход невероятно раздувает код программы.


решение: Сторонняя программа, выступающая клиентом, 
во время первичной настройки будет заворачивать объект оповещений в те обёртки, которые соответствуют желаемому способу 
оповещения.




using System.Reflection.Metadata.Ecma335;

public abstract class Person//определяет базовую функциональность
{
    public string Name { get; private set; }
    protected Person(string name)
    {
        Name = name;
    }
    public abstract string Dress();
    
}

// конкретная реализация компонента Person, в которую с помощью декоратора добавляется
// новая функциональность
public class PersonOne : Person
{
    public PersonOne(string name) : base(name)
    {
    }

    public override string Dress()
    {
        return $"{Name} одел штаны";
    }
}

// конкретная реализация компонента Person, в которую с помощью декоратора добавляется
// новая функциональность
public class PersonTwo : Person
{
    public PersonTwo(string name) : base(name)
    {
    }
    public override string Dress()
    {
        return $"{Name} одел трусы";
    }
}

//собственно декоратор, реализуется в виде абстрактного класса и имеет тот же базовый класс,
//что и декорируемые объекты. Поэтому базовый класс Person должен быть по возможности
//легким и определять только базовый интерфейс.
public abstract class PersonDecorator : Person
{
    //Класс декоратора также хранит ссылку на декорируемый объект в виде объекта базового
    //класса Component и реализует связь с базовым классом как через наследование,
    //так и через отношение агрегации.
    public Person MyPerson;
    protected PersonDecorator(string name, Person person) : base(name)
    {
        MyPerson = person;
    }
}

//Класс PersonPullover представляет дополнительную функциональность,
//которой должен быть расширен объект PersoneOe или PersoneTwo
public class PersonPullover : PersonDecorator
{
    public PersonPullover(Person person) : base(person.Name , person)
    {
    }

    public override string Dress()
    {
        return MyPerson.Dress() + ", одел свитер";
    }
}

//Класс PersonPullover представляет дополнительную функциональность,
//которой должен быть расширен объект PersoneOe или PersoneTwo
public class PersonShurt : PersonDecorator
{
    public PersonShurt(Person person) :  base(person.Name , person)
    {
    }

    public override string Dress()
    {
        return MyPerson.Dress() + ", одел рубашку";
    }
}



Person person2 = new PersonTwo("Lex");

Console.WriteLine(person2.Dress());//базовая функциональность (Lex одел трусы)


//добавляем новые обертки для класса, достаточно унаследовать от декоратора класс,
//который будет определять дополнительный функционал.
person2 = new PersonPullover(person2);
person2 = new PersonShurt(person2);


Console.WriteLine(person2.Dress());//Lex одел трусы, одел свитер, одел рубашку

---------------

namespace RefactoringGuru.DesignPatterns.Composite.Conceptual
{
    // Базовый интерфейс Компонента определяет поведение, которое изменяется
    // декораторами.
    public abstract class Component
    {
        public abstract string Operation();
    }

    // Конкретные Компоненты предоставляют реализации поведения по умолчанию.
    // Может быть несколько вариаций этих классов.
    class ConcreteComponent : Component
    {
        public override string Operation()
        {
            return "ConcreteComponent";
        }
    }

    // Базовый класс Декоратора следует тому же интерфейсу, что и другие
    // компоненты. Основная цель этого класса - определить интерфейс обёртки для
    // всех конкретных декораторов. Реализация кода обёртки по умолчанию может
    // включать в себя  поле для хранения завёрнутого компонента и средства его
    // инициализации.
    abstract class Decorator : Component
    {
        protected Component _component;

        public Decorator(Component component)
        {
            this._component = component;
        }

        public void SetComponent(Component component)
        {
            this._component = component;
        }

        // Декоратор делегирует всю работу обёрнутому компоненту.
        public override string Operation()
        {
            if (this._component != null)
            {
                return this._component.Operation();
            }
            else
            {
                return string.Empty;
            }
        }
    }

    // Конкретные Декораторы вызывают обёрнутый объект и изменяют его результат
    // некоторым образом.
    class ConcreteDecoratorA : Decorator
    {
        public ConcreteDecoratorA(Component comp) : base(comp)
        {
        }

        // Декораторы могут вызывать родительскую реализацию операции, вместо
        // того, чтобы вызвать обёрнутый объект напрямую. Такой подход упрощает
        // расширение классов декораторов.
        public override string Operation()
        {
            return $"ConcreteDecoratorA({base.Operation()})";
        }
    }

    // Декораторы могут выполнять своё поведение до или после вызова обёрнутого
    // объекта.
    class ConcreteDecoratorB : Decorator
    {
        public ConcreteDecoratorB(Component comp) : base(comp)
        {
        }

        public override string Operation()
        {
            return $"ConcreteDecoratorB({base.Operation()})";
        }
    }
    
    public class Client
    {
        // Клиентский код работает со всеми объектами, используя интерфейс
        // Компонента. Таким образом, он остаётся независимым от конкретных
        // классов компонентов, с которыми работает.
        public void ClientCode(Component component)
        {
            Console.WriteLine("RESULT: " + component.Operation());
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            Client client = new Client();

            var simple = new ConcreteComponent();
            Console.WriteLine("Client: I get a simple component:");
            client.ClientCode(simple);
            Console.WriteLine();

            // ...так и декорированные.
            //
            // Обратите внимание, что декораторы могут обёртывать не только
            // простые компоненты, но и другие декораторы.
            ConcreteDecoratorA decorator1 = new ConcreteDecoratorA(simple);
            ConcreteDecoratorB decorator2 = new ConcreteDecoratorB(decorator1);
            Console.WriteLine("Client: Now I've got a decorated component:");
            client.ClientCode(decorator2);
        }
    }
}


--Фасад--Facade
------------------------------------------
если коду приходится работать с большим колвом обьектов некой сложной билиотеки или фарймворка 
нужно самостоятльно инициализировать эти оьекты следаить за правильным порядком зависимостей и тд

когда исползовать -когда имеется сложная сисетма, и необходимо упростиь с ней работу. фасад позволит определеить
одну точку взаимодействия между клиентом и системой. - кода нужно уменшить колво зависимостей между клиентом и 
сложной ситемой, фасадные обьекты позволяют отоделить, изолировать копмпоненты системы от клиента и разививать и 
рабоатьа с ними независимо. -когда нужно определеить подсистемы компонентов с сложной системе. создание фасадов
каждой подсистеы что позволит упростить их взаимодействие и повысытиь независимость друг от друга.

namespace ConsoleApp1;

#region компоненты сложной системы с которой должен взаимодействоваьт клиен

public class TextEditor
{
    public void CreateCode()
    {
        Console.WriteLine("Создание кода");   
    }

    public void Save()
    {
        Console.WriteLine("Сохранение кода");   
    }
}

public class  Compiler
{
    public void Compile()
    {
        Console.WriteLine("Компиляция приложеиня");
    }
}

public class Clr
{
    public void Execute()
    {
        Console.WriteLine("Выполнение приложения");
    }

    public void Finish()
    {
        Console.WriteLine("Завершение работы приложения");
    }
}

#endregion

//фасад непосродсвенно ктороый представолят интерфей клинету для работы с компонентами
public class VisualStudioFacade
{
    private TextEditor textEditor;
    private Compiler compiler;
    private Clr clr;

    public VisualStudioFacade(TextEditor textEditor, Compiler compiler, Clr clr)
    {
        this.textEditor = textEditor;
        this.compiler = compiler;
        this.clr = clr;
    }

    public void Start()
    {
        textEditor.CreateCode();
        textEditor.Save();
        compiler.Compile();
        clr.Execute();
    }

    public void Stop()
    {
        clr.Finish();
    }
}

//взаимодействует со сложными компнентами подсистемы 
public class ClientProgrammer
{
    //взаимодействие через класс фасад который скрывает сложности реализации от
    //пользователя
    public void WorkInVisualStudio(VisualStudioFacade facade)
    {
        facade.Start();
        facade.Stop();
    }
}


TextEditor textEditor = new TextEditor();
Compiler compiler = new Compiler();
Clr clr = new Clr();

VisualStudioFacade ide = new VisualStudioFacade(textEditor, compiler, clr);
ClientProgrammer clientProgrammer = new ClientProgrammer();
clientProgrammer.WorkInVisualStudio(ide);


клиент может при необходимости обращаться напрямую к компонентам, например, отдельно от других компонентов 
использовать текстовый редактор. Но в виду сложности процесса создания приложения лучше использовать фасад. 
Также это не единственный возможный фасад для работы с данными компонентами. При необходимости можно создавать
альтернативные фасады также, как в реальной жизни мы можем использовать альтернативные среды разработки.

--поведенческие паттерны
------------------------------------------

--Цепочка обязанностей--Chain of responsibility--
------------------------------------------
позволяет ищбежать жесткой привязки отерпвителя запроса к получателю. все возможные обработчики запроса образуют 
цепочку, а сам запрос премещается по этой цепочке. каждый обьекит в этой цепочке при получении запроса выбирает,
либо закончить обработку запроса (если валидация не прошла например), либо передать запрос на обработку след
по цепочке обьекту.

когда применять - имеется больее одного обьекта, ктороый может обработать оперделнные запрос
-надо передать запрос на выполнение одному из неольких обьектов точно не определяя какому
-когда набор обьектов задается динамически

преимущества -ослаблление связанности между обьектами. отправителю и получателю запроса ничего не известно
друг о друге. клиенту неизвестна цепочка обьектов, какие именно обьекты составлюят ее как запрос в не ппередается

недодстатки -никто не гарантирует что запрос обработается в конечном счете. если необходимого обработчика
в цепочке не обазалось, то запрос просто выходит из цепочки и остается необработаным.






--наблюдатель--observer--издатель--подписчик--
------------------------------------------
исполььзует отношение один ко многим. в этом отношении есть один наблюдаемый обьект и множество наблюдателей.
и при изменении наблюдаемого обьекта автоматически происходит оповещение наблюдателей.

данный паттерн еще назыаеют издалель-подписчик, типа подписчики подписываются на мобытиие а издатель уведомляет
подпичсиков. получив изменение и производят опредленные действия. 

когда исполььзовать -когда система состоит из множества классов, обьктыы ктороых должны находится в согласовыных
состояниях.
-когда одна сторна рассылает собщения, а другая полчает эти сообщения и реагирует на них.
-когда существует один обььект рассылающий собщения и множество подписчиков кторые эти собщения получают. при этом
точно колво подписчиков неизвестно и в процесе работы программы колво подписчиков может изменятся.

//интерфейс наблюдаемого обьекта(издатель)
interface IObservable
{
    //для добавления наблюдателя(подписчика)
    void AddObserver(IObserver o);
    //удаление наблюдаетля
    void RemoveObserver(IObserver o);
    //увдедомление наблюдателей
    void NotifyObservers();
}
//конкретая реализация интерфейса наблюдаемого обьекта
class ConcreteObservable : IObservable
{
    //список наблюдателей
    private List<IObserver> observers;
    public ConcreteObservable()
    {
        observers = new List<IObserver>();
    }
 
    public void AddObserver(IObserver o)
    {
        observers.Add(o);
    }
    public void RemoveObserver(IObserver o)
    {
        observers.Remove(o);
    }
    public void NotifyObservers()
    {
        //проходим по списку наблюдателей и вызываеу м у каждого из них 
        //метод update
        foreach (IObserver observer in observers)
            observer.Update();
    }
}
//интерфейс наблюдателя
interface IObserver
{
    void Update();
}
//конкретные налюдателя
class ConcreteObserver :IObserver
{
    //конкретный метод кторый вызывается наблюдаемым обьектом(издателем)
    //для уведомления наблюдателя
    public void Update()
    {
    }
}

при этом наблюемому обьекту ничего знать о наблюдателях ненадо, кроме того что они реализуют
метод UPdate(). с помощью отношения агрегации реализуется слабая связь обоих компонентов.
изменения в наблюдаемом обьекте не влияют на наблюдателя и наоборот(только если наблюдаемый обьект не 
вызовет метод update как в случае выше).
наблюдаетль всегда может прекратиь наблюдение. и ппри этом обде эти сущности останутся сущетсовать 
независимо друг от друга.

--
//аналогично примеру сверху
public interface IObservable
{
    void AddObserver(IObserver observer);
    void Remove(IObserver observer);
    void NotifyObservers();
}

//аналогично примеру сверху
public interface IObserver
{
    //уведомляем подписчиков о изменении в классе цен на тполиво
    void Update(PriceFuelInfo storeInfo);
}
//издатель содержит список подписчиков ссылку на класс цен на топливо и метод имитацию изменения цен на топливо
public class StoreFuel : IObservable
{
    private List<IObserver> observers;
    private PriceFuelInfo priceInfo;
    public StoreFuel()
    {
        observers = new();
        priceInfo = new();
    }
    public void AddObserver(IObserver observer)
    {
        observers.Add(observer);
    }

    public void Remove(IObserver observer)
    {
        observers.Remove(observer);
    }

    public void NotifyObservers()
    {
        foreach (var observer in observers)
        {
            observer.Update(priceInfo);
        }
    }
//мимтация изменения цен на топливо
    public void FuelPrice()
    {
        Random rnd = new Random();
        priceInfo.PriceGas = rnd.Next(45, 50);
        priceInfo.PricePetrol = rnd.Next(60, 70);
        //
        NotifyObservers();
    }
}
//класс инфформация о топливе кторый будет передаватся в подписчика
public class PriceFuelInfo
{
    public int PriceGas { get; set; }
    public int PricePetrol { get; set; }
}

//класс подписчика содержит сылку на класс издателя 
public class PetrolCustomer : IObserver
{
    public string Name { get; set; }    
    
    private IObservable storeFuel;

    public PetrolCustomer(IObservable observable, string name)
    {
        Name = name;
        this.storeFuel = observable;
        //поддписываемя на события из издателя (добалвяемся в список подписчиков в класе издателе)
        observable.AddObserver(this);
    }
    
    //подписчик уведомляется от издателя через этот метод когда издатель вызывает FuelPrice, 
    //в кторм вызывается метод NotifyObservers котрый в свою очередь вызывает все методы update
    //всех подписчиков кторые были добавлены в список издателя.
    public void Update(PriceFuelInfo storeInfo)
    {
        if (storeInfo.PricePetrol > 68)
        {
            Console.WriteLine($"{Name} жалутес что бензин доргой");
        }
        else
        {
            Console.WriteLine($"{Name} покупат бензин по цене {storeInfo.PricePetrol}");
        }
    }

//удаляем подписчика из списка подписчиков в классе издателе
    public void StopTrade()
    {
        storeFuel.Remove(this);
    }
}

public class GasCustomer : IObserver
{
    public string Name { get; set; }
    private IObservable storeFuel;
    
    public GasCustomer(IObservable storeFuel, string name)
    {
        this.storeFuel = storeFuel;
        Name = name;
        storeFuel.AddObserver(this);
    }
    public void Update(PriceFuelInfo storeInfo)
    {
        if (storeInfo.PriceGas < 47)
        {
            Console.WriteLine($"{Name} скупает весь газ по цене {storeInfo.PriceGas}");
        }
        else
        {
            Console.WriteLine($"{Name} не покупает газ");
        }
    }

    public void StopTrade()
    {
        storeFuel.Remove(this);
    }
}


StoreFuel fuelStore = new StoreFuel();

GasCustomer gas = new GasCustomer(fuelStore, "Lex");
PetrolCustomer petrol = new PetrolCustomer(fuelStore, "Hex");

fuelStore.FuelPrice();//Lex не покупает газ
//Hex покупат бензин по цене 62

//отписка одноко из подпискичов
gas.StopTrade();

fuelStore.FuelPrice();//Hex покупат бензин по цене 63



--mvc--
------------------------------------------
модель(model) - бизнес логика. например чтение/запись в бд, получение иформации с удалленных машин по сети, и тд. - кароче работа с данными

представление (view) - компоннент заботится о представлении данных полльзователю. - кароче форма

контролллер (controller) - связываеит вмессте моделль и представление. модель которая манипулируте данными и прдставление 
которое предоставляет данные полльзователю, не доллжны знать друг у друге или взаимодействовоат друг с другом напрямую. 
контроллер как бы посредник, напрмиер контроллер принимает ввод от пользователя такой как нажатие кнопки, и информирует модель о 
необходимости предпринять соотвествующие деействия кароче контроллер берет нажаите кнопки и вызыввает приязаный к ней(нажатие кнопки) метод.





==========================================
--API, REST API
------------------------------------------
API (Application programming interface) — это контракт, который предоставляет программа. «Ко мне можно обращаться так и так, 
я обязуюсь делать то и это».
API включает в себя

-операция
-данные на входе
-данные на выходе

применимо к реальной жизни это - Договор между двумя сторонами, как договор на покупку машины:

мои обязанности — внести такую то сумму,
обязанность продавца — дать машину.

API — это набор функций. Это может быть одна функция, а может быть много.

Пользователи работают с GUI — graphical user interface. Программы работают с API — Application programming interface. 
Им не нужна графика, только контракт. 

В MVVM MV монжо назвать API
--
в апи етсь два стиля

Code first — сначала пишем код, потом по нему генерируем контракт
Contract first — сначала создаем контракт, потом по нему пишем или генерируем код (в этой статье я буду говорить именно 
об этом стиле)
------------------------------------------
CDN

CDN (Content Delivery Network) — это географически распределённая сетевая инфраструктура, обеспечивающая быструю доставку 
контента пользователям веб-сервисов и сайтов. Входящие в состав CDN cерверы географически располагаются таким образом, 
чтобы сделать время ответа для пользователей сайта/сервиса минимальным.

В современном мире огромную роль играет скорость работы веб-сайтов и сервисов. Если скорость слишком мала 
это чревато потерей аудитории, а во многих случаях ― ещё и прибыли. Один из надёжных способов решения этой проблемы ― 
использование сетей доставки контента (Content Delivery Networks, CDN).

--
связаные понятия

Ориджин (origin) — сервер, на котором хранятся исходные файлы или данные, раздаваемые через CDN.

PoP (point of presence, точка присутствия) — кэширующий сервер в составе CDN, расположенный в определенной 
географической локации. Для обозначения таких серверов также используется термин edge.

Динамический контент ― контент, генерируемый на сервере в момент получения запроса (либо изменяемый пользователем, 
  либо загружаемый из базы данных).

Статический контент ― контент, хранимый на сервере в неизменяемом виде (например, бинарные файлы, аудио- и видеофайлы, 
  JS и CSS).
------------------------------------------


REST API

REpresentational State Transfer (Википедия: «передача состояния представления»). Это популярный архитектурный подход 
для создания API в современном мире.
сервисы рест позволяют наилучшим образом использовать протокол HTTP

------------------------------------------
==========================================

--Vue--
------------------------------------------
v-cloak

Бывают ситуации, когда вы загружаете страницу с каким-то компонентом Vue, и при этом страница при загрузке 
«прыгает»: сначала показывает синтаксис шаблона Vue, а потом рендерит сам шаблон.

Починить это легко — добавляем к родительскому элементу директиву v-cloak, прописываем стили и всё. 
Со стилями можно поэкспериментировать.

 <style>
        [v-cloak]
        {
            display: none;
        }
    </style>
==========================================


--Arduino--
------------------------------------------
--основные перменные--

------------------------------------------
#include //подключить файл/библиотеку

--
чтобы сократить время операции при работее с числами с плавающей точкой, лууше умножиитьь их на 1000+ с перводом в инт

--
мат операции с числами

pow(x,a);//возвесит х в степень а, может возводиить в дроную стерпень

sqr(x); //воввести число в квадрат х

sqrt(x);//взят квадратный корень числа х

abs(x); //найти модульь числа х

sin(x), cos(x), tan(x)//синус, колсинус, ттангенс

round(x);//округлитть число х

ceil(x);округить число х в большую сторону

floor(x); округитьь в меньшую сторону

перменные в арудино принимают новые значения если их перезаписывать

a = 10;//равна 10

a = 2500; //равноа 2500

a = 0;//равна 0

a = 0;

a= a+a+1;//равана и 0+0+1 и тд

--
константы const int = 10; неизменная перменная

--
лоалные глобальные пермененной

глобальные доступны веезде, локлаьные доступныы только внутри функции в кторой они обьявлены

--
#define <name> <value> //пременная хранится в памяти микроконтролеера,в случае с дефайнайном все перменные с именеми дефайна загружают свои значения 
//в микроконтроллер на этапе комплияции(рабоать как с консттантой можно читтат нельхя перзаписсывать) моджн обявлять например номер пина 
//время для таймера или физические ли математические константы


--

--работа с компортом
------------------------------------------
когда отравлявяем данные из компьюьтера в компорт они скалдываются в буфер и ждут обработки(пока ардуино ихъ прочитает) обьем данных 64 байта

Serial// обььект библиотеки Serial для работыы с последователгным портом (COM port)

Serial.begin(x);// компорт будет работать на сокрости х бод по умаолчанию 9600

Serial.print("x")// отправляем в порт строку х, если выводим число каавычки ненужны

Serial.println("x")// отправляем в порт строку х, с ПЕРЕВОДОМ на новую строку, если выводим число каавычки ненужны

Serial.println(x, n)// отправляем в порт число х с колочисвтом числел после запятой n, 
//с ПЕРЕВОДОМ на новую строку

int x = 3442;
Serial.println(x, DEC);//вывести чисо х в десятчном формате
Serial.println(x, HEX);//вывести число х в 16ричном
Serial.println(x, OCT);//х в 8ричном
Serial.println(x, BIN);//х в двоичном

Serial.available();// провериттьь буфер наналичие входящих данных возвращает число данных в буфере

Serial.read(); //прочитать входящие данные в символьном формате ASCII

Serial.read() - 0;//прочитиатьь данные в целочисленном формате, но тольько по однгой цифре, перменнная будет принамть вид последннй циффры

Serial.parseInt(); //позволяет прочиать int число в целочисленоо формате ПОЛНОСТЬЬЮ  а не по одной цифре
Serial.parseDouble(); //позволяет прочитать число double аналогично верхней записи

if (Serial.available() > 0)//если в буефре нет данных то мы ничего не делаем
  {
    //тут ардуино отправляет нам то...
    int in_data = Serial.parseInt();//читаем число из компорта
    //...что мы послали ей
    Serial.println(in_data); //отправляем число в компорт
  }

--условные операторы(if-else, switch)
------------------------------------------
работает как в шарпе

свитч работает как в шарпе

--временные функции
------------------------------------------
delay(x);//задержка в х милисекнуд(1/1000сек), макисмальное занчение 4 294 967 295 мс/ 1200 часов/ 50 суток

delayMicroseconds(x)//заддержка в х микросекунд(1/1000 000), макс значение 16383 мкс/16 мс
//это не рекомендуется использоват тк это работает не насинхронно нефига тем самым тормозя микросконтроллер пока не выполнится

//рекнмендуется использовать millis(), micros()

millis();// возварщает колво мс, с разрещшением 1 мс, которые прошли  с момента включения контроллера в милисекуундах, 
//макс значение 4 294 967 295 мс/ 1200 часов/ 50 суток, при переполнении сбрасывается в 0

micros();// возварщает колво микросекунд, с разрещшением 4 мкс, которые прошли с момента включения контроллера в микросекундах, 
//макс значение 4 294 967 295 мс/ 70 минут, при переполнении сбрасывается в 0

//пример использования миллис
if (millis() - last_time > 5000)//перменная last_time; не растет а вот millis растет, при кажом цикле программы растет 
 //разность между ними при достижении разности в 5 сек условие выполняется
 {
   last_time = millis();//это сделано для того чтобы условие срабатыало каджый раз при достижении 5 секунд, тк пока идет 
   //цикл внутри перменная if (millis() - last_time не меняется, а как тотлько проихсодит взод из цикла приследующей итерации луп ей 
   //присвоиится значение которое записано втури цикла при первой итерации 5000, при второй 10000 и тд
...

if (millis() - last_time > (unsigned long) 23 * 24 * 60 * 60 * 1000)//чтобы достичь задерждки например в несолкьок дней протсо умонжаем чиссло на колво 
//часов в сутках - 24, на клово минут в часе - 60, на колво секунд в одной минуте - 60, 
//на колво милисекундд в одной секунде 1000.(unsignned long тут для работы с ольшими числами)
{
  ...


#include <Thread.h>  // подключение библиотеки ArduinoThread
const int soundPin = 3;  // переменная с номером пина пьезоэлемента
const int ledPin = 13;  // переменная с номером пина светодиода

Thread ledThread = Thread(); // создаём поток управления светодиодом
Thread soundThread = Thread(); // создаём поток управления сиреной

void setup() {
    pinMode(soundPin, OUTPUT); // объявляем пин 3 как выход.
    pinMode(ledPin, OUTPUT);   // объявляем пин 13 как выход.

    ledThread.onRun(ledBlink);  // назначаем потоку задачу
    ledThread.setInterval(1000); // задаём интервал срабатывания, мсек
    
    soundThread.onRun(sound);     // назначаем потоку задачу
    soundThread.setInterval(20); // задаём интервал срабатывания, мсек
}

void loop() {
    // Проверим, пришло ли время переключиться светодиоду:
    if (ledThread.shouldRun())
        ledThread.run(); // запускаем поток
    
    // Проверим, пришло ли время сменить тональность сирены:
    if (soundThread.shouldRun())
        soundThread.run(); // запускаем поток
}

// Поток светодиода:
void ledBlink() { 
    static bool ledStatus = false;    // состояние светодиода Вкл/Выкл
    ledStatus = !ledStatus;           // инвертируем состояние
    digitalWrite(ledPin, ledStatus);  // включаем/выключаем светодиод
}

 // Поток сирены:
void sound() { 
    static int ton = 100;  // тональность звука, Гц
    tone(soundPin, ton);  // включаем сирену на "ton" Гц
    if (ton <= 500) {  // до частоты 500 Гц 
        ton += 100;  // увеличиваем тональность сирены
    }
    else {  // по достижении 500 Гц
        ton = 100;  // сбрасываем тональность до 100 Гц
    }
}

==========================================

--gpib--
------------------------------------------

==========================================


--Изучить позже--
------------------------------------------
Выражения nameOf для возвращения строкового представления символов

Использование await в блоках catch и finally.

Обобщенные асинхронные возвращаемые типы

глянуть тот видос с обьлегчением консткрукций if else

фнукция this делает полезную работу и потом говорит пулу потоков: 
вызови вот эту вот вторую асинхронную функцию invike, но сделай это в основном потоке. 
Вторая функция обновляет индикатор процесса, и, поскольку пул потоков вызывает её в основном потоке, 
никаких конфликтов не происходит.
Типа вызываем например нашу  асинхронную функцию this в случае каогото дествия в программе,
 например нажатие кнопки (это делается как раз в асинхролнном потоке) и наша this делает
скажем settext = "AOAOAAO" в textbox(это делается в оснвном потоке). а такак  settext = "AOAOAAO"в textbox
 делается в основном потоке, при налиции нескольких потоков(таких вот функций по типу this), напрмиер есть 
 еще одна скаежм кнопка ктороая вызывает еще одну асинхронную функцию которая джаелет чтот подобное  
 settext = "blabla"в том же textbox по нажатию кнопки. 
 И чтобы асинхронные функции для входа в оснвной поток друг друга не ждали и не конфликтовали. 
 наши фунции асинхронная разбиваеттся на две  части первая делает полезную работу обработку события 
 нажатия кнопки и говрит вызови вторую часть(которая собтсвенно делает gettext в textbox) в оснвном 
 потоке да обновление происходит послдовательно но и  потому у нас не происходит конфликта с очередностью 
 мы как раз и спользуем invoke ктороый явлется как бы окном в основной поток из асинхроного потка нашей
  функции this те invoke попросту используется для синхронного вызова каждого из первоч части нашей this 
  ва которой выолппняется обработка нажатия, это означает, что вызывающий код(основной поток) должен ожидать
  завершения вызова через invoke, прежде чем продолжить свою работувобщем скажи мне правильно ли я поял 
  прдназначение invoke

типа пул потков это как бы списко чтли потоков для выполнения в фновм режиме
типа чтобы выполниьт какойто метод из потока надо его в пул потока поместить и тогда пул сам будет 
извелкать методы и выполноять их при вызове  и вот чтобы эти асинхронные потоки не конфликтовали и существует invoke

присваивание в  object value = 50; это боксинг


using System;

namespace ExperementNetCore
{
    delegate void AccountHandler<in T>(T message) where T : AccounArgs;//in T это когд вы не можете 

    class AccounArgs
    {
        public string Name;
    }

    class CompanyArg : AccounArgs
    {
        public string Company;
    }


    class Person<T> where T : AccounArgs
    {

        public Person(string name)
        {
            Name = name;
        }


        public event AccountHandler<T> _notify;
        private string name;

        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value != name)
                {
                    name = value;
                    DisplayTo();
                }

            }
        }

        public virtual void DisplayTo()
        {
            OnNotify((T)new AccounArgs() { Name = name });
        }

        protected void OnNotify(T message)
        {
            _notify?.Invoke(message);
        }
    }
    class Employee : Person<CompanyArg>
    {
        public string Company { get; set; }

        public Employee(string name, string company)
            : base(name)
        {
            Company = company;
        }

        public override void DisplayTo()
        {
            OnNotify(new CompanyArg() { Name = Name, Company = Company });
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            var p = new Person<AccounArgs>("Max");
            p._notify += Display;
            p.DisplayTo();

            var e = new Employee("Mixa", "KEK");
            e._notify += Display;
            e.DisplayTo();

            e = new Employee("Lexa", "LLOOOL");
            e._notify += Display;
            e.DisplayTo();

            Console.Read();
        }

        static void Display(AccounArgs name)
        {
            Console.WriteLine(name.Name);
        }
        static void Display(CompanyArg name)
        {
            Console.WriteLine($"{name.Name} {name.Company}");
        }
    }
}


использование _  пустых переменных, в out и прочем.


==========================================


вопросы
------------------------------------------
уточнить про строки как они там копируются и что будет если пердвать строку по ref

как мне сделать в классе  
    class Instantiator<U,V>
    {
        public U FromInstance { get; set; }
        public U ToInstance { get; set; }
        public V Code { get; set; }

    }

            Instantiator<Account<int>,string> i = new Instantiator<Account<int>, string>
            {
                FromInstance = acc1,
                ToInstance = acc2,
                Code = "2520"
            };

    генерик метод который будет выводить значения его полей в виде строки 10 20 30 60 2520, может использзовать делегаты?

почему не раобтает
------------------------------------------ 
как мне правильнол организваоть рекрусию чтобы после ухода в кетч я могг ввести ичло != 0 и не получить на выходе 20

var gg = Num(Console.ReadLine());

static int Num(string num)
        {

            int ss = 20;
            var gg = int.Parse(num);

            try
            {
                ss = ss / gg;
            }
            catch (DivideByZeroException ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine("число не должно быть 0");
                return Num(Console.ReadLine());
            }


            return ss;
        }

==========================================
 delegate void Operations<T>(int i, T acc1, T acc2) where T : IAccount, IClient;
    interface IAccount
    {
      
        int CurrentSum { get; } // Текущая сумма на счету
        void Put(int sum); // Положить деньги на счет
        void Withdraw(int sum); // Взять со счета
    }

    interface IClient
    {
        string Name { get; set; }
    }
   
    class Client : IAccount, IClient
    {
     
        int _sum; // Переменная для хранения суммы
        public Client(string name, int sum)
        {
            Name = name;
            _sum = sum;
          
        }

        public string Name { get; set; }

        public int CurrentSum
        {
            get { return _sum; }
        }

        public void Put(int sum)
        {
            _sum += sum;
        }

        public void Withdraw(int sum)
        {
            if (sum <= _sum)
            {
                _sum -= sum;
            }
        }
    }

    

    class Transaction<T> where T : IAccount, IClient
    {
        
        public void Operate(int sum, T acc1, T acc2, Operations<T> op)
        {
           op.Invoke(sum, acc1, acc2);

            Console.WriteLine($"{acc1.Name} : {acc1.CurrentSum}\n{acc2.Name} : {acc2.CurrentSum}");
        }

        public static void Withdraw(int sum, T acc1, T acc2) 
        {
            if (acc1.CurrentSum >= sum)
            {
                acc1.Withdraw(sum);
                acc2.Put(sum);

            }
        }
        public static void Put(int sum, T acc1, T acc2)
        {
            if (acc1.CurrentSum >= sum)
            {
                acc1.Put(sum);
                acc2.Withdraw(sum);

            }
        }

    }

    class Program
    {
        static void Main(string[] args)
        {

            Client account1 = new Client("Tom", 200);
            Client account2 = new Client("Bob", 300);

            Transaction<Client> transaction = new Transaction<Client>();


            transaction.Operate(150, account1, account2, Transaction<Client>.Put);
            transaction.Operate(150, account1, account2, Transaction<Client>.Withdraw);

        }

    }
}