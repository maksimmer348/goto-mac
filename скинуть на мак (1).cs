
--Структуры--

------------------------------------------
1) Переменные структуры хранят не ссылку на объект, а сам объект (у вас это не очевидно, хотя и можно догадаться). 
То есть это значимый тип, а не ссылочный.

2) Значит если одной структуре присвоить другую, то Скопируются Все Поля одной структуры в другую,
 а не ссылка, как было бы с классами.

3) Т.к. переменная хранит сами данные, а не ссылку на них, то доступ к полям осуществляется быстрее и есть 
некоторая экономия памяти.

4) Структуры не поддерживают наследование


==========================================

--Стек и Куча--

------------------------------------------
Стек
------------------------------------------
поселдний зашел последний вышел

для стека использетуеся маленкий обьем опаретивной памяти
стек выделяется для каждого потока те каждый поток в ропграмме имеет собственный стек
стек использетуеся для храниения перменных которые мы создаем для выполнения операций над этими перменными
для вызова методов которые мы используем в нашей программе те для того чтобы выполнять логику нашей программы
дефолтное значение которое выделяется под стек ограничивается - 1 МБ

стек нужен для организации логики нашей программы 
здесь опрделеяется очередность вызова метододв используемые по мере выполнения наше программы 

Куча(Heap)
------------------------------------------
первый зашел последний вышел

Склад опреативной памяти который мы используем по мере надобности он гораздо больше чем стек
если у нас 32 разрадный процеес то выделить под кучу можно до 1,5 ГБ опреативной памяти 
если у нас 64 разрадный процеес то выделить под кучу можно до 8 ТБ опреативной памяти 

более проблематично выделять и очищать данные в оперативной памяти под кучу нежели под стек 
очисткой кучи из памяти занимается сборщик мусора сборка мусора занимает опраделленно время и расходует ресцурсы

==========================================

--значимые типы, (value types) и ссылочные типы (reference types)--
------------------------------------------

значимые типы, (value types) -> стек
------------------------------------------
эти типы неявно унаследованы от System.ValueType
Структуры (struct)
Целочисленные типы (byte, sbyte, short, ushort, int, uint, long, ulong)
Типы с плавающей запятой (float, double)
Тип decimal
Тип bool
Тип char

Перечисления enum

пермеменные передаются по значению(копируются реальные данные) те она хранит реальные данные

когда создаем перменную значимого типа то мы как будто положили какотйо файл на рабочеий стол а не его ярлык поэтому 
мы не можем присвоить этой персенной значение null

если мы присваем одной такой перемено значени другой такой перменной мы копируем значение из одной переменной в другую,
как итог в стеке две перменнх с одинаковым результатом

переменные этого типа пракаращают свое сущетсование когда покидают контекст(область видимости) в котором они были 
определены

static void Main(string[] args)
            {
               int i = 1;
               GetInt(5);
               Console.WriteLine(i);//i == 1 
               Console.ReadLine();
            }

            static void GetInt(int i)//сюда копируеся значение из перменной i 
            {
                i = 5;//при выходе из области видимочти эта перменная как и ее значение удаляется
            }



ссылочные типы (reference types) -> куча
------------------------------------------
могут быть производными от любого другого типа кроме System.ValueType
неявно наследованы от object
Тип object
Тип string
Тип Array
Классы (class)
Интерфейсы (interface)
Делегаты (delegate)
------------------------------------------

копируется ссылка, оригинал и копия ссылаются на один и тот же обьект в управляемой куче, одни и те же данные 

ссылочные типы хранят свои данные в куче, но в стеке хранится ссылка на данные в управляемой куче 
когда создаем перменную ссылочного типа то в стеке у нас хранится ссылка(типа как ярлык на рабочем столе),
а в куче хранятся данные(типа как exe) 

Если переменным ссылочного типа не присваивается значение, то им дается значение по умолчанию - значение null.
Фактически оно говорит об отстутсвии значения как такового или что нету ссылки на данные в управляемой куче  
те когда мы обявли перменную ссылочного типа
{
   int[]a;  //a = null;
}
мы разместили на стеке некий ярлык ктороый храни ссылку на данные ктороы распологаются в куче - это и ест null 

если мы присваем одной такой перемено значени другой такой перменной мы копируем ссылки на эту перменную а не содержимое
(типа как еще один ярлык на рабочем столе который ведет по тому же пути что и первый), те две этих перменных теперь 
будут ссылаться на один и теже еданные 

static void Main(string[] args)
            {
                int[] arr1;//arr1 = null мы разместили на стеке некий ярлык ктороый храни 
                //ссылку на данные ктороы распологаются в управляемой куче но пока там ничего нет

                arr1 = new int[1];//new в управляемой куче создает место под массив и вернет ссылку на эту область
                //в памяти в перменную arr1

                ////////////////////////////////////////////
                //если сдесь сделать так то связь между ссылкой в стеке и реальными данными в куче будет разорвана 
                arr1 = null;
                ////////////////////////////////////////////

                arr1[0] = 1;
                GetInt(arr);
                Console.WriteLine(arr[0]);//arr1[0] == 5;
                Console.ReadLine();
            }

            static void GetInt(int[] arr)//сда копируется ССЫЛКА на массив arr1  
            {
                arr[0] = 5;//потому здесь мы отправляем значение по ССЫЛКЕ на массив arr1 цифру 5
            }

------------------------------------------
переменные этого типа пракаращают свое сущетсование когда обьект подвергается сборке мусора
если выйти из области видимости ссылочного типа удалится сслыка на этот тип но, память выделаная под этот тип все 
еще занята этим типом, пока не отработает сборщик мусора
------------------------------------------
Одно из отличий ссылочных типов от типов значений состоит в том, что переменные ссылочных типов могут принимать 
значение null. Например:

object o = null;
string s = null;

Если переменным ссылочного типа не присваивается значение, то им дается значение по умолчанию - значение null.
 Фактически оно говорит об отстутсвии значения как такового.
==========================================


--модификаторы доступа--

------------------------------------------
public: публичный, общедоступный класс или член класса. Такой член класса доступен из любого места в коде, а также из 
других программ и сборок.;

private: закрытый класс или член класса. Представляет полную противоположность модификатору public. 
Такой закрытый класс или член класса доступен только из кода в том же классе или контексте.

protected: такой член класса доступен из любого места в текущем классе или в производных классах.
При этом производные классы могут располагаться в других сборках.

internal: класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке,
 однако он недоступен для других программ и сборок (как в случае с модификатором public).

protected internal: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны 
из текущей сборки и из производных классов.

private protected: такой член класса доступен из любого места в текущем классе или в производных классах, которые 
определены в той же сборке.
------------------------------------------
класс может иметь модификатор доступа private но если класс вложенный по отношению к другому классу.
 А если класс определен в пространстве имен, то не может;

namespace numbers
{
	private class one//недопустимо
	{

	}
	class two
	{
		private class three//допустимо
		{

		}
		private class five : four//допустимо
		{

		}
	}
	class four internal 
	{

	}
}
==========================================


--null  и операторы --

------------------------------------------
Если переменным ссылочного типа не присваивается значение, то им дается значение по умолчанию - значение null. 
Фактически оно говорит об отстутсвии значения как такового или что нету ссылки на данные в управляемой куче  
те когда мы обявли перменную ссылочного типа
{
   int[]a;  //a = null;
}
мы разместили на стеке некий ярлык ктороый храни ссылку на данные ктороы распологаются в куче - это и ест null

Одно из отличий ссылочных типов от типов значений состоит в том, что переменные ссылочных типов могут принимать
 значение null. Например:

object o = null;
string s = null;

? для ссылочных типов
------------------------------------------
здесь происходит проверка на null
Action s = null;               

var handler = s;
if (s != null)
{
    s(…);
}

s?.Invoke();//эта запись аналогична вышенаписаной

------------------------------------------
    class User
{
    public Phone Phone { get; set; }
}
 
class Phone
{
    public Company Company { get; set; }
}
 
class Company
{
    public string Name { get; set; }
}            
В данном случае свойство Phone не определено, будет по умолчанию иметь значение null. 
Поэтому мы столкнемся с исключением NullReferenceException.
 Чтобы избежать этой ошибки мы могли бы использовать условную конструкцию для проверки на null

User user = new User();
 
if(user!=null)
{
    if(user.Phone!=null)
    {
        if (user.Phone.Company != null)
        {
            string companyName = user.Phone.Company.Name;
            Console.WriteLine(companyName);
        }
    }
}
//или сокращенно 
//эта записа аналогична вышенаписаной
string companyName = user?.Phone?.Company?.Name;

------------------------------------------
null Строки
Из-за того, что строки это ссылочный тип, их идентификаторы тоже могут быть равны null. 
Мы часто хотим защитить свою программу от ошибок, связанных с null-строками. Это можно сделать
 с помощью методов IsNullOrEmpty(возвращает trye если string пуста или string == null) 
 или string.IsNullOrWhiteSpace(string)(возвращает trye если string пуста или string == null или string == "\t" или 
 string == " " те строка ). 
 Также можно просто проверить строку на равенство литералу null. 
 Достоинство этого метода в том, что она работает быстрее, если не требуется проверка на длину строки.

nullable для значимых типов
------------------------------------------
Оператор ?? возвращает левый операнд, если этот операнд не равен null. Иначе возвращается правый операнд.
object x = null;
object y = x ?? 100;  // равно 100, так как x равен null
работает только с переменным ссылочного типа


int? i = null;//делается для того чтобы значимые типа могли хранить null
//в случае если вдруг не пришлось присваивать null в эту перменную она останется 
//обфчной int
int y;


Console.WriteLine(i == null);

Console.WriteLine(i.HasValue);//bool есть ли у этой перменной реальное занчение i == null будет возвращено false

Console.WriteLine(i.GetValueOrDefault());//GetValueOrDefault досутпен только в сулчае если перменная является nullable 
           
//если в преременной i было присвоено значние, то результатом этой операции будет это самое значение 
//если же нет то будет возрващено занчение default для того типа перменной к кторой проверяемая перменная относится
//в данном случае будет возвращено 0 

Console.WriteLine(i.GetValueOrDefault(3));//аналогично верхней записи за исключением того что вместа default
//в случае если проверямеая пременная ббудет i == null , то будет возраащено 3

Console.WriteLine(i??55);//если перменная i == null то он вернет занчение из правой части те 55
//если же значение i != null (например 10)то он вернет ээто значение те 10
//обычно используется этот метод
           
Console.WriteLine(i.Value);//реальные данные которые хранятся в поле i , если i == null то тут будет ошибка

Console.WriteLine(i); // есл сделать так то вместо ошикбки на консоль выведется путсая строка 


==========================================

--динамические струкры данных--
------------------------------------------

Array.Resize

==========================================
--Пространства имен, псевдонимы и статический импорт--

------------------------------------------
Пространства имен
------------------------------------------
Но чтобы задействовать классы из других пространств имен, эти пространства надо подключить с помощью директивы using, 
например using System;
Здесь подключается пространство имен System, в котором определен класс Console. Иначе нам бы пришлось писать полный 
путь к классу: System.Console.WriteLine("hello");

Пространства имен могут быть определены внутри других пространств
В этом случае для подключения пространства указывается его полный путь с учетом внешних пространств имен например 
using HelloApp.AccountSpace;

псевдонимы
------------------------------------------
Для различных классов мы можем использовать псевдонимы. Затем в программе вместо названия класса используется 
его псевдоним. 
Например, для вывода строки на экран применяется метод Console.WriteLine(). Но теперь зададим для класса Console 
псевдоним:

using printer = System.Console;
class Program
{
    static void Main(string[] args)
    {
        printer.WriteLine("Hello from C#");
        printer.Read();
    }
}
Указываем, что псевдонимом для класса System.Console будет имя printer.
 Это выражение не имеет ничего общего с подключением пространств имен в начале файла, хотя и использует оператор using.
 
статический импорт
------------------------------------------
Выражение using static подключает в программу все статические методы и свойства, а также константы. 
И после этого мы можем не указывать название класса при вызове метода.

Также в C# имеется возможность импорта функциональности классов. Например, импортируем возможности класса Console:

using static System.Console;

            WriteLine("Hello from C# 8.0");//в этом случае можно опусттить вызов тсатического метода консаль

            Read();
    
==========================================

--свойства get set свойства--
------------------------------------------

 private int x;
        public void SetX(int x)
        {
            if (x > 5)
            {
                this.x = 5;
                return;
            }

            this.x = x;
        }
        public int GetX()
        {
            return x;
        }
//вышенпаисаное аналогично ниже написаному
////////////////////////////////////////////////
        private int y;
        public int Y
        {
            get { return y; }
            set
            {
                if (value > 5)
                {
                    y = 5;
                    return;
                }

                y = value;
            }
        }

------------------------------------------

Автосвойствам можно присвоить значения по умолчанию (инициализация автосвойств) и модификаторы доступа:

    public string Name { get; set; } = "Tom";
    public int Age { get; set; } = 23;

     public string Name { private set; get;}
    public Person(string n)
------------------------------------------
1. Модификатор для блока set или get можно установить, если свойство имеет оба блока (и set, и get)

2. Только один блок set или get может иметь модификатор доступа, но не оба сразу

3. Модификатор доступа блока set или get должен быть более ограничивающим, чем модификатор доступа свойства. 
Например, если свойство имеет модификатор public, то блок set/get может иметь только модификаторы protected internal, 
internal, protected, private

Начну с №3,
Модификатор должен быть более ограничивающий потому, что: 1.Нет смысла делать такой же модификатор,
как у свойства потому что он уже есть и get-set им пользуются. 2. Невозможно и нельзя сделать модификатор более 
расширяющим, потому что это противоречит идеи инкапсуляции.

Теперь №2,
Как сказано - только 1 метод (get или set) может иметь модификатор, значит нужно понять, что не так в случае если оба 
имеют модификаторы, а вот что - допустим у нас свойство модификации public и мы поставили модификатор protected на оба:
 get, set и это означает, что эти методы будут доступны в текущем классе и классах-наследниках, 
 и проблема в том что если класс Program, в методе main мы создали объект от того класса, при вызове свойства Name 
 оно будет obsolete, иными словами функционал недоступен!, хотя оно же public, и тут возникает ошибка! 
 Поэтому опять таки исходя из идеи инкапсуляции public - должно быть доступно везде! А мы там поставили на оба protected,
  непорядок! Не должно быть так! Все что public - должно быть доступным везде и всюду!Поэтому из этого исходит пункт, 
  что только один может иметь модификацию, чтобы другой мог всегда быть использован!

Теперь №1,
Здесь мысль такая же, как и в предидущем пункте - Свойство должно быть доступно! 
Если поставить модификатор в случае когда есть только get или set (один из них), то получится опять нарушение
идеи инкапсуляции! Поэтому при присутствии второго, на который не будет вешаться модификатор, 
все будет соответствовать идеи!

------------------------------------------
Не лишним будет подчеркнуть, что внутри блоков get{ } и set { } можно указывать процедуры и функции. И это замечательно,
 ведь благодаря этому, на любое поле класса можно повесить процедуру, которая будет запускаться каждый раз,
  когда значение переменной где-то изменяется.
private bool fullyLoaded = false;
public bool onfullyLoaded
{
get { return fullyLoaded; }
set
{
fullyLoaded = value;
OnTestChanged();
}
}

void OnTestChanged()
{
//Ваш индусский код
}

сокращенная записаь свойства
------------------------------------------
private string name;
     
    // эквивалентно public string Name { get { return name; } }
    public string Name => name;

чтобы присовить значение readonly свойству нужно использовать конструктор класса

  public string Name { get; }// readonly свойство

 public human(string name)//рабоает как с любой  reaadonly перменной
        {
            Name = name;
        }

  human h = new human("Max");
  Console.WriteLine($"{h.Name}");//Max

==========================================


--static модификатор--
------------------------------------------

На уровне памяти для статических полей будет создаваться участок в памяти, который будет общим для всех объектов
(экземпляров) класса.


 static-методы не могут использовать ссылку this и напрямую (т.е. без указания конкретного объекта класса) 
 обращаться к нестатическим членам класса, а только через объект класса.

  public static bool ValidatePorts(this ComSettings view)//здесь создается объект класса через который и пойдет 
  //обращение к нестаическим членам класса
        {
        	//если вместо viev написать this выскочит исключение
            if (view.ChannelComMeter.SelectedItem == view.ChannelComSupply.SelectedItem)
            {
                return false;
            }

            return true;
        }

статический конструктор  необходимо создавать, если вам надо выполнять некоторые действия при первом создании 
объекта этого класса.
	Как правило, в статическом конструкторе инициализируются общие для всех объектов ресурсы.
	Приведу практический пример: есть класс, через который взаимодействуем с базой данных. И нам надо, 
	чтобы до создания первого объекта класса в базе данных уже были некоторые объекты. 
	В статическом конструкторе этого класса тогда можно проверить объекты в бд и добавить их при необходимости.

Статический конструктор вызывается перед доступом к любому члену класса.

class Account
    {
        // public static string name = "Ivan";
        public static string name;
        static Account()
        {
            name = "Ivan"; 
        }
    }
    
        static void Main(string[] args)
        {
            Console.WriteLine(Account.name);// Обращение к полю по имени класса и тут срабатывает конструктор
        }
    
    все объекты класса, в том числе и первый, создаются с помощью нестатического конструктора, 
    статический конструктор не создает объект касса, более того явным образом не вызывается. Он вызывается системой,
     когда вы создаете с помощью нестатического конструктора первый объект класса
==========================================



--перегрузка операторов--
------------------------------------------


Counter c1 = new Counter { Value = 23 };
Counter c2 = new Counter { Value = 45 };
операция сравнения, и операция сложения для объектов Counter не доступны. 
Эти операции могут использоваться для ряда примитивных типов. Например, по умолчанию мы можем складывать числовые 
значения, но как складывать объекты комплексных типов - классов и структур компилятор не знает. 
И для этого нам надо выполнить перегрузку нужных нам операторов.

bool result = c1 > c2;
Counter c3 = c1 + c2;

Перегрузка операторов заключается в определении в классе, для объектов которого мы хотим определить оператор,
 специального метода:Этот метод должен иметь модификаторы public static, так как перегружаемый оператор будет
  использоваться для всех объектов данного класса.
public static возвращаемый_тип operator оператор(параметры)
{  }


class Counter
{
    public int Value { get; set; }
         
    public static Counter operator +(Counter c1, Counter c2)
    {
        return new Counter { Value = c1.Value + c2.Value };
    }
   //Если мы переопределяем одну из этих операций сравнения, то мы также должны переопределить вторую из этих операций
    public static bool operator >(Counter c1, Counter c2)
    {
        return c1.Value > c2.Value;
    }
    public static bool operator <(Counter c1, Counter c2)
    {
        return c1.Value < c2.Value;
    }
}
 static void Main(string[] args)
  {
bool result = c1 > c2;
Counter c3 = c1 + c2;
  }      
------------------------------------------
Стоит отметить, что так как по сути определение оператора представляет собой метод, то этот метод мы также можем 
перегрузить, то есть создать для него еще одну версию.
 Например, добавим в класс Counter еще один оператор:

public static int operator +(Counter c1, int val)
{
    return c1.Value + val;
}
------------------------------------------
при перегрузке не должны изменяться те объекты, которые передаются в оператор через параметры.

public static Counter operator ++(Counter c1)
{
	//это неправильнео написание тк оператор не должен менять сови параметры
    c1.Value += 10;
    return c1;
}

И более корректная перегрузка оператора инкремента будет выглядеть так:

public static Counter operator ++(Counter c1)
{
    return new Counter { Value = c1.Value + 10 };
}

==========================================

--Const и Readonly--
------------------------------------------

const Константы
------------------------------------------
const неявно static и его Невозможно изменить где-либо.

Итак, если вы уверены, что значение константы не изменится, используйте const.
public const int CM_IN_A_METER = 100;

Константы по умолчанию статичны.
Они должны иметь значение во время компиляции (вы можете иметь, например, 3,14 * 2, но не можете вызывать методы)
Может быть объявлено внутри функций
Скопируются в каждую сборку, которая их использует (каждая сборка получает локальную копию значений)
Может использоваться в атрибутах;

readonly
------------------------------------------
Но если у вас есть константа, которая может измениться (например, точность w.r.t.).. или если у вас есть сомнения,
 используйте readonly.

public readonly float PI = 3.14;


Существует небольшая магия с readonly. Поле readonly может быть установлено несколько раз внутри конструктора (-ов).
 Даже если значение задано в двух разных цепных конструкторах, оно все же разрешено.

public class Sample {
    private readonly string ro;

    public Sample() {
        ro = "set";
    }

    public Sample(string value) : this() {
        ro = value; // this works even though it was set in the no-arg ctor
    }
}

Еще одно значение: значения readonly могут быть изменены с помощью "коварного" кода через отражение.

var fi = this.GetType().BaseType.GetField("_someField", BindingFlags.Instance | BindingFlags.NonPublic); 
fi.SetValue(this, 1);

Поля экземпляров Readonly
Должно быть установлено значение, по истечении времени конструктор
Оцениваются при создании экземпляра
------------------------------------------
Статические поля readonly
Оцениваются, когда выполнение кода попадает в ссылку на класс (когда создается новый экземпляр или выполняется 
    статический метод) должно быть оцененное значение к моменту завершения статического конструктора
Не рекомендуется помещать ThreadStaticAttribute в эти (статические конструкторы будут выполняться только в 
    одном потоке и будут 
	устанавливать значение для его потока; все остальные потоки будут иметь это значение неинициализированным)
==========================================



--индексаторы--

------------------------------------------
индексаторы позволяют индексировть обьекты и обращатся к даным по индексу. те мы можем работать с обьектами как 
с массивами. 
в таком виде индексатор используется если нужнро скажем написать массив с особеными свойствами

возвращаемый_тип this [Тип параметр1, ...]
{
    get{...}
    set{...}
}
------------------------------------------
 class Person
    {
        public string Name { get; set; }
    }
    class People
    {
        Person[] data = new Person[5];
        //индексатор
        public Person this[int index]// в отличии от свойств инджексатор не имеет названия вместо него идет ключевое 
        //слово this 
        {
            //объекты Person хранятся в классе в массиве data, для получения их по индексу в индексаторе определен 
            //блок get
            get
            {
                return data[index];
            }
            //получаем через параметр value переданный объект Person и сохраняем его в массив по индексу
            set
            {
                data[index] = value;
            }
        }
    }

People p = new People();

            //После этого мы можем работать с объектом People как с набором объектов Person
            p[0] = new Person { Name = "X4X" };
            p[1] = new Person { Name = "X3X" };

            Console.WriteLine(p[0]?.Name);
            Console.WriteLine(p[1]?.Name);

------------------------------------------
Также индексатор может принимать несколько параметров.

 class Matrix
    {
        private int[,] numbers = new int[,] {
            { 1, 9, 4 },
            { 8, 3, 6 }, 
            { 3, 4, 6 }};// хранилище определено в виде двухмерного массива или матрицы
        public int this[int i, int j]  
        {
            get
            {
                return numbers[i, j];
            }
            set
            {
                numbers[i, j] = value;
            }
        }
    }


    class Program
    {


        static void Main(string[] args)
        {
          Matrix mt = new Matrix();
          mt[0, 2] = 99;
          Console.WriteLine(mt[0, 1]);
          Console.WriteLine(mt[0,2]);
        }

------------------------------------------
Как и в свойствах, в индексаторах можно опускать блок get или set, если в них нет необходимости.

 private int[,] numbers = new int[,] { { 1, 2, 4}, { 2, 3, 6 }, { 3, 4, 8 } };
    public int this[int i, int j]
    {
        get// делаем индексатор доступным только для чтения
        {
            return numbers[i,j];
        }
    }
------------------------------------------
перегрузка индексаторов
Подобно методам индексаторы можно перегружать. В этом случае также индексаторы должны отличаться по количеству, 
типу или порядку используемых параметров.

 class Person
    {
        public string Name;
        public int Age;
    }
    class People
    {
        Person[] data;
        public People()
        {
            data = new Person[5];
        }
        public Person this[int index]//перывая версия получает и устанавливает объект Person по индексу
        {
            get
            {
                return data[index];
            }
            set
            {
                data[index] = value;
            }
        }
        public Person this[string name]// вторая - только получае объект Person по его имени
        {
            get
            {
                Person person = null;
                foreach (var p in data)
                {
                    if (p?.Name.ToLower() == name.ToLower())
                    {
                        person = p;
                        break;
                    }
                }
                return person;
            }
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            People people = new People();

            people[0] = new Person { Name = "Tom" };//использование set из первая версия
            people[1] = new Person { Name = "Bob" };//использование set из первая версия
            Console.WriteLine(people[0].Name);//использование get из первая версия

            Console.WriteLine(people["bob"]?.Name);//использование get из второй версия
        }
    }

==========================================



--наследование--
------------------------------------------
После двоеточия мы указываем базовый класс для данного класса. Для класса Employee базовым является Person, 
и поэтому класс Employee наследует все те же свойства, методы, поля, которые есть в классе Person. Единственное, 
что не передается при наследовании, это конструкторы базового класса.

class Person
{
    public string Name { get; set; }
    public Person(string name)
    {
        Name = name;
    }
    public void DisplayName()
    {
        Console.WriteLine(Name);
    }
}

class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company) : base(name)
    {
        Company = company;
    }
}

class Program
{
    static void Main(string[] args)
    {
        Person p1 = new Person("Bill");
        Employee p2 = new Employee("Tom", "Microsoft");
        p1.DisplayName();//Bill
        p2.DisplayName();//Tom функционал из Person Name из Employee
        Console.ReadKey();
    }
}

------------------------------------------

delegate void AccountHandler(string message);
    class Person
    {
        public event AccountHandler _notify;
        private string name;
        string tempName;
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value != name)
                {
                    name = value;
                    DisplayTo();
                }
                
            }
        }

        public void DisplayTo()
        {
            _notify?.Invoke(name);
        }

    }
    class Employee : Person//этот класс будет реализовывать тот же функционал, что и класс Person
                           //Таким образом, наследование реализует отношение is-a (является),
                           //объект класса Employee также является объектом класса Person:
    {

    }
    class Program
    {
        static void Main(string[] args)
        {

            Person p = new Person();
            p._notify += Display;
            p.Name = "flfl";
            p = new Employee();//И поскольку объект Employee является также и объектом Person,
                               //то мы можем так определить переменную: Person p = new Employee().
            p._notify += Display;//но так как новый экземпляр всегода
            //создается с дефолтными значениями
            //нам нажно переподключится к ивенту
            p.Name = "Josh";
            Console.Read();
        }

        static void Display(string name)
        {
            Console.WriteLine(name);
        }
    }

------------------------------------------
class one{}
class two : one{}
class three
one newone = new two();//в этом случае выделяется память под объект two, и поскольку two является наследником от one,
 //то такое использование является допустимым.
  //Затем мы можем использовать созданный объект как one и как two, но чтобы использовать его как two,
   //надо будет выполнить преобразование к two

------------------------------------------
По умолчанию все классы наследуются от базового класса Object, даже если мы явным образом не устанавливаем наследование. 
Поэтому выше определенные классы Person и Employee кроме своих собственных методов, также будут иметь и методы класса 
Object: ToString(), Equals(), GetHashCode() и GetType().
------------------------------------------
Все классы по умолчанию могут наследоваться. Однако здесь есть ряд ограничений:
Не поддерживается множественное наследование, класс может наследоваться только от одного класса.
При создании производного класса надо учитывать тип доступа к базовому классу - тип доступа к производному классу
 должен быть таким же, как и у базового класса, или более строгим. То есть, если базовый класс у нас имеет тип доступа
  internal, то производный класс может иметь тип доступа internal или private, но не public.
Однако следует также учитывать, что если базовый и производный класс находятся в разных сборках (проектах), 
то в этом случае производый класс может наследовать только от класса, который имеет модификатор public.
Если класс объявлен с модификатором sealed, то от этого класса нельзя наследовать и создавать производные классы. 
Например, следующий класс не допускает создание наследников:
sealed class Admin//модификатор по умолчанию - internal
{

}
------------------------------------------
Доступ к членам базового класса из класса-наследника

class Person
    {
       
        private string name;
       
        public string Name
        {
            get...

class Employee : Person
{
    public void Display()
    {
        Console.WriteLine(_name);//не скомпирилуется тк k _name доступ имеет только класс Person
    }
}            
--------
class Employee : Person
{
    public void Display()
    {
        Console.WriteLine(Name);// общедоступное свойство Name, которое мы можем использовать
    }
}

------------------------------------------
Таким образом, производный класс может иметь доступ только к тем членам базового класса, 
которые определены с модификаторами private protected (если базовый и производный класс
 находятся в одной сборке), public, internal (если базовый и производный класс находятся в одной сборке), 
protected и protected internal.
------------------------------------------
порядок вызовов коонстуркторов

При вызове конструктора класса сначала отрабатывают конструкторы базовых классов и только затем конструкторы производных.

class Person
{
    string name;
    int age;
 
    public Person(string name)//сперва отработает этот конструктор 
    {
       //1
    }
    public Person(string name, int age) : this(name)//далее этот тк через this он вызывает первй конструктор
    {
    	//2
    }
}
class Employee : Person
{
    string company;
 
    public Employee(string name, int age, string company) : base(name, age)//и потом уже этот тк он вызывает через 
    //base контсркутор 2 ктороый в свою очреедшь через this вызывает кнстр 1
    {
      //3
    }
}

Employee tom = new Employee("Tom", 22, "Microsoft");//в случае создания обьекта Employee мы получим 
//вышенапиисаный порядок вызово конструкторов
------------------------------------------
Ключевое слово base

С помощью ключевого слова base мы можем обратиться к базовому классу. В нашем случае в конструкторе 
класса Employee нам надо установить имя и компанию. Но имя мы передаем на установку в конструктор базового класса, 
то есть в конструктор класса Person, с помощью выражения base(name).

class Person
{
    public string Name { get;  set; }
 
    public Person(string name)//вот это конструктора мы вызваем из ксласса Employee через выржаение base
    {
        Name = name;
    }
 
    public void Display()
    {
        Console.WriteLine(Name);
    }
}
 
class Employee : Person
{
    public string Company { get; set; }
 
    public Employee(string name, string company)
        : base(name)//С помощью ключевого слова base мы можем обратиться к базовому классу Person.
        //Класс Person имеет конструктор, который устанавливает свойство Name. 
        //Поскольку класс Employee наследует и устанавливает то же свойство Name, 
        //то логично было бы не писать по сто раз код установки, а вызвать соответствующий код класса Person. 
    {
        Company = company;
    }
}

Person p = new Person("Bill");
   
Employee emp = new Employee ("Tom", "Microsoft");//имя мы передаем на установку в конструктор базового класса,
// то есть в конструктор класса Person, с помощью выражения base(name)
------------------------------------------

если в базовом классе не определен конструктор по умолчанию без параметров, 
а только конструкторы с параметрами (как в случае с базовым классом Person), 
то в производном классе мы обязательно должны вызвать один из этих конструкторов через ключевое слово base.

==========================================



--преобразование типов--

------------------------------------------
Восходящие преобразования. Upcasting

восходящих преобразований от производного к базовому

пременной обьекта класса родителя Person person , присваиваешь пременную обьекта класса потомока Employee employee
и ты автоматом выполняешь некое преобразование. 
вот оно и называется как раз "восходящим" или "Upcasting" тк ты  потомка employee преобразуешь в класс предок person 
который находится вверху иерархии классов и они типа таким образом обе эих перменных те перменная потомка и перменная
родителя с присвоеной в нее переменноой потомка начинают указыать на один класс в куче, но перменной класса родителя
будет доступна только та часть кода которая в ней собтвенно есть те дополнительные функции и поля из потомка ей недоступны

В данном случае переменной person, которая представляет тип Person, присваивается ссылка на объект Employee.
 Но чтобы сохранить ссылку на объект одного класса в переменную другого класса, необходимо выполнить 
 преобразование типов - в данном случае от типа Employee к типу Person.

 class Person
    {
        public string Name { get; set; }
        public Person(string name)
        {
            Name = name;
        }
        public void Display()
        {
            Console.WriteLine($"Person {Name}");
        }
    }

    class Employee : Person
    {
        public string Company { get; set; }
        public Employee(string name, string company) : base(name)
        {
            Company = company;
        }

    }

    class Client : Person
    {
        public string Bank { get; set; }
        public Client(string name, string bank) : base(name)
        {
            Bank = bank;
        }
    }

    class Program
    {
       
        static void Main(string[] args)
        {
            Employee employee = new Employee("Tom", "Microsoft");
            Person person = employee;   // преобразование от Employee к Person
            // В итоге переменные employee и person будут указывать на один и тот же объект в памяти,
            // но переменной person будет доступна только та часть, которая представляет функционал типа Person.
            // Это назыывается  восходящие преобразования


            if (employee is Person person)//это аналогично вышенпаисной констркуции 
            //здесь идет проверка на можно ли преобразовать выражение в указанный тип и, если можно,
            // приводит переменную к переменной этого типа.
        	{
        		//varname назначается только в пределах инструкции if
            Console.WriteLine(person.Name);
            Console.WriteLine(person.Company);//это выдаст ошибку тк поле Company принадлежит к классу Employee
            //а ссылочная перменная оьект person указывает сейчас на на клсасс в heap Person  
        	}

            Console.WriteLine(person.Company);//это выдаст ошибку тк поле Company принадлежит к классу Employee
            //а ссылочная перменная оьект person указывает сейчас на на клсасс в heap Person  
			Console.WriteLine(person.Name);
            Person person1 = new Client("Bob", "ContosoBank");//Здесь переменная person1, которая представляет
            //тип Person, хранит ссылку на объект Client, поэтому также выполняется восходящее неявное преобразование
            //от производного класса Client к базовому типу Person.
 			
            Console.ReadKey();

            Так как тип object -базовый для всех остальных типов, то преобразование к нему будет 
            производиться автоматически.

            object person2 = new Employee("Tom", "Microsoft");  // от Employee к object
            object person3 = new Client("Bob", "ContosoBank");  // от Client к object
            object person4 = new Person("Sam");
            
           
        }
    }

//это
    Employee employee = new Employee("Tom", "Microsoft");
    Person person = employee;
//аналогично нижеследуеще зхаписи толоко без создание отдельной перменной employee
    Person person = new Employee("Tom", "Microsoft");
------------------------------------------
Нисходящие преобразования. Downcasting


нисходящие преобразования или downcasting - от базового типа к производному.
Но автоматически такие преобразования не проходят, ведь не каждый человек (объект Person) является сотрудником 
предприятия (объектом Employee). И для нисходящего преобразования необходимо применить явное преобразования,
указав в скобках тип, к которому нужно выполнить преобразование:

 			Employee employee = new Employee("Tom", "Microsoft");
            Person person = employee;   // преобразование от Employee к Person
            //переменная person хранит ссылку на объект Employee
            //сперва апкаст а потом уже даункасат 
            //Потому, что объект создан и занимает в памяти 20 байт. И о не как не может кастнуться в объект который 
            //должен занимать 20 Мб.

            Employee employee2 = person;// так нельзя, нужно явное преобразование 

            Employee employee1 = (Employee)person;//после апкаста можно уже производить явное преобразование от
            // Person к Employee

            Console.WriteLine(employee1.Name +" "+ employee1.Company);




            object obj = new Employee("Bill", "Microsoft");
            // чтобы обратиться к возможностям типа Employee,явно приводим объект к типу Employee
            Employee emp = (Employee)obj;//В этом случае переменной obj присвоена ссылка на объект Employee, 
//поэтому мы можем преобразовать объект obj к любому типу который располагается в иерархии классов между 
            //типом object и Employee.

Если нам надо обратиться к каким-то отдельным свойствам илиз методам объекта, то нам необязательно присваивать 
преобразованный объект переменной :

// Объект Employee также представляет тип object
object obj = new Employee("Bill", "Microsoft");
 
// преобразование к типу Person для вызова метода Display
((Person)obj).Display();
// либо так
// ((Employee)obj).Display();
 
// преобразование к типу Employee, чтобы получить свойство Company
string comp = ((Employee)obj).Company;


------------------------------------------
is as 

Структура - это тип значения, поэтому ее нельзя использовать с as оператором. 
as Оператор должен иметь возможность присвоить значение NULL ,
если терпит неудачу. Это возможно только со ссылочным типом или типом значения, допускающим значение NULL.

is в случае апкаста
 if (employee is Person person)//это аналогично вышенпаисной констркуции 
            //здесь идет проверка на можно ли преобразовать выражение в указанный тип и, если можно,
            // приводит переменную к переменной этого типа.
        	{
        		//varname назначается только в пределах инструкции if
            Console.WriteLine(person.Name);
            Console.WriteLine(person.Company);//это выдаст ошибку тк поле Company принадлежит к классу Employee
            //а ссылочная перменная оьект person указывает сейчас на на клсасс в heap Person  
        	}

is в случае даункаста
Person person = new Person("Tom");
if(person is Employee)
{
    Employee emp = (Employee)person;
    Console.WriteLine(emp.Company);
}
else
{
    Console.WriteLine("Преобразование не допустимо");
}      	

as в случае даункаста

Person person = new Person("Tom");
Employee emp = person as Employee;//пытается преобразовать выражение к определенному типу в
// случае неудачного преобразования выражение будет содержать значение null 
if (emp == null)
{
    Console.WriteLine("Преобразование прошло неудачно");
}
else
{
    Console.WriteLine(emp.Company);
}

==========================================


--преобразование типов перегрзка--
------------------------------------------

public static implicit|explicit operator Тип_в_который_надо_преобразовать(исходный_тип param)// explicit если 
//преобразование явное и implicit если преобразование неявное
{
    // логика преобразования
}
Какие операции преобразования делать явными,а какие неявные,не столь важно, это решает разработчик по своему усмотрению.
------------------------------------------
class Counter
{
public int Seconds { get; set; }

    public static explicit operator int(Counter counter)//преобразует объект Counter к типу int, то есть получает 
    //из Counter число.
    {
        return counter.Seconds;
    }

     public static implicit operator Counter(int x)//преобразует число объект типа int к типу Counter. 

    {
        return new Counter { Seconds = x };// тут создается новый объект Counter, у которого устанавливается 
        //свойство Seconds.
    }
}


    static void Main(string[] args)
    {
        Counter counter1 = new Counter { Seconds = 23 };

        int x = (int)counter1;//преобразует объект Counter к типу int x, то есть получает из Counter число.explicit
        //и это преобразование явное
    {
        Console.WriteLine(x);   

        Counter counter2 = x;//преобразует число x объект типа int к типу Counter. implicit и это преобразование неявное
        Console.WriteLine(counter2.Seconds);  // 23
    }

если для преобразования потребуется более сложная логика, то просто так написать не получится. Например,
 во втором примере при преобразовании от типа Counter к типу Timer сложность преобразования возрастает,
 соотвественно лучше один раз определить оператор, чем по сто раз писать один и тот же набор операций. 
 А в случае преобразований с более сложной логикой это тем более актуально

class Timer
{
    public int Hours { get; set; }
    public int Minutes { get; set; }    
    public int Seconds { get; set; }
}
class Counter
{
    public int Seconds { get; set; }
 
    public static implicit operator Counter(int x)
    {
        return new Counter { Seconds = x };
    }
    public static explicit operator int(Counter counter)
    {
        return counter.Seconds;
    }
    public static explicit operator Counter(Timer timer)
    {
        int h = timer.Hours * 3600;
        int m = timer.Minutes * 60;
        return new Counter { Seconds = h + m + timer.Seconds };
    }
    public static implicit operator Timer(Counter counter)
    {
        int h = counter.Seconds / 3600;
        int m = (counter.Seconds % 3600) / 60;
        int s = counter.Seconds % 60;
        return new Timer { Hours = h, Minutes = m, Seconds = s };
    }
}

static void Main(string[] args)
{
    Counter counter1 = new Counter { Seconds = 115 };
 
    Timer timer = counter1;
    Console.WriteLine($"{timer.Hours}:{timer.Minutes}:{timer.Seconds}"); // 0:1:55
 
    Counter counter2 = (Counter)timer;
    Console.WriteLine(counter2.Seconds);  //115
     
    Console.ReadKey();
}
==========================================


--виртуальные (virtual) методы и свойства--
------------------------------------------
угу значит виратуальный метод или свойства могу находится в обычном классе родителе, могут иметь свою функциональность,
 при этом могут быть (а могут и не быть, тогда их функционал будет просто использован из класса родителя)  
 перпоределнными в потмках, вызыватся через экземпляр класса в котором они обьявлены.

простой пример это у класса Human есть метод Display выавода на экран поля Name , а в классе наслднике Employee 
этот метод перопределяется для вывода 
на экарн Name из класса Human + Company из класса Employee(те приобретает доп функциональность)

модификатор доступа должен быть одинаковым

class Person
{
    public string Name { get; set; }
    public Person(string name)
    {
        Name = name;
    }
    public virtual string Display()//методы и свойства, которые мы хотим сделать доступными для переопределения,
    // в базовом классе помечается модификатором virtual. Такие методы и свойства называют виртуальными.
    {
        return Name;
    }
}
class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company) : base(name)
    {
        Company = company;
    }

    //методы можно перопрделть а можно оставлять как есть в этом случае объекты Employee будут использовать реализацию 
    //метода Display из класса Person те из базового класса
    public override string Display();//А чтобы переопределить метод в классе-наследнике, этот метод определяется 
    //с модификатором override. 

    //Переопределенный метод в классе-наследнике должен иметь тот же набор параметров, что и виртуальный метод в базовом классе.
    {
        if (Name =="Tom")
        {
            Name = "Max";
            return Name + $" {Company}";
        }
        return base.Display() + $" {Company}";
    }
}

class EmployeeTwo : Employee
{
    public int Age { get; set; }
    public EmployeeTwo(string name, string company, int age) : base(name, company)
    {
        Age = age;
    }

    public override string Display()//Виртуальные методы базового класса определяют интерфейс всей иерархии, 
    //то есть в любом производном классе, который не является прямым наследником от базового класса, можно 
    //переопределить виртуальные методы.
    //Например, мы можем определить класс Manager, который будет производным от Employee, и в нем также переопределить 
    //метод Display.
    {
        return base.Display() + $" {Age}";
    }
}
class Program
{
    static void Main(string[] args)
    {
        Person p1 = new Person("Bill");
        Console.WriteLine(p1.Display());//Bill
        // вызов метода Display из класса Person

        Employee p2 = new Employee("Tom", "Microsoft");
        Console.WriteLine(p2.Display());//Max Microsoft
        // вызов метода Display из класса Person

        EmployeeTwo p3 = new EmployeeTwo("Tommi", "Microsoftuuuss", 20);
        Console.WriteLine(p3.Display());//Tommi Microsoftuuuss 20

        Console.ReadKey();
    }
}

Также можно запретить переопределение методов и свойств. В этом случае их надо объявлять с модификатором sealed

 public override sealed string Display();//производится только в произодном классе в класс родителе смысл делать 
 //нет тк проще убраьт virtual

------------------------------------------
виртуальные свойства

так же монжно перопрделть свойства, модификатор доступа должен быть одинаковым

class Credit
{
    public virtual decimal Sum { get; set; }//свойства, которые мы хотим сделать доступными для переопределения,
    // в базовом классе помечается модификатором virtual. Такие методы и свойства называют виртуальными.
}
class LongCredit : Credit
{
    private decimal sum;
    public override decimal Sum//А чтобы переопределить свойство в классе-наследнике, этот свойство определяется 
    //с модификатором override. 
    //Переопределенный свойство в классе-наследнике должен иметь тот же набор параметров, 
    //что и виртуальный свойство в базовом классе.
    {
        get
        {
            return sum;
        }
        set
        {
            if (value > 1000)
            {
                sum = value;
            }
        }
    }
}
class Program
{
    static void Main(string[] args)
    {
        LongCredit credit = new LongCredit { Sum = 6000 };
        credit.Sum = 490;
        Console.WriteLine(credit.Sum);
        Console.ReadKey();
    }
}

==========================================



--сокрытие--
------------------------------------------
это когда скрываем в производном классе функциноал базового класса
определение в классе-наследнике метода или свойства,которые соответствует по имени и набору параметров методу или
 свойству базового класса.

 Для сокрытия членов класса применяется ключевое слово new. 

 class Person
    {

        public string FirstName { get; set; }
        public string LastName { get; set; }

        public Person(string firstName, string lastName)
        {
            FirstName = firstName;
            LastName = lastName;
        }

        public void Display()
        {
            Console.WriteLine($"{FirstName} {LastName}");
        }

        public void DisplayIs()
        {
            Console.WriteLine($"{FirstName} {LastName} AZazain");
        }
    }

    class Employee : Person
    {
        public string Company { get; set; }

        public Employee(string firstName, string lastName, string company)
            : base(firstName, lastName)
        {
            Company = company;
        }

        public new void Display() //этотт метод скрывает рализацию из класса Persone при этом неважно является ли метод
        // в классе родителя виртуальным или нет, если используется  var kek = (Employee) bob то мы получаем на выходе 
        //метод из Employee а не методж из класса Person это полезно использовать когжа нпример метод Display в 
        //базовом классе не является виртуальным,мы не можем его переопределить, и тут нам поможет именно такая
        // конструкция какnew void Display()
        {
            Console.WriteLine($"{FirstName} {LastName} работает в {Company}");
        }

        public void DisplayCompany()
        {
            Console.WriteLine($"{Company}");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Person bob = new Person("Bob", "Robertson");
            bob.Display(); // Bob Robertson

            bob = new Employee("Max", "Robertson", "okla"); //сперва апкаст а потом уже даункасат 
            //Потому, что объект создан и занимает в памяти 20 байт. И о не как не может кастнуться в объект
            // который должен занимать 20 .переменной bob будет доступна только та часть, которая представляет 
            //функционал типа Person.Это назыывается  восходящие преобразования
            bob.Display(); //Max Robertson 
            bob.DisplayIs();//Max Robertson AZazain

            bob.DisplayCompany(); // выдаст ошибку оптому что Person недоступен функционал типа Employee.

            var kek = (Employee) bob; //здесь происходит даункаст 
            kek.Display(); //Max Robertson работает в okla здесь используется сокрытый метод Display тк кек 
            //это обьект класса Employee 

            Employee tom = new Employee("Tom", "Smith", "Microsoft");//используется сокрытый метод Display 
            //тк кек это обьект класса Employee 
            tom.Display(); // Tom Smith работает в Microsoft
            Console.ReadKey();
        }
    }

------------------------------------------
аналогично можно реализовтаь сокрытие свойств 
class Person
{
    protected string name;
    public string Name
    {
        get { return name; }
        set { name = value; }
    }
}
class Employee : Person
{
    public new string Name
    {
        get { return "Employee " + base.Name; }
        set { name = value; }
    }
}
------------------------------------------
а так же переменные и константы
class ExampleBase
{
    public readonly int x = 10;
    public const int G = 5;
}
class ExampleDerived : ExampleBase
{
    public new readonly int x = 20;
    public new const int G = 15;
}

==========================================



--Абстрактные классы и члены классов--
------------------------------------------
а вот абстрактные класс может иметь как обыкновенные переменные и методы и конструкторы (со стандартным наполнением 
и объявлением) так и абстрактные методы и переменные (но тогда у них не должно  быть тела функциональности, 
они должны быть обязательно переопределены в потомках, а так же класс в которм есть хоть один абстрактный член 
должен быть сам абстрактным), и вот  эти абстракты не могут быть вызваны в отличии от вируталов через экземпляры. 
Аабстрактные классы как бы обьеднияют классы наследники какимито общими свойствами.

например есть фигура геометрическая по сути она без оперделения круга там или квадрат она не может сущетсвовать, 
и вот только когда мы преопределяем класс фигуры с полями типа Площадь и Периметр в какомнибудь там круге или 
треугольнике только там она начинает сущетсовать как бы

 при определении абстрактных классов используется ключевое слово abstractb и мы не можем использовать конструктор
  абстрактного класса для создания его объекта
abstract class Human
{
	...

Human h = new Human();//выдсат ошибку

эти классы используются для того чтобы определять общую функциональность например, имя и метод вывода на консоль имени

abstract class Person
{
    public string Name { get; set; }
 
    public Person(string name)
    {
        Name = name;//тут инициализировать некоторые общие для производных классов 
        //переменные и свойства, как в случае со свойством Name
    }
 
    public void Display()
    {
        Console.WriteLine(Name);
    }
    public abstract void DisplayIs();//определим абстрактный класс 
}
 
class Client : Person
{
    public int Sum { get; set; }    // сумма на счету
 
    public Client(string name, int sum)
        : base(name)
    {
        Sum = sum;
    }

     public override void DisplayIs()//переопреедлим асбтакртный класс из родителя, 
     //если этого не сделать компилятор выдаст ошибку 
        {
            Console.WriteLine($"{Name} имеет счет на сумму {Sum}");
        }
}
 
class Employee : Person
{
    public string Position { get; set; } // должность
 
    public Employee(string name, string position) 
        : base(name)
    {
            Position = position;
    }

     public override void DisplayIs()//переопреедлим асбтакртный класс из родителя, 
     //если этого не сделать компилятор выдаст ошибку 
        {
            Console.WriteLine($"{Position} {Name}");
        }
}

//И хотя в примере конструктор класса Person не вызывается, тем не менее производные классы Client и Employee 
//могут обращаться к нему.
 Client client = new Client("Tom", 500);
Employee employee = new Employee("Bob", "Apple");
client.Display();//Tom
employee.Display();//Bob
Person person = new Person ("Bill");//выдсат ошибку
------------------------------------------
абстрактные члены классов не имеют никакого функционала

Методы
Свойства
Индексаторы
События

abstract class Person
{
    public string Name { get; set; }
 
    public Person(string name)
    {
        Name = name;
    }
}

class Client : Person
{
    public int Sum { get; set; }    // сумма на счету
 
    public Client(string name, int sum)
        : base(name)
    {
        Sum = sum;
    }
    public override void Display()
    {
        Console.WriteLine($"{Name} имеет счет на сумму {Sum}");
    }
}

------------------------------------------
Следует отметить использование абстрактных свойств. Их определение похоже на определение автосвойств

abstract class Person
{
    public abstract string Name { get; set; }
}

class Client : Person
{
    private string name;
 
    public override string Name
    {
        get { return "Mr/Ms. " + name; }
        set { name = value; }
    }

    //или

    public override string Name { get; set; }
}
------------------------------------------
если нужно отказаться от реализации абстрактных членов в классе потомке нужно сделать его тоже абстрактным
abstract class Person
{
    public abstract string Name { get; set; }
}
 
abstract class Manager : Person
{

}
------------------------------------------
Xрестоматийным примером является система геометрических фигур. В реальности не существует геометрической фигуры как 
таковой.
 Есть круг, прямоугольник, квадрат, но просто фигуры нет. Однако же и круг, и прямоугольник имеют 
 что-то общее и являются фигурами
// абстрактный класс фигуры
abstract class Figure
{
    // абстрактный метод для получения периметра
    public abstract float Perimeter();
    // абстрактный метод для получения площади
    public abstract float Area();
}
// производный класс прямоугольника
class Rectangle : Figure
{
    public float Width { get; set; }
    public float Height { get; set; }
 
    public Rectangle(float width, float height)
    {
        this.Width = width;
        this.Height = height;
    }
    // переопределение получения периметра
    public override float Perimeter()
    {
        return Width * 2 + Height * 2;
    }
    // переопрелеление получения площади
    public override float Area()
    {
        return Width * Height;
    }
}

==========================================



--System.Object и его методы--
------------------------------------------
 мы можем переопределить метод ToString()

(string)obj производит явное преобразование obj в string. obj должен уже быть, string чтобы это удалось.

obj.ToString()получает строковое представление obj путем вызова ToString() метода. 
Это в отличии от явного приведения никогда не вызывовет исключения (если obj != null).

class Clock
    {
        public int Hours { get; set; }
        public int Minutes { get; set; }
        public int Seconds { get; set; }

        public override string ToString()//используется ключевое слово override для перопределения ToString
        {
            return $"{Hours}:{Minutes}:{Seconds}";
        }
    }
class Program
    {
        private static void Main(string[] args)
        {
            Clock clock = new Clock { Hours = 15, Minutes = 34, Seconds = 53 };
            Console.WriteLine(clock.ToString()); // выведет 15:34:53
             
            Console.Read();
        }
    }

------------------------------------------
Метод GetHashCode позволяет возвратить некоторое числовое значение(уникальное для каждого обекта), которое будет 
соответствовать данному объекту или его хэш-код. По данному числу, например, можно сравнивать объекты. 

 public string Name { get; set; }
 
    public override int GetHashCode()
    {
        return Name.GetHashCode();
    }

перопределние GetHashCode
 class human
    {
        public string Name { get; }

        public human(string name)
        {
            Name = name;
        }

        public override int GetHashCode()//перопределяем получение хашкода на проеку хешкода только имени 
        {
            return Name.GetHashCode();
        }
    }

human h = new human("Max");
human g = new human("Max");
Console.WriteLine($"client {h.GetHashCode()} ,clientone {g.GetHashCode()}" );//client 1627628113, 
//clientone 1627628113 hash коды одинаковые 

//тк мы проверяе хеш только имени
------------------------------------------
Метод GetType позволяет получить тип данного объекта

Person person = new Person { Name = "Tom" };
Console.WriteLine(person.GetType());   
В отличие от методов ToString, Equals, GetHashCode метод GetType не переопределяется.;
------------------------------------------
С помощью ключевого слова typeof мы получаем тип класса и сравниваем его с типом объекта. 
И если этот объект представляет тип Client, то выполняем определенные действия.

object person = new Person { Name = "Tom" };
if (person.GetType() == typeof(Person))
    Console.WriteLine("Это реально класс Person");

------------------------------------------

Equals(gthjghtltkztncz) принимает в качестве параметра объект любого типа, который мы затем приводим к текущему, 
если они являются объектами одного класса.
 Затем сравниваем по именам. Если имена равны, возвращаем true, что будет говорить, что объекты равны. 
 Однако при необходимости реализацию метода можно сделать более сложной, например, 
 сравнивать по нескольким свойствам при их наличии.

Person person1 = new Person { Name = "Tom" };
Person person2 = new Person { Name = "Bob" };
Person person3 = new Person { Name = "Tom" };
bool p1Ep2 = person1.Equals(person2);   // false
bool p1Ep3 = person1.Equals(person3);   // true

Для типов значений == и Equals не имеет разницы, отличается ReferenceEquals, выдающий false, к примеру, для двух
 переменных типа int, равных 0 (потому, что сравнивает не значения, а ссылки). Для ссылочных типов эквивалентны 
 все три способа ==, Equals и ReferenceEquals,сравнивать значения аналогично типам значений возможно только с
 помощью переопределения, как и описано в примере
==========================================

--generics обобщения (--упаковка распкаовка boxing unboxing--)--
------------------------------------------
упаковка распкаовка

 class Account
    {
        public object Id { get; set; }
        public int Sum { get; set; }
    }

    Account acc1 = new Account();
    Account acc2 = new Account();
            
            //упкаовка и распкаовка ведут к снижению производительностьи и нарушению безопасности типа если
            // обьекты изменяются извне и мы можем не знать какие значения хранятся в этом обьекте если не те
            //к торым мы распаковываем происходит System.InvalidCastException

            acc1.Id = 45;// происходит упаковка boxing, int упакаютеся в тип object
            int intID = (int)acc1.Id;//обратный процесс распокавка unboxing

            string intID = (string)acc1.Id;//выдаст ошибку изза нессотвтествия типов

            acc2.Id = "55";// происходит упаковка boxing, int упакаютеся в тип object
            string str = (string)acc2.Id;//обратный процесс распокавка unboxing

            Console.WriteLine(str + intID);
            Console.Read();


------------------------------------------
generics
 //чтобы решить проблему упаковки распкаовки и проблему безопасноти типов исопльзу.тся обощения
    class Account<T>//это универсальный парметр всемто него можно пердать любой тип
    {
        public T Id { get; set; }
        public int Sum { get; set; }
    }
    class Program
    {
        static void Main(string[] args)
        {
            //после создания обьектов не происходит не упаковки не распкаовки
            Account<int> acc1 = new Account<int>();//тк класс теперь обобщенный нужно прри создани экземпляра 
            //указать какой типа экземпляр будет исопльзовать
            Account<string> acc2 = new Account<string>();//тк класс теперь обобщенный нужно прри создани экземпляра
            //указать какой типа экземпляр будет исопльзовать

            acc1.Id = 11;
            Console.WriteLine(acc1.Id);
            Console.Read();
        }
    }
------------------------------------------
так же можно использовать класс с несоклькими генериками и генерик с включенным в него классом с генериком

class Instantiator<U,V>
    {
        public U FromInstance { get; set; }
        public U ToInstance { get; set; }
        public V Code { get; set; }

    }
    class Account<T>
    {
        public T Id { get; set; }
        public int Sum { get; set; }
    }

class Program
    {
        static void Main(string[] args)
        {
            Account<int> acc1  = new Account<int>();
            //присваиваем значения для будущего их сипользхования в генерике Instantiator<Account<int>,...
            acc1.Id = 10;
            acc1.Sum = 20;
            Account<int> acc2 = new Account<int>();
            //присваиваем значения для будущего их сипользхования в генерике Instantiator<Account<int>,...
            acc2.Id = 30;
            acc2.Sum = 60;
            Account<string> acc3 = new Account<string>();

            Instantiator<Account<int>,string> i = new Instantiator<Account<int>, string>//кладев в обьект i наш класс 
            //Action с генериком int, а вторым генриком кладем простую строку
            {
                FromInstance = acc1,//кладем сюда экземпляр Acction<int>acc1 с вложеиями ввиде acc1.Id = 10 и
                // acc1.Sum = 20
                ToInstance = acc2,//кладем сюда экземпляр Acction<int>acc2 с вложеиями ввиде acc1.Id = 30 и
                // acc1.Sum = 60
                Code = "2520"//кладем сюда строку
            };

Console.WriteLine($"{i.FromInstance.Id} {i.FromInstance.Sum} {i.ToInstance.Id} {i.ToInstance.Sum} { i.Code}");

            Instantiator<int, string> j = new Instantiator<int, string>//здесь просто тандартный рпимер с двумя 
            //генериками ввиде инт и стринг
            {
                FromInstance = 20,
                ToInstance = 10,
                Code = "2010"
            };


------------------------------------------
Мы не можем использовать конструктор для создания объекта типа T. Если нам нужно создать значение по умолчанию,
 то для этого необходимо использовать оператор default
 
 class Instantiator<T>
    {
        public T instance;
        public Instantiator()
        {
            instance = default(T);//здесь испоользуется дефаулт
        }
    }

        static void Main(string[] args)
        {
            Instantiator<int> i = new Instantiator<int> {instance = 10};
            Console.WriteLine(i.instance);

        }

------------------------------------------ 
так же можно использовать геенрик методы 

            int x = 10;
            int y = 30;
            Swap(ref x, ref y);//ref используется чтобы наш метод поменял значение непосрдсвтенно в перменны а,
            // не только внутри себя 

            //int x = 30; после работы метода в перменных выше будет так
            //int y = 10; после работы метода в перменных выше будет так

            string xx = "x";
            string yy = "y";
            Swap(ref xx, ref yy);
             // string xx = "y"; после работы метода в перменных выше будет так
            // string xx = "x"; после работы метода в перменных выше будет так

            void Swap<T>(ref T x, ref T y)
            {
                T temp = x;
                x = y;
                y = temp;
                Console.WriteLine($"x = {x},y = {y}");
            }

==========================================



--generic where ограничения обощений--
------------------------------------------
С помощью универсальных параметров мы можем типизировать обобщенные классы любым типом. 
Однако иногда возникает необходимость оргриничить генерик определенным типом и его наследниками.

делается это все потому что в этом случае будет идти преобразование типов. 
Параметризация generic <T> where : class позволяет избежать преобразований типов

В качестве ограничений мы можем использовать следующие типы:

Классы

Интерфейсы

class - универсальный параметр должен представлять класс

struct - универсальный параметр должен представлять структуру при этом использовать в качестве ограничения конкретные 
структуры в отличие от классов нельзя.

new() - универсальный параметр должен представлять тип, который имеет общедоступный (public) конструктор без параметров

------------------------------------------
class Account
{
    public int Id { get; private set; } // номер счета
    public int Sum { get; set; }

    public Account(int _id)
    {
        Id = _id;
    }
}

class Persone : Account
{
    public string Name { get; set; }
    public Persone(int id, string name): base(id)
    {
        Name = name;
    }
}

Следует учитывать, что только один класс может использоваться в качестве ограничения
Параметризация generic <T> where : class позволяет избежать преобразований типов

class Transaction<T> where T : Account// с помощью выражения where T : Account мы указываем,
// что используемый тип T обязательно должен быть классом Account или его наследником
{
    // Благодаря подобному ограничению мы можем использовать внутри класса Transaction
    // все объекты типа T именно как объекты Account и соответственно обращаться к их свойствам и методам.
    public T FromAccount { get; set; } // с какого счета перевод
    public T ToAccount { get; set; } // на какой счет перевод
    public T NameAccount { get; set; }

    public int Sum { get; set; } // сумма перевода

    public void Execute()
    {
        if (FromAccount.Sum > Sum)
        {
            FromAccount.Sum -= Sum;
            ToAccount.Sum += Sum;
            Console.WriteLine($"Счет {FromAccount.Id}: {FromAccount.Sum}$ \nСчет {ToAccount.Id}: {ToAccount.Sum},");//
            //благодаря where в перменные можно записать поля и методы относящиеся к классу которым ограничен данный генерик

            //Console.WriteLine($"Name{NameAccount.Name}");//вызовет ошибку тк это поле из наследника класса Account
        }
        else
        {
            Console.WriteLine($"Недостаточно денег на счете {FromAccount.Id}");
        }
    }
}

 class DemandAcc : Account
    {
        public DemandAcc(int id) : base(id)
        {
            
        }
    }

class Program
{
    static void Main(string[] args)
    {

        Account acc1 = new Account(1) {Sum = 4500};
        Account acc2 = new Account(2) {Sum = 5000};


        DemandAcc acc3 = new DemandAcc(3){Sum = 10000};
        DemandAcc acc4 = new DemandAcc(4){Sum = 3000};

        Transaction<Account> transaction1 = new Transaction<Account>//использумем указанный в  where T : Account класс
        {
            FromAccount = acc1,  
            ToAccount = acc2,
            Sum = 300
        };
        transaction1.Execute();


        Transaction<DemandAcc> transaction2 = new Transaction<DemandAcc>//использумем наследника указанного 
        //в where T : Account класса Account
           {
               FromAccount = acc3,//если бы в классе Transaction мы вместо типа T FromAccount, использовали бы тип Account
               // FromAccount, в это сткрочке мы получили бы апкаст тк как acc3 чтобы присовится в перменную FromAccaunt 
               //которая в наешму слуаае является Account, те классом родителем, нам пришлоь бы произвести апкаст 
               //преобразовангие от производнолго к базовому классу

               ToAccount = acc4,//если бы в классе Transaction мы вместо типа T FromAccount, использовали бы тип Account
               // FromAccount, в это сткрочке мы получили бы апкаст тк как acc3 чтобы присовится в перменную FromAccaunt 
               //которая в наешму слуаае является Account, те классом родителем, нам пришлоь бы произвести апкаст 
               //преобразовангие от производнолго к базовому классу
               Sum = 6900
           };
           DemandAcc acc5 = (DemandAcc)transaction2.FromAccount;//и если бы мны захотели бы полчуить обрантно данный обьект в 
           //перепенную DemandAcc нам пришлось бы произсодить даункаст,но в случаее если бы мы использволи where T : Account 
           //этоыго бы делать не пришлось -> DemandAcc acc5 = transaction2.FromAccount;
             DemandAcc acc5 = (DemandAcc)transaction2.ToAccount;//и если бы мны захотели бы полчуить обрантно данный обьект в 
           //перепенную DemandAcc нам пришлось бы произсодить даункаст,но в случаее если бы мы использволи where T : Account 
           //этоыго бы делать не пришлось -> DemandAcc acc5 = transaction2.ToAccount;
        ransaction2.Execute();

        Console.ReadLine();
    }
}
}

------------------------------------------
В качестве ограничения также может выступать и обобщенный класс

class Account<T>//Класс Account же может быть типизирован абсолютно любым типом
   {
       public T Id { get; private set; } // номер счета
       public int Sum { get; set; }
       public Account(T _id)
       {
           Id = _id;
       }
   }
   class Transaction<T> where T : Account<int>//В данном случае класс Transaction типизирован классом Account<int>
       // класс Transaction может использовать только объекты класса Account<int> или его наследников
   {
       public T FromAccount { get; set; }  // с какого счета перевод
       public T ToAccount { get; set; }    // на какой счет перевод
       public int Sum { get; set; }        // сумма перевода

       public void Execute()
       {
           if (FromAccount.Sum > Sum)
           {
               FromAccount.Sum -= Sum;
               ToAccount.Sum += Sum;
               Console.WriteLine($"Счет {FromAccount.Id}: {FromAccount.Sum}$ \nСчет {ToAccount.Id}: {ToAccount.Sum}$");
           }
           else
           {
               Console.WriteLine($"Недостаточно денег на счете {FromAccount.Id}");
           }
       }
   }

   class Program
   {
       static void Main(string[] args)
       {
           Account<int> acc1 = new Account<int>(1857) { Sum = 4500 };
           Account<int> acc2 = new Account<int>(3453) { Sum = 5000 };

           Transaction<Account<int>> transaction1 = new Transaction<Account<int>>
           {
               FromAccount = acc1,
               ToAccount = acc2,
               Sum = 300
           };

            transaction1.Execute();

           Account<string> acc1 = new Account<string>("34") { Sum = 4500 };
           Account<string> acc2 = new Account<string>("45") { Sum = 5000 };
          
           //Transaction<Account<string>> transaction2 = new Transaction<Account<string>>// так нельзя написать, 
           //так как Bank должен быть типизирован классом Account<int> или его наследником
           {
              FromAccount = acc1,
               ToAccount = acc2,
               Sum = 900
           };

           Console.Read();
       }
   }

------------------------------------------
Есть ряд стандартных ограничений, которые мы можем использовать. можно задать в качестве ограничения ссылочные типы:
частности, можно указать ограничение, чтобы использовались только структуры или другие типы значений 

------------------------------------------
ограничение структуой

 class Transaction<T>  where T : struct
{
    public T FromAccount { get; set; } // с какого счета перевод
    public T ToAccount { get; set; } // на какой счет перевод
}


 Transaction<int> transaction3 = new Transaction<int>//тк int предстявляет обой сткрутктуру
            //мы можем сделать так
            {
                //соответвенно теперь нужно предостаивть FromAccount и ToAccount числовые значения
                FromAccount = 123,
                ToAccount = 321,  
            };

НО при этом использовать в качестве ограничения конкретные те (имена структур) структуры в отличие от классов нельзя!

------------------------------------------
ограничение классом

class Transaction<T> where T : class
{}

------------------------------------------
ограничение new()

А также можно задать с помощью слова new в качестве ограничения класс или структуру, которые имеют общедоступный 
конструктор без параметров

class Transaction<T> where T : new()//это значит что ограничивающеи генерик 
//тип дожен поределять констуктор по умолчанию без парметров 
{
    ...
}
class Account//такой обьект впишется в ограничение генерика сверху
    {
        public int Id { get;  set; } 
        public int Sum { get; set; }
        public Account(int _id)
        {
            Id = _id;
        }
        public Account()//для этого нужно просто опеределить вот такой констурктор по умолчанию
        {
            
        }
    }

------------------------------------------
Если для универсального параметра задано несколько ограничений, то они должны идти в определенном порядке
1 Название класса, class, struct. Причем мы можем одновременно определить только одно из этих ограничений. 

2Название интерфейса.

3 new()

interface IAccount
{
    int CurrentSum { get; set;}
}
class Person
{
    public string Name { get; set; }
}
 
class Transaction<T> where T: Person, IAccount, new()//1 Название класса, class, struct
//2Название интерфейса
//3 new()
{
 ...
}

------------------------------------------
Использование нескольких универсальных параметров

class Transaction<U, V>
        where U : Account<int>//Если класс использует несколько универсальных параметров,
        // то последовательно можно задать ограничения к каждому из них
        where V : struct//Если класс использует несколько универсальных параметров, 
        //то последовательно можно задать ограничения к каждому из них

------------------------------------------
Ограничения методов

Подобным образом можно использовать и ограничения методов

private static void Main(string[] args)
{
    Account<int> acc1 = new Account<int>(1857) { Sum = 4500 };
    Account<int> acc2 = new Account<int>(3453) { Sum = 5000 };
 
    Transact<Account<int>>(acc1, acc2, 900);
 
    Console.Read();
}
 
public static void Transact<T>(T acc1, T acc2, int sum) where T : Account<int>//Метод Transact в качестве ограничения
// принимает тип Account<int>.
    if (acc1.Sum > sum)
    {
        acc1.Sum -= sum;
        acc2.Sum += sum;
    }
    Console.WriteLine($"acc1: {acc1.Sum}   acc2: {acc2.Sum}");
}
==========================================


--generic наследование--
------------------------------------------
Один обобщенный класс может быть унаследован от другого обобщенного. При этом можно использовать различные варианты наследования.



==========================================

--await timer--

------------------------------------------
await CommandToFormSupply("Output", "0"); программа дожидается выполнения и только потом перскакивает на следующий 
оператор CommandToFormSupply("Output", "0"); программа не дожидается выполнения и сразу  перскакивает на следующий 
оператор


==========================================


--WinForm--

------------------------------------------
 this.Tag.ToString(); получение тега кнопки

 Debug.WriteLine(cmd); так мождно проследить за выполнением команды в окне output например при нажатии кнопки

==========================================

 --Reflection--

------------------------------------------

 создание словаря с определенгными элементами из класса
------------------------------------------
     private void DictionaryAdd()
        {
          
            var type1 = typeof(Form1)//рефлексим класс по названию
            var type2 = type1.GetFields();// получаем все поля из него

            foreach (var types in type2)
            {
                
                if (types.FieldType.Name == "Button")// если имя типа элеменат == кнопке ... 
                {
                    elems.Add(types.Name, types.GetValue(this));//... то добаляем в словарь
                }
               
            }

            SafeGetComponent<Button>("CalcDelta").BackColor = Color.Red;

        }

         public T SafeGetComponent<T>(string name) where T : Component//присваивание типа определенному элменту 
         //тк рефлекшн возрващает обджекты 
        {
            return elems[name] as T;//.FirstOrDefault(e => e is T component && component.name == name ) as T;
        }

получение данных из приватной (private) перменной через рефлексию
------------------------------------------
  class Point
     {
         private int x;
 
         public void SetX(int x)
         {
             this.x = x;
         }
     }

  static void Main(string[] args)
        {
            Point p = new Point();
            p.SetX(3);

            var str = GetInstanceField(typeof(Point), p, "x");
            var ss = (int) str;
            Console.WriteLine(ss);
            Console.ReadLine();
        }

        //Type type -  для имени класса (typeof(имя класса),  object instance для экземпляраа класса object 
        //экз. класса, string fieldName - для имени перменной
        internal static object GetInstanceField(Type type, object instance, string fieldName)
        {
            //задаем параметр поиска 
            BindingFlags bindFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic
                                     | BindingFlags.Static;
            FieldInfo field = type.GetField(fieldName, bindFlags);
            //возвращаем значение искомой пермененной в виде object
            return field.GetValue(instance);
        }
    }




==========================================



--Циклы--
------------------------------------------

пример switch

  return key switch
            {
                "c" => new ChatClient(),
                "s" => new ChatServer(),
                _ => null
            };


public StopBits ConvertStopBits(int stopBit)
        {
            return stopBit switch
            {
                1 => StopBits.One,
                2 => StopBits.Two,
                _ => StopBits.One
            };
        }

        
==========================================




--Делегаты--
------------------------------------------
Делегаты представляют такие объекты, которые указывают на методы. 
То есть делегаты - это указатели на методы и с помощью делегатов мы можем вызвать данные методы.

Если делегат принимает параметры, то в метод Invoke передаются значения для этих параметров.

Другой пример анонимных методов - передача в качестве аргумента для параметра, который представляет делегат
------------------------------------------
delegate void MessageHandler(string message);
    static void о в одной используется ?Main(string[] args)
    {
        ShowMessage("hello!", delegate(string mes){ Console.WriteLine(mes); });//Здесь всего лишь передаем параметры 
        //для функции
    }

    static void ShowMessage(string mes, MessageHandler handler) //handler теперь указывает на анонимный метод 
    //и по сути является им
    {
        handler(mes); Отсюда вызывается сообщение на консоль!
    }

использование делегатов в качестве парметров анонимного метода;
------------------------------------------
 int[] integers = { 2, 7, 3, 6, 5, 4, 7, 8, 9 };

            // найдем сумму чисел больше 5
            int result = Sum(integers, ss => ss > 5);//эта записаь аналогична нижеследующей
            Console.WriteLine(result);

            // найдем сумму четных чисел
            int result2 = Sum(integers, delegate(int ss)//эта записаь аналогична вышеследующей
            {
                if (ss % 2 == 0)
                {
                    return true;
                }

                return false;
            });
            Console.WriteLine(result2);
        }

        private static int Sum(int[] numbers, IsEqual funcx)
        {
            int result = 0;
            foreach (int i in numbers)
            {
                if (funcx(i))
                    result += i;
            }
            return result;
        }

 обобщённый делегат ;
------------------------------------------
delegate возвращаемый_тип имя_делегата<список_параметров_типа>(список_аргументов);
delegate T 				  Operation	  <T, K ,J>				  (K val, J value);

        class Program
        {
            static void Main(string[] args)
            {
                Operation<decimal, int, string> op = Square;

                Console.WriteLine(op(5, "2"));
                Console.Read();
            }

            static decimal Square(int n, string ss)
            {
                n += int.Parse(ss);
                return n * n;
            }
        }

------------------------------------------    
    View.OpenSettings += () => OpenSettings(); //так можно избежать требований сигнатуры метода при вызове экшана,
    но при этом -= отключит анонимный метод но не OpenSettings()


------------------------------------------
ковариативные и конвариаативные Делегаты

Ковариантность позволяет возвращать из метода объект, тип которого является производным от типа, возвращаемого делегатом.
Ковариантность - выходящие из банка могут быть не просто людьми, но и клиентами банка.
Ковариантностью называется сохранение иерархии наследования исходных типов в производных типах в том же порядке.
 Так, если класс Cat наследуется от класса Animal, то естественно полагать, что перечисление IEnumerable<Cat> 
 будет потомком перечисления IEnumerable<Animal>. Действительно, «список из пяти кошек» — это частный случай «списка из 
 пяти животных». 
 В таком случае говорят, что тип (в данном случае обобщённый интерфейс) IEnumerable<T> ковариантен своему 
 параметру-типу T.

Контрвариантность делегата предполагает, что типом параметра может быть более универсальный тип.
Контрвариантность - в банк могут входить люди. 
Так, если класс String наследуется от класса Object, а делегат Action<T> определён как метод, принимающий объект типа T, 
то Action<Object> наследуется от делегата Action<String>, а не наоборот. Действительно, если «все строки — объекты», 
то «всякий метод, оперирующий произвольными объектами, может выполнить операцию над строкой», но не наоборот.

Как и в случае с обобщенными интерфейсами параметр ковариантного типа применяется только к типу значения,
 которые возвращается делегатом. А параметр контравариантного типа применяется только к входным аргументам делегата.

 ------------------------------------------
Делегаты Action, Predicate и Func

Делегат Action является обобщенным, принимает параметры и возвращает значение void:
------------------------------------------
public delegate void Action<T>(T obj);
 можно передать до 16 значений в метод.
public delegate void Action<T,T2,...T16>(T obj,T2 obj2,...T16 obj16);

Как правило, этот делегат передается в качестве параметра метода и предусматривает вызов определенных действий 
в ответ на произошедшие действия

static void Main(string[] args)
            {
                Action<int, int> op;
                op = Add;
                Operation(10, 6, op);//Оператион через экщен ор делает сумму 10 и 6
                op = Substract;
                Operation(10, 6, op);//Оператион через экщен ор делает умножение 10 и 6
            }

            static void Operation(int x1, int x2, Action<int, int> op)//один и тот же метод делает 
            //разные вещи в зависимости от значения экшена ор
            {
                if (x1 > x2)
                    op(x1, x2);
            }

            static void Add(int x1, int x2)
            {
                Console.WriteLine("Сумма чисел: " + (x1 + x2));
            }

            static void Substract(int x1, int x2)
            {
                Console.WriteLine("Разность чисел: " + (x1 - x2));
            }

Predicate         
------------------------------------------
Predicate<int> isPositive = x => x > 0;

                Console.WriteLine(isPositive(20));
                Console.WriteLine(isPositive(-20));

Func
------------------------------------------
возвращает результат действия и может принимать 
параметры. Он также имеет различные формы: от Func<out T>(), где T - тип возвращаемого значения, 
до Func<in T1, in T2,...in T16, out TResult>(), то есть может принимать до 16 параметров.

TResult Func<out TResult>()
TResult Func<in T, out TResult>(T arg)
TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2)
TResult Func<in T1, in T2, in T3, out TResult>(T1 arg1, T2 arg2, T3 arg3)
TResult Func<in T1, in T2, in T3, in T4, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4)

Метод GetInt() в качестве параметра принимает делегат Func<int, int>, то есть ссылку на метод,
 который принимает число int и возвращает также значение int.
static void Main(string[] args)
          {
              Func<int, int> retFunc = Factorial;
              int n1 = GetInt(6, retFunc);
          }
static int GetInt(int x1, Func<int, int> retF)
  			{
  			    int result = 0;
  			    if (x1 > 0)
 			         result = retF(x1);
  			    return result;
  			}
 static int Factorial(int x)//функц в качестве парметра принимает именно этот метод
            {
                int result = 1;
                for (int i = 1; i <= x; i++)
                {
                    result *= i;
                }

                return result;
            }

------------------------------------------
пример реализации делегатов

delegate void AccountStateHandler(string message);//создаем делегат
 class Person
    {
        private AccountStateHandler _del;//создаем перменную делегата

        private string name;
        public void RegisterHandler(AccountStateHandler del)//создаем регистратор перменной делегата 
        //чтобы потом записать в него метод который будет вызватся при произведении нашего действия
        {
            _del = del;
        }

        public string Name
        {
            get
            {
                return name;
            }
            set => name = value;
        }

        public void DisplayTo()//наше действие 
        {
            _del(name);//когда вызывается это метод происходит вызов делегата те вставленого туда в 
            //процессе регистрации метода и вставляем в аргумент этого метода перменную name
        }

    }
    class Employee : Person
    {

    }
    class Program
    {
        static void Main(string[] args)
        {

            Person p = new Person{Name = "Tomm"};
            p.RegisterHandler(new AccountStateHandler(Display));//регистарция и присвоение в делегат 
            //того мтоеда Display кторый будет вызватся при вызове делегата
            p.DisplayTo();//вызываем наш делегат 
            p = new Employee { Name = "Sam" };
            p.RegisterHandler(new AccountStateHandler(Display));
            p.DisplayTo();
           
           
            Console.Read();
        }

        static void Display(string name)//этот метод будет вызыватся при использовании делегата
        {
            Console.WriteLine(name);
        }
    }


------------------------------------------
пример реализации ивентов
delegate void AccountHandler(string message);
    class Person
    {
        public event AccountHandler _notify;
        private string name;
        string tempName;
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value != name)
                {
                    name = value;
                    DisplayTo();
                }
                
            }
        }

        public void DisplayTo()
        {
            _notify?.Invoke(name);
        }

    }
    class Employee : Person//этот класс будет реализовывать тот же функционал, что и класс Person
                           //Таким образом, наследование реализует отношение is-a (является),
                           //объект класса Employee также является объектом класса Person:
    {

    }
    class Program
    {
        static void Main(string[] args)
        {

            Person p = new Person();
            p._notify += Display;
            p.Name = "flfl";
            p = new Employee();//И поскольку объект Employee является также и объектом Person,
                               //то мы можем так определить переменную: Person p = new Employee().

            p._notify += Display;//но так как новый экземпляр всегода
            //создается с дефолтными значениями
            //нам нажно переподключится к ивенту
            p.Name = "Josh";
            Console.Read();
        }

        static void Display(string name)
        {
            Console.WriteLine(name);
        }
    }

==========================================


--Классы ссылки экземпляры--

------------------------------------------ 
поля или перменные класса определяют состояние класса, а методы поведение будущего обьекта

       обьект (new) это сущность времени выполнения программы, он запрашивает область памяти под выполнение класса,
        ссылка на обьект, облать в управляемой куче ктороая хранит в себе методы

       экземпляр область в памяти кторая хранит в себе нестатические поля

       ссылка - это первый байт в памяти из той области где начинается обьект или адрес в памяти первого байта блока 
       загловка

       задача конструктора без параметров(по муолчанию) проинициализировать все поля класса знаениями по мумолчанию

сильная ссылка MyClass class = new MyClass() - имеется перменная солжерэащся в себе ссылку, по этой ссылке мы можем 
обращатся к члену этого экземпляра/объекта class.Method()

 слабая ссылка new MyClass().Method можно обратится к члену экземпляра но только один раз

 ComCommunication Meter = new ComCommunication(); это вызов конструктора
------------------------------------------
класс может иметь модификатор доступа private но если класс вложенный по отношению к другому классу.
 А если класс определен в пространстве имен, то не может;

namespace numbers
{
	private class one//недопустимо
	{

	}
	class two
	{
		private class three//допустимо
		{

		}
		private class five : four//допустимо
		{

		}
	}
	class four internal 
	{

	}
}
 
------------------------------------------
так можно вызвать экземпляры класса без дополнительной функциональности
 class Counter
    {
        public int Value;
        public int Value2 { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Counter c1 = new Counter { Value = 23, Value2 = 2};//это аналогично нижней констркции
            c1.Value = 32;//ээто
            c1.Value2 = 3;//и это аналогично верхней конструкции

            Counter c2 = new Counter { Value = 45 };
            c2.Value = 54;
        }
    }

==========================================


--Linq--

------------------------------------------
пример использования Linq Select
------------------------------------------
 var equalsToFive = integers.Select(delegate(int ss)//эта записаь аналогична нижеследующей
            {
                if (ss ==5)
                {
                    return true;
                }

                return false;
            }).ToArray();

var NotEqualsToFive = integers.Select(element => element != 5).ToArray();//эта записаь аналогична вышеследующей
==========================================

--Исключения(Exception)--

------------------------------------------
Прочитал комментарии и встретил несколько вопросов о том, как сделать циклический вызов try...catch.
Я просто применил рекурсию, обернув блок в функцию:

public int GetInput()
{
try
{
int input = Int32.Parse(Console.ReadLine());
return input;
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
return GetInput();
}
}

------------------------------------------
В этом случае обработка исключения в блоке catch производится только в том случае, если условие в выражении when 
истинно.
catch when(условие)

{

     

}

------------------------------------------
К слову сказать, лучше юзать throw ex только в самом начале стека вызова, а во всех последующих throw, 
так как throw ex резетит Stack Trace, и отследить начальную функцию, в которой было вызвано исключение
 уже намного сложнее.

------------------------------------------
 Частичные классы partial 

 public partial class Person//частичный класс
{
    public void Move()
    {
        Console.WriteLine("I am moving");
    }
    partial void DoSomethingElse();//частичный метод
}
А в другом файле определим следующий класс
а так же частичные классы могут содержать частичные методы

public partial class Person//частичный класс
{
    public void Eat()
    {
        Console.WriteLine("I am eating");
    }
     partial void DoSomethingElse()//частичный метод
    {
        Console.WriteLine("I am reading a book");
    }
}

 static void Main(string[] args)
    {
        Person tom = new Person();
        tom.Move();//I am moving
        tom.Eat();//I am eating
 
        Console.ReadKey();
    }
Таким образом, два файла в проекте содержит определение одного и того же класса Person, 
которые содержат два разных метода. И оба определенных здесь класса являются частичными. 
Для этого они определяются с ключевым словом partial.
==========================================



--Общая информация--

------------------------------------------
рефакторинг - это контролируемый процесс улучшения кода, без написания новой функциональности. 
Результат рефакторинга — это чистый код и простой дизайн.

==========================================

--Изучить позже--
------------------------------------------

фнукция this делает полезную работу и потом говорит пулу потоков: 
вызови вот эту вот вторую асинхронную функцию invike, но сделай это в основном потоке. 
Вторая функция обновляет индикатор процесса, и, поскольку пул потоков вызывает её в основном потоке, 
никаких конфликтов не происходит.
Типа вызываем например нашу  асинхронную функцию this в случае каогото дествия в программе,
 например нажатие кнопки (это делается как раз в асинхролнном потоке) и наша this делает
скажем settext = "AOAOAAO" в textbox(это делается в оснвном потоке). а такак  settext = "AOAOAAO"в textbox
 делается в основном потоке, при налиции нескольких потоков(таких вот функций по типу this), напрмиер есть 
 еще одна скаежм кнопка ктороая вызывает еще одну асинхронную функцию которая джаелет чтот подобное  
 settext = "blabla"в том же textbox по нажатию кнопки. 
 И чтобы асинхронные функции для входа в оснвной поток друг друга не ждали и не конфликтовали. 
 наши фунции асинхронная разбиваеттся на две  части первая делает полезную работу обработку события 
 нажатия кнопки и говрит вызови вторую часть(которая собтсвенно делает gettext в textbox) в оснвном 
 потоке да обновление происходит послдовательно но и  потому у нас не происходит конфликта с очередностью 
 мы как раз и спользуем invoke ктороый явлется как бы окном в основной поток из асинхроного потка нашей
  функции this те invoke попросту используется для синхронного вызова каждого из первоч части нашей this 
  ва которой выолппняется обработка нажатия, это означает, что вызывающий код(основной поток) должен ожидать
  завершения вызова через invoke, прежде чем продолжить свою работувобщем скажи мне правильно ли я поял 
  прдназначение invoke

типа пул потков это как бы списко чтли потоков для выполнения в фновм режиме
типа чтобы выполниьт какойто метод из потока надо его в пул потока поместить и тогда пул сам будет 
извелкать методы и выполноять их при вызове  и вот чтобы эти асинхронные потоки не конфликтовали и существует invoke

присваивание в  object value = 50; это боксинг


using System;

namespace ExperementNetCore
{
    delegate void AccountHandler<in T>(T message) where T : AccounArgs;//in T это когд вы не можете 

    class AccounArgs
    {
        public string Name;
    }

    class CompanyArg : AccounArgs
    {
        public string Company;
    }


    class Person<T> where T : AccounArgs
    {

        public Person(string name)
        {
            Name = name;
        }


        public event AccountHandler<T> _notify;
        private string name;

        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value != name)
                {
                    name = value;
                    DisplayTo();
                }

            }
        }

        public virtual void DisplayTo()
        {
            OnNotify((T)new AccounArgs() { Name = name });
        }

        protected void OnNotify(T message)
        {
            _notify?.Invoke(message);
        }
    }
    class Employee : Person<CompanyArg>
    {
        public string Company { get; set; }

        public Employee(string name, string company)
            : base(name)
        {
            Company = company;
        }

        public override void DisplayTo()
        {
            OnNotify(new CompanyArg() { Name = Name, Company = Company });
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            var p = new Person<AccounArgs>("Max");
            p._notify += Display;
            p.DisplayTo();

            var e = new Employee("Mixa", "KEK");
            e._notify += Display;
            e.DisplayTo();

            e = new Employee("Lexa", "LLOOOL");
            e._notify += Display;
            e.DisplayTo();

            Console.Read();
        }

        static void Display(AccounArgs name)
        {
            Console.WriteLine(name.Name);
        }
        static void Display(CompanyArg name)
        {
            Console.WriteLine($"{name.Name} {name.Company}");
        }
    }
}


==========================================


вопросы
------------------------------------------
уточнить про строки как они там копируются и что будет если пердвать строку по ref

как мне сделать в классе  
    class Instantiator<U,V>
    {
        public U FromInstance { get; set; }
        public U ToInstance { get; set; }
        public V Code { get; set; }

    }

            Instantiator<Account<int>,string> i = new Instantiator<Account<int>, string>
            {
                FromInstance = acc1,
                ToInstance = acc2,
                Code = "2520"
            };

    генерик метод который будет выводить значения его полей в виде строки 10 20 30 60 2520, может использзовать делегаты?

==========================================
