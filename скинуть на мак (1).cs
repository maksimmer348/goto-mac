


--Стек и Куча--

------------------------------------------
Стек
------------------------------------------
последним пришёл — первым ушёл
Самый верхний элемент стека, который добавлен последним, извлекается самым первым. Поэтому такой стек является 
структурой типа LIFO, аналогией может служить магазин пистолета патроны при стрельбе извелкаются в 
обратном порядке тому в ктором они туда заряжались

для стека использетуеся маленкий обьем опаретивной памяти
стек выделяется для каждого потока те каждый поток в ропграмме имеет собственный стек
стек использетуеся для храниения перменных которые мы создаем для выполнения операций над этими перменными
для вызова методов которые мы используем в нашей программе те для того чтобы выполнять логику нашей программы
дефолтное значение которое выделяется под стек ограничивается - 1 МБ

стек нужен для организации логики нашей программы 
здесь опрделеяется очередность вызова метододв используемые по мере выполнения наше программы 

Куча(Heap)
------------------------------------------
первый зашел последний вышел

Склад опреативной памяти который мы используем по мере надобности он гораздо больше чем стек
если у нас 32 разрадный процеес то выделить под кучу можно до 1,5 ГБ опреативной памяти 
если у нас 64 разрадный процеес то выделить под кучу можно до 8 ТБ опреативной памяти 

более проблематично выделять и очищать данные в оперативной памяти под кучу нежели под стек 
очисткой кучи из памяти занимается сборщик мусора сборка мусора занимает опраделленно время и расходует ресцурсы

==========================================

--значимые типы, (value types) и ссылочные типы (reference types)--
------------------------------------------

значимые типы, (value types) -> стек
------------------------------------------
эти типы неявно унаследованы от System.ValueType
Структуры (struct)
Целочисленные типы (byte, sbyte, short, ushort, int, uint, long, ulong)
Типы с плавающей запятой (float, double)
Тип decimal
Тип bool
Тип char

Перечисления enum

пермеменные передаются по значению(копируются реальные данные) те она хранит реальные данные

когда создаем перменную значимого типа то мы как будто положили какотйо файл на рабочеий стол а не его ярлык поэтому 
мы не можем присвоить этой персенной значение null

если мы присваем одной такой перемено значени другой такой перменной мы копируем значение из одной переменной в другую,
как итог в стеке две перменнх с одинаковым результатом

переменные этого типа пракаращают свое сущетсование когда покидают контекст(область видимости) в котором они были 
определены

static void Main(string[] args)
    {
       int i = 1;
       GetInt(5);
       Console.WriteLine(i);//i == 1 
       Console.ReadLine();
    }

    static void GetInt(int i)//сюда копируеся значение из перменной i 
    {
        i = 5;//при выходе из области видимочти эта перменная как и ее значение удаляется
    }


ссылочные типы (reference types) -> куча
------------------------------------------
могут быть производными от любого другого типа кроме System.ValueType
неявно наследованы от object
Тип object
Тип string
Тип Array
Классы (class)
Интерфейсы (interface)
Делегаты (delegate)
------------------------------------------

копируется ссылка, оригинал и копия ссылаются на один и тот же обьект в управляемой куче, одни и те же данные 

ссылочные типы хранят свои данные в куче, но в стеке хранится ссылка на данные в управляемой куче 
когда создаем перменную ссылочного типа то в стеке у нас хранится ссылка(типа как ярлык на рабочем столе 
если удалить файл на ктороый ссылается этот ярлык то наш ярлык будет иметь значение null),
а в куче хранятся данные(типа как exe) 

Если переменным ссылочного типа не присваивается значение, то им дается значение по умолчанию - значение null.
Фактически оно говорит об отстутсвии значения как такового или что нету ссылки на данные в управляемой куче  
те когда мы обявли перменную ссылочного типа
{
   int[]a;  //a = null;
}
мы разместили на стеке некий ярлык ктороый храни ссылку на данные ктороы распологаются в куче - это и ест null 

если мы присваем одной такой перемено значени другой такой перменной мы копируем ссылки на эту перменную а не содержимое
(типа как еще один ярлык на рабочем столе который ведет по тому же пути что и первый), те две этих перменных теперь 
будут ссылаться на один и теже еданные 

static void Main(string[] args)
            {
                int[] arr1;//arr1 = null мы разместили на стеке некий ярлык ктороый храни 
                //ссылку на данные ктороы распологаются в управляемой куче но пока там ничего нет

                arr1 = new int[1];//new в управляемой куче создает место под массив и вернет ссылку на эту область
                //в памяти в перменную arr1

                ////////////////////////////////////////////
                //если сдесь сделать так то связь между ссылкой в стеке и реальными данными в куче будет разорвана 
                arr1 = null;
                ////////////////////////////////////////////

                arr1[0] = 1;
                GetInt(arr);
                Console.WriteLine(arr[0]);//arr1[0] == 5;
                Console.ReadLine();
            }

            static void GetInt(int[] arr)//сда копируется ССЫЛКА на массив arr1  
            {
                arr[0] = 5;//потому здесь мы отправляем значение по ССЫЛКЕ на массив arr1 цифру 5
            }
--

class Person
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Person p1 = new Person { Name = "Tom", Age = 23 };
            Person p2 = p1;//присваиваем двум обьектам один адрес в памяти присваивая p2 = p1

            p2.Name = "Alice";//В данном случае объекты p1 и p2 будут указывать на один и
            //тот же объект в памяти, поэтому изменения свойств в переменной p2 затронут
            //также и переменную p1, те изменив имя в обьектке класса Person p2 мы измним
            //его и в обьекте p1

            Console.WriteLine(p1.Name); // Alice

            Console.Read();
        }
    }
------------------------------------------
переменные этого типа пракаращают свое сущетсование когда обьект подвергается сборке мусора
если выйти из области видимости ссылочного типа удалится сслыка на этот тип но, память выделаная под этот тип все 
еще занята этим типом, пока не отработает сборщик мусора
------------------------------------------
Одно из отличий ссылочных типов от типов значений состоит в том, что переменные ссылочных типов могут принимать 
значение null. Например:

object o = null;
string s = null;

Если переменным ссылочного типа не присваивается значение, то им дается значение по умолчанию - значение null.
 Фактически оно говорит об отстутсвии значения как такового.
==========================================

--Инициализация переменной--
------------------------------------------
int i = 10;        //производим инициализацию перменной (задаем целочисленной переменной i значение 10)
char symbol = 'Z';   // инициализируем переменную symbol буквенным значением Z
float f = 15.7F;   // переменная f инициализируется числовым значением 15.7

int x = 5, y = 10, z = 12;    // инициализируем несколько переменных одного типа

Задать значение переменной можно, в частности, с помощью оператора присваивания. 
Кроме того, задать начальное значение переменной можно при ее объявлении. 
Для этого после имени переменной указывается знак равенства (=) и присваиваемое значение. 
Если две или более переменные одного и того же типа объявляются списком, разделяемым запятыми, 
то этим переменным можно задать, например, начальное значение.

Переменные, являющиеся полями класса или структуры, если не инициализированы явно,
по умолчанию обнуляются (null или 0 )в момент создания.

--обьявление-- --объявление перменной--
------------------------------------------
int i;//обьявление перменной 

Объявить можно переменную любого действительного типа. Важно подчеркнуть, что возможности 
переменной определяются ее типом. Например, переменную типа bool нельзя использовать для
хранения числовых значений с плавающей точкой. Кроме того, тип переменной нельзя изменять
 в течение срока ее существования. В частности, переменную типа int нельзя преобразовать
  в переменную типа char.

Все переменные в C# должны быть объявлены до их применения. Это нужно для того, чтобы 
уведомить компилятор о типе данных, хранящихся в переменной, прежде чем он попытается 
правильно скомпилировать любой оператор, в котором используется переменная. Это позволяет 
также осуществлять строгий контроль типов в C#.
инициализация перменной

==========================================

--Классы ссылки экземпляры--

------------------------------------------ 
поля или перменные класса определяют состояние класса, а методы поведение будущего обьекта

       обьект (new) это сущность времени выполнения программы, он запрашивает область памяти под выполнение класса,
        ссылка на обьект, облать в управляемой куче ктороая хранит в себе методы

       экземпляр область в памяти кторая хранит в себе нестатические поля

       ссылка - это первый байт в памяти из той области где начинается обьект или адрес в памяти первого байта блока 
       загловка

       задача конструктора без параметров(по муолчанию) проинициализировать все поля класса знаениями по мумолчанию

сильная ссылка MyClass class = new MyClass() - имеется перменная солжерэащся в себе ссылку, по этой ссылке мы можем 
обращатся к члену этого экземпляра/объекта class.Method()

 слабая ссылка new MyClass().Method можно обратится к члену экземпляра но только один раз тк каждый раз при обращении
 мы работаем с новым экземплярок класса MyClass

 ComCommunication Meter = new ComCommunication(); это вызов конструктора
------------------------------------------
класс может иметь модификатор доступа private но если класс вложенный по отношению к другому классу.
 А если класс определен в пространстве имен, то не может;

namespace numbers
{
  private class one//недопустимо
  {

  }
  class two
  {
    private class three//допустимо
    {

    }
    private class five : four//допустимо
    {

    }
  }
  class four internal 
  {

  }
}
 
------------------------------------------
так можно вызвать экземпляры класса без дополнительной функциональности
 class Counter
    {
        public int Value;
        public int Value2 { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Counter c1 = new Counter { Value = 23, Value2 = 2};//это аналогично нижней констркции
            c1.Value = 32;//ээто
            c1.Value2 = 3;//и это аналогично верхней конструкции

            Counter c2 = new Counter { Value = 45 };
            c2.Value = 54;
        }
    }

==========================================



--Структуры--

------------------------------------------

Структуры синтаксически очень похожи на классы, Так же как и классы, структуры могут иметь поля,
методы и конструкторы. НО существует принципиальное отличие, которое заключается в том,
что класс – является ССЫЛОЧНЫМ типом (reference type), а структуры – ЗНАЧИМЫМ типом (value type)
Следовательно, классы всегда создаются в так называемой “куче” (heap), а структуры создаются в стеке (stack).
------------------------------------------

1) Переменные структуры хранят не ссылку на объект, а сам объект (у вас это не очевидно, хотя и можно догадаться). 
То есть это значимый тип, а не ссылочный.

2) Значит если одной структуре присвоить другую, то Скопируются Все Поля одной структуры в другую,
 а не ссылка, как было бы с классами.

3) Т.к. переменная хранит сами данные, а не ссылку на них, то доступ к полям осуществляется быстрее и есть 
некоторая экономия памяти.

4) Структуры не поддерживают наследование(именованое)

------------------------------------------
два правила старктур
Первое правило структуры: Всегда все переменные должны быть инициализированы.
В классах Вы можете инициализировать значение полей непосредственно при их объявлении.
 В структурах такого сделать нельзя, и поэтому данный код вызовет ошибку при компиляции. Поэтому:
Второе правило структуры: Нельзя инициализировать переменные в том месте, где они объявляются.

struct Time
   {
      //private int hours = 10; так делать НЕЛЬЗЯ 
      private int hours;//так делать можно
      private int minutes;//так делать можно
      private int seconds;//так делать можно    
...


------------------------------------------
 структуру тоже можно передать по ссылке, используя модификаторы out и ref.


------------------------------------------
Мы выяснили, что все встроенные типы значений задаются структурами, например, числовые типы int, long, float 
определены структурами System.Int32, System.Int64 и System.Single соответственно.
------------------------------------------
Структуры не могут содержать явных конструкторов без параметров


struct Time
   {
       public int hours, minutes, seconds;
       public string age;
       //public Time() так дельать НЕЛЬЗЯ
       //Структуры не могут содержать явных конструкторов без параметров
       //{
       //    this.hours = 50;
       //    this.minutes = 20;
       //    this.seconds = 30;
       //    this.age = "22";
       //}
       ...

struct Time
    {
        public int Hours, Minutes, Seconds;
        public string age;
        public Time(int hours, int minutes, int seconds, string age)//мождно делать так
        {
            Hours = hours;
            Minutes = minutes;
            Seconds = seconds;
            this.age = age;
        }
    ...
------------------------------------------
пример использовния структур возврат из метода

  struct Time
    {
        public int hours, minutes, seconds;

        public int height;
        public string age;

        public void Disp()
        {
            Console.WriteLine($"{hours} {minutes} {seconds}");
        }
    }

    class HA<T>
    {
        public T haha;
    }
    class Program
    {
        static void Main(string[] args)
        {
            Time t = geTime("10", "12", "19");
            t.Disp();//10 12 19

            Time tt = geTime("15", "20", "30");
            HA<Time> ha = new HA<Time>();
            ha.haha = tt;
            ha.haha.Disp();//15 20 30
        }

        static Time geTime(string h, string m, string s)//сдесь мы возвращаем из метода структура, 
        //так можно добится возвращения не одного знгачения а сразу несокльких входящих в стурктуру
        {
            return new Time()
            {
                hours = int.Parse(h),
                minutes = int.Parse(m),
                seconds = int.Parse(s)//если не присовить значение одному из полей структры 
                //оно будет иметь дефолтное значение, для значимой ерменной 0, для ссылочной null
            };
        }
    }

------------------------------------------
В отличие от классов, использование публичных полей в структурах в большинстве случаев не рекомендуется,
потому что не существует способа контролирования значений в них. Например, кто-либо может установить значение 
минут или секунд более 60.

struct Time
   {
      //private int hours = 10; так делать НЕЛЬЗЯ 
      private int hours, minutes, seconds;
      public Time(int hh, int mm, int ss)
      {
         hours = hh % 24;
         minutes = mm % 60;
         seconds = ss % 60;
      }
    //так делать нельзя тк Структуры не могут содержать явных конструкторов без параметров
            //public Time()
        //{
        //    hours = 7;
        //    minutes = 4;
        //    seconds = 0;
        //}
      public int Hours()
      {
         return hours;
      }
   }
   class Program
   {
      static void Main()
      {
         Time t = new Time(30,69,59);
         Console.WriteLine(t.Hours());
         Console.ReadKey();
      }
   }


==========================================



--переменные и обьекты c#--
------------------------------------------

------------------------------------------
string
Прежде всего, объект String представляет собой неизменяемую строку. 
Когда мы выполняем какой-нибудь метод класса String, система создает новый объект в памяти с 
выделением ему достаточного места.

------------------------------------------





==========================================



--модификаторы доступа--
------------------------------------------
public: публичный, общедоступный класс или член класса. Такой член класса доступен из любого места в коде, а также из 
других программ и сборок.;

private: закрытый класс или член класса. Представляет полную противоположность модификатору public. 
Такой закрытый класс или член класса доступен только из кода в том же классе или контексте.

protected: такой член класса доступен из любого места в текущем классе или в производных классах.
При этом производные классы могут располагаться в других сборках.

internal: класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке,
 однако он недоступен для других программ и сборок (как в случае с модификатором public).

protected internal: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны 
из текущей сборки и из производных классов.

private protected: такой член класса доступен из любого места в текущем классе или в производных классах, которые 
определены в той же сборке.
------------------------------------------
класс может иметь модификатор доступа private, НО только если это класс вложенный по отношению к другому классу.
А если класс определен в пространстве имен, то не может;

namespace numbers
{
	private class one//недопустимо
	{

	}
	class two
	{
		private class three//допустимо
		{

		}
		private class five : four//допустимо
		{

		}
	}
	class four internal 
	{

	}
}
==========================================


--null  и операторы --

------------------------------------------
Если переменным ссылочного типа не присваивается значение, то им дается значение по умолчанию - значение null. 
Фактически оно говорит об отстутсвии значения как такового, это как яярлык на рабчем столе кторрый ссылаетя на 
несуществующий файл, или что нету ссылки на данные в управляемой куче  
те когда мы обявли перменную ссылочного типа
{
   int[]a;  //a = null;
}
мы разместили на стеке некий ярлык ктороый храни ссылку на данные ктороы распологаются в куче - это и ест null

Одно из отличий ссылочных типов от типов значений состоит в том, что переменные ссылочных типов могут принимать
 значение null. Например:

object o = null;
string s = null;

? для ссылочных типов
------------------------------------------

Action s = null;             

var handler = s;

if (s != null)//здесь происходит проверка на null
{
    s(…);
}

s?.Invoke();//эта запись аналогична вышенаписаной

------------------------------------------
    class User
{
    public Phone Phone { get; set; }
}
 
class Phone
{
    public Company Company { get; set; }
}
 
class Company
{
    public string Name { get; set; }
}            
В данном случае свойство Phone не определено, будет по умолчанию иметь значение null. 
Поэтому мы столкнемся с исключением NullReferenceException.
 Чтобы избежать этой ошибки мы могли бы использовать условную конструкцию для проверки на null

User user = new User();
 
if(user!=null)
{
    if(user.Phone!=null)
    {
        if (user.Phone.Company != null)
        {
            string companyName = user.Phone.Company.Name;
            Console.WriteLine(companyName);
        }
    }
}
//или сокращенно 
//эта записа аналогична вышенаписаной
  string companyName = user?.Phone?.Company?.Name;
    if (companyName != null)
    {
        Console.WriteLine(companyName);
    }
//или сокращенно 
//эта записа аналогична вышенаписаной
string companyName = user?.Phone?.Company?.Name;
        if (string.IsNullOrEmpty(companyName))
        {
            Console.WriteLine(companyName);
        }
------------------------------------------
null Строки

Из-за того, что строки это ссылочный тип, их идентификаторы тоже могут быть равны null. 
Мы часто хотим защитить свою программу от ошибок, связанных с null-строками. Это можно сделать
 с помощью методов IsNullOrEmpty(возвращает true если string пуста или string == null) 
 или string.IsNullOrWhiteSpace(string)(возвращает true если string пуста или string == null или string == "\t" или 
 string == " " те строка ). 
 Также можно просто проверить строку на равенство литералу null. 
 Достоинство этого метода в том, что она работает быстрее, если не требуется проверка на длину строки.

--nullable для значимых типов
------------------------------------------
Значение null по умолчанию могут принимать только объекты ссылочных типов. 
Однако в различных ситуациях бывает удобно, чтобы объекты числовых типов данных имели значение null,
то есть были бы не определены

Для этого надо использовать знак вопроса ? после типа значений. Например:
Nullable<int> z = null;//эта запись аналогична нижней
int? z = null;//делается для того чтобы значимые типа могли хранить null
//в случае если вдруг не пришлось присваивать null в эту перменную она останется 
//обычной int
bool? enabled = null;

int? i = null;//делается для того чтобы значимые типа могли хранить null
//в случае если вдруг не пришлось присваивать null в эту перменную она останется 
//обфчной int

дополнительные фнункиции которые поялвются при обявлении пременной nullable

Console.WriteLine(i == null);

Console.WriteLine(i.HasValue);//bool есть ли у этой перменной реальное занчение i == null будет возвращено false

Console.WriteLine(i.GetValueOrDefault());//GetValueOrDefault досутпен только в сулчае если перменная является nullable            
//если в преременной i было присвоено значние, то результатом этой операции будет это самое значение 
//если же нет то будет возрващено занчение default для того типа перменной к кторой проверяемая перменная относится
//в данном случае будет возвращено 0 

Console.WriteLine(i.GetValueOrDefault(3));//аналогично верхней записи за исключением того что вместа default
//в случае если проверямеая пременная ббудет i == null , то будет возраащено 3

Console.WriteLine(i??55);//если перменная i == null то он вернет занчение из правой части те 55
//если же значение i != null (например 10)то он вернет ээто значение те 10
//обычно используется этот метод
           
Console.WriteLine(i.Value);//реальные данные которые хранятся в поле i , если i == null то тут будет ошибка

Console.WriteLine(i); // есл сделать так то вместо ошикбки на консоль выведется путсая строка 

Оператор ?? возвращает левый операнд, если этот операнд не равен null. Иначе возвращается правый операнд.
object x = null;
object y = x ?? 100;  // равно 100, так как x равен null
работает только с переменным ссылочного типа

==========================================

--динамические структуры данных--
------------------------------------------

Array.Resize

==========================================


--Пространства имен, псевдонимы и статический импорт--

------------------------------------------
Пространства имен
------------------------------------------
Но чтобы задействовать классы из других пространств имен, эти пространства надо подключить с помощью директивы using, 
например using System;
Здесь подключается пространство имен System, в котором определен класс Console. Иначе нам бы пришлось писать полный 
путь к классу: System.Console.WriteLine("hello");

Пространства имен могут быть определены внутри других пространств
В этом случае для подключения пространства указывается его полный путь с учетом внешних пространств имен например 
using HelloApp.AccountSpace;

псевдонимы
------------------------------------------
Для различных классов мы можем использовать псевдонимы. Затем в программе вместо названия класса используется 
его псевдоним. 
Например, для вывода строки на экран применяется метод Console.WriteLine(). Но теперь зададим для класса Console 
псевдоним:

using printer = System.Console;
class Program
{
    static void Main(string[] args)
    {
        printer.WriteLine("Hello from C#");
        printer.Read();
    }
}
Указываем, что псевдонимом для класса System.Console будет имя printer.
 Это выражение не имеет ничего общего с подключением пространств имен в начале файла, хотя и использует оператор using.
 
статический импорт
------------------------------------------
Выражение using static подключает в программу все статические методы и свойства, а также константы. 
И после этого мы можем не указывать название класса при вызове метода.

Также в C# имеется возможность импорта функциональности классов. Например, импортируем возможности класса Console:

using static System.Console;

            WriteLine("Hello from C# 8.0");//в этом случае можно опусттить вызов тсатического метода консаль

            Read();
    
==========================================


--свойства get set свойства--
------------------------------------------

        private int x;

        public void SetX(int x)
        {
            if (x > 5)
            {
                this.x = 5;
                return;
            }

            this.x = x;
        }
        public int GetX()
        {
            return X;
        }
//вышенпаисаное аналогично ниже написаному()
////////////////////////////////////////////////
        private int y;

        public int Y
        {
            get { return y; }//GetX()
            set//SetX(int x)
            {
                if (value > 5)
                {
                    y = 5;
                    return;
                }

                y = value;
            }
        }

------------------------------------------

Автосвойствам можно присвоить значения по умолчанию (инициализация автосвойств) и модификаторы доступа:

    public string Name { get; set; } = "Tom";
    public int Age { get; set; } = 23;

     public string Name { private set; get;}
    public Person(string n)
------------------------------------------
1. Модификатор для блока set или get можно установить, если свойство имеет оба блока (и set, и get)

2. Только один блок set или get может иметь модификатор доступа, но не оба сразу

3. Модификатор доступа блока set или get должен быть более ограничивающим, чем модификатор доступа свойства. 
Например, если свойство имеет модификатор public, то блок set/get может иметь только модификаторы protected internal, 
internal, protected, private

Начну с 3,
Модификатор должен быть более ограничивающий потому, что: 1.Нет смысла делать такой же модификатор,
как у свойства потому что он уже есть и get-set им пользуются. 2. Невозможно и нельзя сделать модификатор более 
расширяющим, потому что это противоречит идеи инкапсуляции.

Теперь 2,
Как сказано - только 1 метод (get или set) может иметь модификатор, значит нужно понять, что не так в случае если оба 
имеют модификаторы, а вот что - допустим у нас свойство модификации public и мы поставили модификатор protected на оба:
 get, set и это означает, что эти методы будут доступны в текущем классе и классах-наследниках, 
 и проблема в том что если класс Program, в методе main мы создали объект от того класса, при вызове свойства Name 
 оно будет obsolete, иными словами функционал недоступен!, хотя оно же public, и тут возникает ошибка! 
 Поэтому опять таки исходя из идеи инкапсуляции public - должно быть доступно везде! А мы там поставили на оба protected,
  непорядок! Не должно быть так! Все что public - должно быть доступным везде и всюду!Поэтому из этого исходит пункт, 
  что только один может иметь модификацию, чтобы другой мог всегда быть использован!

Теперь 1,
Здесь мысль такая же, как и в предидущем пункте - Свойство должно быть доступно! 
Если поставить модификатор в случае когда есть только get или set (один из них), то получится опять нарушение
идеи инкапсуляции! Поэтому при присутствии второго, на который не будет вешаться модификатор, 
все будет соответствовать идеи!

------------------------------------------
Не лишним будет подчеркнуть, что внутри блоков get{ } и set { } можно указывать процедуры и функции. И это замечательно,
 ведь благодаря этому, на любое поле класса можно повесить процедуру, которая будет запускаться каждый раз,
  когда значение переменной где-то изменяется.
private bool fullyLoaded = false;
public bool onfullyLoaded
{
get { return fullyLoaded; }
set
{
fullyLoaded = value;
OnTestChanged();
}
}

void OnTestChanged()
{
//Ваш индусский код
}

сокращенная записаь свойства
------------------------------------------
private string name;
     
    // эквивалентно public string Name { get { return name; } }
    public string Name => name;

чтобы присовить значение readonly свойству нужно использовать конструктор класса

  public string Name { get; }// readonly свойство

 public human(string name)//рабоает как с любой  reaadonly перменной
        {
            Name = name;
        }

  human h = new human("Max");
  Console.WriteLine($"{h.Name}");//Max

==========================================


--static модификатор--
------------------------------------------

На уровне памяти для статических полей будет создаваться участок в памяти, который будет общим для всех объектов
(экземпляров) класса.


 static-методы не могут использовать ссылку this и напрямую (т.е. без указания конкретного объекта класса) 
 обращаться к нестатическим членам класса, а только через объект класса.

  public static bool ValidatePorts(this ComSettings view)//здесь создается объект класса через который и пойдет 
  //обращение к нестаическим членам класса
        {
        	//если вместо viev написать this выскочит исключение
            if (view.ChannelComMeter.SelectedItem == view.ChannelComSupply.SelectedItem)
            {
                return false;
            }

            return true;
        }

статический конструктор  необходимо создавать, если вам надо выполнять некоторые действия при первом создании 
объекта этого класса.
	Как правило, в статическом конструкторе инициализируются общие для всех объектов ресурсы.
	Приведу практический пример: есть класс, через который взаимодействуем с базой данных. И нам надо, 
	чтобы до создания первого объекта класса в базе данных уже были некоторые объекты. 
	В статическом конструкторе этого класса тогда можно проверить объекты в бд и добавить их при необходимости.

Статический конструктор вызывается перед доступом к любому члену класса.

class Account
    {
        // public static string name = "Ivan";
        public static string name;
        static Account()
        {
            name = "Ivan"; 
        }
    }
    
        static void Main(string[] args)
        {
            Console.WriteLine(Account.name);// Обращение к полю по имени класса и тут срабатывает конструктор
        }
    
    все объекты класса, в том числе и первый, создаются с помощью нестатического конструктора, 
    статический конструктор не создает объект касса, более того явным образом не вызывается. Он вызывается системой,
     когда вы создаете с помощью нестатического конструктора первый объект класса
==========================================

--перегрузка методов--
------------------------------------------

метод можно перегрузить этими способоами
Определить версию метода с другим количеством параметров
Определить версию метода с другим типами параметров
Определить версию метода, где порядок параметров будет иным
Изменить модификаторы параметров

И в языке C# мы можем создавать в классе несколько методов с одним и тем же именем, но разной сигнатурой. Что такое сигнатура? Сигнатура складывается из следующих аспектов:

Имя метода
Количество параметров
Типы параметров
Порядок параметров
Модификаторы параметров

Но названия параметров в сигнатуру НЕ входят. Например, возьмем следующий метод:

public int Sum(int x, int y) 
{ 
    return x + y;
}
У данного метода сигнатура будет выглядеть так: Sum(int, int)

И перегрузка метода как раз заключается в том, что методы имеют разную сигнатуру, в которой совпадает только название метода. То есть методы должны отличаться по:

Количеству параметров
Типу параметров
Порядку параметров
Модификаторам параметров

Здесь представлены четыре разных версии метода Add, то есть определены четыре перегрузки данного метода.
То есть мы можем представить сигнатуры данных методов следующим образом
class Calculator
{
    public void Add(int a, int b)
    {
        int result = a + b;
        Console.WriteLine($"Result is {result}");
    }
    public void Add(int a, int b, int c)
    {
        int result = a + b + c;
        Console.WriteLine($"Result is {result}");
    }
    public int Add(int a, int b, int c, int d)
    {
        int result = a + b + c + d;
        Console.WriteLine($"Result is {result}");
        return result;
    }
    public void Add(double a, double b)
    {
        double result = a + b;
        Console.WriteLine($"Result is {result}");
    }
}

==========================================

--перегрузка операторов--
------------------------------------------


Counter c1 = new Counter { Value = 23 };
Counter c2 = new Counter { Value = 45 };
операция сравнения, и операция сложения для объектов Counter не доступны. 
Эти операции могут использоваться для ряда примитивных типов. Например, по умолчанию мы можем складывать числовые 
значения, но как складывать объекты комплексных типов - классов и структур компилятор не знает. 
И для этого нам надо выполнить перегрузку нужных нам операторов.

bool result = c1 > c2;
Counter c3 = c1 + c2;

Перегрузка операторов заключается в определении в классе, для объектов которого мы хотим определить оператор,
 специального метода:Этот метод должен иметь модификаторы public static, так как перегружаемый оператор будет
  использоваться для всех объектов данного класса.
public static возвращаемый_тип operator оператор(параметры)
{  }


class Counter
{
    public int Value { get; set; }
         
    public static Counter operator +(Counter c1, Counter c2)
    {
        return new Counter { Value = c1.Value + c2.Value };
    }
   //Если мы переопределяем одну из этих операций сравнения, то мы также должны переопределить вторую из этих операций
    public static bool operator >(Counter c1, Counter c2)
    {
        return c1.Value > c2.Value;
    }
    public static bool operator <(Counter c1, Counter c2)
    {
        return c1.Value < c2.Value;
    }
}
 static void Main(string[] args)
  {
bool result = c1 > c2;
Counter c3 = c1 + c2;
  }      
------------------------------------------
Стоит отметить, что так как по сути определение оператора представляет собой метод, то этот метод мы также можем 
перегрузить, то есть создать для него еще одну версию.
 Например, добавим в класс Counter еще один оператор:

public static int operator +(Counter c1, int val)
{
    return c1.Value + val;
}
------------------------------------------
при перегрузке не должны изменяться те объекты, которые передаются в оператор через параметры.

public static Counter operator ++(Counter c1)
{
	//это неправильнео написание тк оператор не должен менять сови параметры
    c1.Value += 10;
    return c1;
}

И более корректная перегрузка оператора инкремента будет выглядеть так:

public static Counter operator ++(Counter c1)
{
    return new Counter { Value = c1.Value + 10 };
}

==========================================

--Const и Readonly--
------------------------------------------

const Константы
------------------------------------------
const неявно static и его Невозможно изменить где-либо.

Итак, если вы уверены, что значение константы не изменится, используйте const.
public const int CM_IN_A_METER = 100;

Константы по умолчанию статичны.
Они должны иметь значение во время компиляции (вы можете иметь, например, 3,14 * 2, но не можете вызывать методы)
Может быть объявлено внутри функций
Скопируются в каждую сборку, которая их использует (каждая сборка получает локальную копию значений)
Может использоваться в атрибутах;

readonly
------------------------------------------
Но если у вас есть константа, которая может измениться (например, точность w.r.t.).. или если у вас есть сомнения,
 используйте readonly.

public readonly float PI = 3.14;


Существует небольшая магия с readonly. Поле readonly может быть установлено несколько раз внутри конструктора (-ов).
 Даже если значение задано в двух разных цепных конструкторах, оно все же разрешено.

public class Sample {
    private readonly string ro;

    public Sample() {
        ro = "set";
    }

    public Sample(string value) : this() {
        ro = value; // this works even though it was set in the no-arg ctor
    }
}

Еще одно значение: значения readonly могут быть изменены с помощью "коварного" кода через отражение.

var fi = this.GetType().BaseType.GetField("_someField", BindingFlags.Instance | BindingFlags.NonPublic); 
fi.SetValue(this, 1);

Поля экземпляров Readonly
Должно быть установлено значение, по истечении времени конструктор
Оцениваются при создании экземпляра
------------------------------------------
Статические поля readonly
Оцениваются, когда выполнение кода попадает в ссылку на класс (когда создается новый экземпляр или выполняется 
    статический метод) должно быть оцененное значение к моменту завершения статического конструктора
Не рекомендуется помещать ThreadStaticAttribute в эти (статические конструкторы будут выполняться только в 
    одном потоке и будут 
	устанавливать значение для его потока; все остальные потоки будут иметь это значение неинициализированным)
==========================================

--индексаторы--

------------------------------------------
индексаторы позволяют индексировть обьекты и обращатся к даным по индексу. те мы можем работать с обьектами как 
с массивами. 
в таком виде индексатор используется если нужнро скажем написать массив с особеными свойствами

возвращаемый_тип this [Тип параметр1, ...]
{
    get{...}
    set{...}
}
------------------------------------------
 class Person
    {
        public string Name { get; set; }
    }
    class People
    {
        Person[] data = new Person[5];
        //индексатор
        public Person this[int index]// в отличии от свойств инджексатор не имеет названия вместо него идет ключевое 
        //слово this 
        {
            //объекты Person хранятся в классе в массиве data, для получения их по индексу в индексаторе определен 
            //блок get
            get
            {
                return data[index];
            }
            //получаем через параметр value переданный объект Person и сохраняем его в массив по индексу
            set
            {
                data[index] = value;
            }
        }
    }

People p = new People();

            //После этого мы можем работать с объектом People как с набором объектов Person
            p[0] = new Person { Name = "X4X" };
            p[1] = new Person { Name = "X3X" };

            Console.WriteLine(p[0]?.Name);
            Console.WriteLine(p[1]?.Name);

------------------------------------------
Также индексатор может принимать несколько параметров.

 class Matrix
    {
        private int[,] numbers = new int[,] {
            { 1, 9, 4 },
            { 8, 3, 6 }, 
            { 3, 4, 6 }};// хранилище определено в виде двухмерного массива или матрицы
        public int this[int i, int j]  
        {
            get
            {
                return numbers[i, j];
            }
            set
            {
                numbers[i, j] = value;
            }
        }
    }


    class Program
    {


        static void Main(string[] args)
        {
          Matrix mt = new Matrix();
          mt[0, 2] = 99;
          Console.WriteLine(mt[0, 1]);
          Console.WriteLine(mt[0,2]);
        }

------------------------------------------
Как и в свойствах, в индексаторах можно опускать блок get или set, если в них нет необходимости.

 private int[,] numbers = new int[,] { { 1, 2, 4}, { 2, 3, 6 }, { 3, 4, 8 } };
    public int this[int i, int j]
    {
        get// делаем индексатор доступным только для чтения
        {
            return numbers[i,j];
        }
    }
------------------------------------------
перегрузка индексаторов
Подобно методам индексаторы можно перегружать. В этом случае также индексаторы должны отличаться по количеству, 
типу или порядку используемых параметров.

 class Person
    {
        public string Name;
        public int Age;
    }
    class People
    {
        Person[] data;
        public People()
        {
            data = new Person[5];
        }
        public Person this[int index]//перывая версия получает и устанавливает объект Person по индексу
        {
            get
            {
                return data[index];
            }
            set
            {
                data[index] = value;
            }
        }
        public Person this[string name]// вторая - только получае объект Person по его имени
        {
            get
            {
                Person person = null;
                foreach (var p in data)
                {
                    if (p?.Name.ToLower() == name.ToLower())
                    {
                        person = p;
                        break;
                    }
                }
                return person;
            }
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            People people = new People();

            people[0] = new Person { Name = "Tom" };//использование set из первая версия
            people[1] = new Person { Name = "Bob" };//использование set из первая версия
            Console.WriteLine(people[0].Name);//использование get из первая версия

            Console.WriteLine(people["bob"]?.Name);//использование get из второй версия
        }
    }

==========================================

--ref и out и in--
------------------------------------------
передача по значению 
При передаче по значению метод получает не саму переменную, а ее копию

class Program
{
    static void Main(string[] args)
    {
        int a = 5;
        Console.WriteLine($"Начальное значение переменной a = {a}");
 
        
        
        IncrementVal(a);//Передача переменных по значению
        //После выполнения этого кода по-прежнему a = 5, так как мы передали лишь ее копию

        Console.WriteLine($"Переменная a после передачи по значению равна = {a}");
        Console.ReadKey();
    }
    // передача по значению
    static void IncrementVal(int x)
    {
        x++;
        Console.WriteLine($"IncrementVal: {x}");
    }
}

------------------------------------------
ref передача по ссылке 
А при передаче параметра по ссылке метод получает адрес переменной в памяти


class Program
{
    static void Main(string[] args)
    {
        int a = 5;//после отработвашего метода IncrementRef значитне этой прменоной изменится на 10 
        //тк мы предали значние в метод поссылке
        int y = 4;//после отработвашего метода IncrementRef значитне этой прменоной изменится на 10 
        //тк мы предали значние в метод поссылке
        Console.WriteLine($"Начальное значение переменной a  = {a}");//тут будет 5 
        Console.WriteLine($"Начальное значение переменной a  = {y}");//тут будет 4

        EdtionVal(a, y)//Передача переменных по значению
        //После выполнения этого кода a = 5, так как мы передали в метод НЕ САМУ переменную а только ее КОПИЮ

        Console.WriteLine($"Переменная a после передачи ссылке равна = {a}");//после отработвашего метода 
        //EdtionVal значитне этой прменоной вне этого метода НЕ изменится те будет равно 5
        Console.WriteLine($"Переменная a после передачи ссылке равна = {y}");//после отработвашего метода 
        //EdtionVal значитне этой прменоной вне этого метода НЕ изменится те будет равно 4

         IncrementRef(ref a, ref y);;//Передача переменных по ссылке
        //После выполнения этого кода a = 6, так как мы передали в метод САМУ переменную

        Console.WriteLine($"Переменная a после передачи ссылке равна = {a}");//после отработвашего метода 
        //IncrementRef значитне этой прменоной изменится на 6 тк мы предали значние в метод поссылке
        Console.WriteLine($"Переменная a после передачи ссылке равна = {y}");//после отработвашего метода 
        //IncrementRef значитне этой прменоной изменится на 6 тк мы предали значние в метод поссылке
        Console.ReadKey();
    }

еще один вариант ref 

    // передача по ссылке
    static void IncrementRef(ref int x, ref y)
    {
        x++;//после того как отработает метод в мейне значние здесь изменится на 5 
        //и потом прибавится еще 1 те будет 6
        y += x;//тут будет 10
        Console.WriteLine(y);//тут будет 10
        Console.WriteLine($"IncrementRef: {x}");//тут будет 6
    }
     static void EdtionVal( int x, ref y)
    {
        x++;//после того как отработает метод в мейне значние здесь изменится на 5 
        //и потом прибавится еще 1 те будет 6
        y += x;//тут будет 10
        Console.WriteLine(y);//тут будет 10
        Console.WriteLine($"IncrementRef: {x}");//тут будет 6
    }
}

------------------------------------------
out определение выходного параметра те результат возвращается не через оператор return, а через выходной параметр.
out передает парметр по ссылке те меняет САМУ переменную НО Не передает её значение!

Но параметры могут быть также выходными .методы, использующие такие параметры, обязательно должны присваивать 
им определенное значение. 

Использования подобных параметров состоит в том, что по сути мы можем вернуть из метода не один вариант,
а несколько.

если исползуется out мы обязаны в методе используешем этот вид перменных измениьт их иначе проект не скомпилируется

   static void Main(string[] args)
        {
            int widthFigure = 10;
            int heightFigure = 5;
            int areaFigure = GetData(widthFigure, heightFigure);//здесь мы взовращаем одно занчение те число int
            Console.WriteLine(areaFigure);//значние будет 50

            int areaGihureTwo = 500; //значние здесь неважно тк оно пеопределится в методое GetDataTwo
            GetDataTwo(widthFigure, heightFigure,out int perimeterFigure, out areaFigure);//на выходе получаем 
            //наши перменнные perimeterFigure и areaFigure со значенимяи измененыыми в методе GetDataTwo

            Console.WriteLine($"perimeter figure {perimeterFigure}, area figure {areaFigure}");//вывод: 
            //perimeter figure 30, area figure 50
            Console.ReadLine();
        }
        static int GetData(int width,  int height)//в этом случае метод венет только одно значение 
        {
            return width * height;
        }
       
        static void GetDataTwo(int width, int height,out int perimeter,out int area) //если мы хотим вернунть несолкько значений
            //из метода то необходимо использовать out 
        {
            perimeter = (width + height) * 2;//если используется out необходим задать ему в метод значение

            area = width * height;//можно исользоватся сколько угдно выходныхх зщначний

            //return width * height; от такого возвращаемого значения можно избаавится и например
            //написать вмето него так
        }
    }

    или так 

    static void Main(string[] args)
        {
              int widthFigure = 10;
                int heightFigure = 5;
                string perimeter = "hjhj";//значние здесь неважно тк оно пеопределится при исользовании ref и out 
                string areas = "ghh";//значние здесь неважно тк оно пеопределится при исользовании ref и out 

                Console.WriteLine(perimeter + " " + areas);//вывод: hjhj ghh

                GetData(ref perimeter, ref areas);
                Console.WriteLine(perimeter + " " + areas);//вывод: 1000 2000

            GetDataTwo(widthFigure, heightFigure, out perimeter, out areas); //на выходе получаем 
                //наши перменнные perimeter и areas со значенимяи измененыыми в методе GetDataTwo
                Console.WriteLine($"perimeter figure {perimeter}, area figure {areas}");//вывод: perimeter figure 30, area figure 50

            Console.ReadLine();
            }

            static void GetData(ref string perimeter, ref string areas)
            {
                perimeter = "1000";
                areas = "2000";
            }

            static void GetDataTwo(int width, int height, out string perimeter, out string area)
            {
                var perim = (width + height) * 2;
                perimeter = perim.ToString();

                var areas = width * height;
                area = areas.ToString();
            }
        }
------------------------------------------
in входные параметры.
это так же пердача параметра по ссылке однако внутри метода его значение параметра нельзя будет изменить

static void GetData(in int x, int y, out int area, out int perim)
{
    // x = x + 10; нельзя изменить значение параметра x
    y = y + 10;
    area = x * y;
    perim = (x + y) * 2;
}

Почему параметр in передается по ссылке, обычно по ссылке мы передаем чтобы изменить значение 
в самой перменной а тут это сделать нельзя? 

Бывает, надо использовать ссылку при этом не меняя значение параметра. Сейчас объясню почему:
Когда ты передаёшь переменную в функцию НЕ по ссылке, она копируется, то есть занимает дополнительную память и дополнительно 
нагружает систему. Конечно, когда ты передаёшь малые объекты как число 5 или строку "я Ваня", такой способ передачи параметров 
мало на что повлияет. Но когда ты работаешь с большими объёмами данных (например, 3д объекты) которые не хочешь изменять 
по самым разным причинам, ты передаёшь только адрес к значению, тем самым лишний раз не напрягая программу и компьютер.
==========================================



--кортежи (tuple)--
------------------------------------------
Кортежи предоставляют удобный способ для работы с набором значений это как бы папка с несколькими файлами в ней
Кортежи - это значения, поэтому они копируются по значению, а не по ссылке.
Анонимные типы и кортежи используются, когда нет значения дизайна, и все, что вам нужно, - это легкий объект передачи данных (DTO) для перемещения информации.

кортежи исопльзуются:

Для представления одного набора данных. Например, кортеж может представлять запись базы данных, 
а ее компоненты могут представлять отдельные поля записи.

Для обеспечения простого доступа к набору данных и его манипуляции.

Для получения нескольких значений из метода без использования out параметров (в C#) или ByRef параметров (в Visual Basic).

Передача нескольких значений в метод через один параметр. Например, Thread.Start(Object) метод имеет один параметр, который 
позволяет указать одно значение для метода, выполняемого потоком во время запуска. При указании Tuple<T1,T2,T3> 
объекта в качестве аргумента метода можно указать подпрограммы запуска потока с тремя элементами данных.

------------------------------------------
var tuple = (5, 10);
В данном случае определен кортеж tuple, который имеет два значения: 
5 и 10. В дальнейшем мы можем обращаться к каждому из этих значений через поля с 
названиями Item[порядковый_номер_поля_в_кортеже]

 var tuple = (5, 10);
    Console.WriteLine(tuple.Item1); // 5
    Console.WriteLine(tuple.Item2); // 10
    tuple.Item1 += 26;
    Console.WriteLine(tuple.Item1); // 31
    Console.Read();
------------------------------------------
типы данных в кортежах
можно использовать в котряжах как один тип данных 
(int, int) tuple = (5, 10);
Console.WriteLine(tuple.Item1);
Console.WriteLine(tuple.Item2);

так и несколько  

(string, int, double) person = ("Tom", 25, 81.23);
Console.WriteLine(person.Item1);//Tom
Console.WriteLine(person.Item2);//25
Console.WriteLine(person.Item3);//81.23

(double, int) t1 = (4.5, 3);
Console.WriteLine(t1.Item1);
Console.WriteLine(t1.Item2);

в случае если у перменных кортежа есь названиея нет необходисмости писатьть имя кортежу, 
достаточно обращатся к нему через его внутренние перменные:
var (name, age) = ("Tom", 23);
Console.WriteLine(name);// Tom
Console.WriteLine(age);// 23

------------------------------------------
названия полей кортежа
в случае если у перменных кортежа есь названиея нет необходисмости писатьть имя кортежу, 
достаточно обращатся к нему через его внутренние перменные:
Мы также можем дать названия полям кортежа
var tuple = (count:5, sum:10);
Console.WriteLine(tuple.count);//5
Console.WriteLine(tuple.sum); //10

(double Sum, int Count) d = (4.5, 3);
Console.WriteLine(d.Sum);
Console.WriteLine(d.Count);
------------------------------------------
возврат кортежа из метода

static void Main(string[] args)
{
    var tuple = GetValues();//присваиваем кортежу tuple результат работы метода - наш кортеж result
    Console.WriteLine(tuple.Item1); // 1
    Console.WriteLine(tuple.Item2); // 3
     
    Console.Read();
}

private static (int, int) GetValues()//создаем ворзващаемое значение ктореж из двух чисел
{
    var result = (1, 3);//инницииализируем кортеж
    return result;//возвращаем кортеж
}
--

private static (int sum, int count) GetNamedValues(int[] numbers)//создаем ворзващаемое значение ктореж из двух чисел с названиями полей кортежа
            //, а в аргумент записиываем массив из чисел
        {
            var result = (sum: 0, count: 0);//присваиваем занчениие нашему кортежу через обращение к его именам
           
            for (int i = 0; i < numbers.Length; i++)//перебиарем список 
            {
                result.sum += numbers[i];//в перменнную кортежа result.sum кладем резуолтат сложения всех занчений
                result.count++;// в перменную count кладем количество сложений
            }
            return result;//возарвщаем наш кортеж 
        }

static void Main(string[] args)
        {
            var tuple = GetNamedValues(new [] { 1, 2, 3, 4, 5, 6, 7 });//присваиваем кортежу tuple результат работы мтеода с именоваными пременными  (int sum, int count)
            //,а в аргумент записываем список
            Console.WriteLine(tuple.count);//обращаемся к членам кортежа через их имя и получаем значение
            Console.WriteLine(tuple.sum);
            Console.Read();
        }
        
------------------------------------------
передача в метод кортежа ввиде свойства

private static (string name, int age) GetTuple((string n, int a) tuple, int x)//создаем ворзващаемое значение ктореж из двух чисел с названиями полей кортежа
            //, а в аргумент записиываем еще один кортеж и число 
        {
            var result = (name: tuple.n, age: tuple.a + x);//заполняем наш возрварщаемый тупл занчениями из тупла аргумента, 
            return result;//result
        }

static void Main(string[] args)
        {
            var (name, age) = GetTuple(("Tom", 23), 12);
            Console.WriteLine(name);    //обращение к кортежу идет через возварщаемый тип те name а не n, Tom
            Console.WriteLine(age);     //обращение к кортежу идет через возварщаемый тип те age а не a, 35
            Console.Read();
        }
------------------------------------------
отличие кортежа от анонимного типа

Кортеж не является анонимным, это именованный тип. Вы можете использовать его как возвращаемый тип или аргумент метода. 
Этот код действителен:

 Tuple<int, string> GetTuple()
            {
                return Tuple.Create(1, "Bob");
            }
            Console.WriteLine(GetTuple());//(1, "Bob")
Вы не можете сделать это с анонимным типом, вам придется возвращать System.Object. Как правило,
 вам нужно использовать Reflection для этих объектов (или dynamic в .NET 4), чтобы получить значения отдельных свойств.


Кроме того, как упоминает Брайан, имена свойств в Tuple фиксированы - они всегда Item1, Item2, Item3 и т.д., 
тогда как с анонимным типом вы выбираете имена, Если вы пишете:

var x = new { ID = 1, Name = "Bob" }

Тогда анонимный тип имеет свойства ID и Name. Но если вы пишете:


Tuple.Create(1, "Bob")

Тогда полученный набор имеет свойства Item1 и Item2.            


==========================================

--анонимные типы--
------------------------------------------
Анонимные типы позволяют создать объект с некоторым набором свойств без определения класса. 
Анонимный тип определяется с помощью ключевого слова var и инициализатора объектов:
var user = new { Name = "Tom", Age = 34 };
          Console.WriteLine(user.Name);//"Tom"

В данном случае user - это объект анонимного типа, у которого определены два свойства Name и Age.
 И мы также можем использовать его свойства, как и у обычных объектов классов. Однако тут есть ограничение - 
 свойства анонимных типов доступны только для чтения.

Следует учитывать, что свойства анонимного объекта доступны для установки только в инициализаторе. 
Вне инициализатора присвоить им значение мы не можем.
 var student = new { Name = "Alice", Age = 21 };
student.Age = 32;   // ! Ошибка

Иногда возникает задача использовать один тип в одном узком контексте или даже один раз.
 Создание класса для подобного типа может быть избыточным. Если нам захочется добавить свойство, 
 то мы сразу же на месте анонимного объекта это можем сделать. В случае с классом придется изменять еще и класс,
  который может больше нигде не использоваться. Типичная ситуация - получение результата выборки из базы данных: 
  объекты используются только для получения выборки, часто больше нигде не используются, и классы для них создавать 
  было бы излишне. А вот анонимный объект прекрасно подходит для временного хранения выборки.
==========================================


--наследование--
------------------------------------------
После двоеточия мы указываем базовый класс для данного класса. Для класса Employee базовым является Person, 
и поэтому класс Employee наследует все те же свойства, методы, поля, которые есть в классе Person. Единственное, 
что не передается при наследовании, это конструкторы базового класса.

class Person
{
    public string Name { get; set; }
    public Person(string name)
    {
        Name = name;
    }
    public void DisplayName()
    {
        Console.WriteLine(Name);
    }
}

class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company) : base(name)
    {
        Company = company;
    }
}

class Program
{
    static void Main(string[] args)
    {
        Person p1 = new Person("Bill");
        Employee p2 = new Employee("Tom", "Microsoft");
        p1.DisplayName();//Bill
        p2.DisplayName();//Tom функционал из Person Name из Employee
        Console.ReadKey();
    }
}

------------------------------------------

delegate void AccountHandler(string message);
    class Person
    {
        public event AccountHandler _notify;
        private string name;
        string tempName;
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value != name)
                {
                    name = value;
                    DisplayTo();
                }
                
            }
        }

        public void DisplayTo()
        {
            _notify?.Invoke(name);
        }

    }
    class Employee : Person//этот класс будет реализовывать тот же функционал, что и класс Person
                           //Таким образом, наследование реализует отношение is-a (является),
                           //объект класса Employee также является объектом класса Person:
    {

    }
    class Program
    {
        static void Main(string[] args)
        {

            Person p = new Person();
            p._notify += Display;
            p.Name = "flfl";
            p = new Employee();//И поскольку объект Employee является также и объектом Person,
                               //то мы можем так определить переменную: Person p = new Employee().
            p._notify += Display;//но так как новый экземпляр всегода
            //создается с дефолтными значениями
            //нам нажно переподключится к ивенту
            p.Name = "Josh";
            Console.Read();
        }

        static void Display(string name)
        {
            Console.WriteLine(name);
        }
    }

------------------------------------------
class one{}
class two : one{}
class three
one newone = new two();//в этом случае выделяется память под объект two, и поскольку two является наследником от one,
 //то такое использование является допустимым. это апкаст
  //Затем мы можем использовать созданный объект как one и как two, но чтобы использовать его как two,
   //надо будет выполнить явное преобразование к two в виде даункаста

------------------------------------------
По умолчанию все классы наследуются от базового класса Object, даже если мы явным образом не устанавливаем наследование. 
Поэтому выше определенные классы Person и Employee кроме своих собственных методов, также будут иметь и методы класса 
Object: ToString(), Equals(), GetHashCode() и GetType().
------------------------------------------
Все классы по умолчанию могут наследоваться. Однако здесь есть ряд ограничений:
Не поддерживается множественное наследование, класс может наследоваться только от одного класса.
При создании производного класса надо учитывать тип доступа к базовому классу - тип доступа к производному классу
 должен быть таким же, как и у базового класса, или более строгим. То есть, если базовый класс у нас имеет тип доступа
  internal, то производный класс может иметь тип доступа internal или private, но не public.
Однако следует также учитывать, что если базовый и производный класс находятся в разных сборках (проектах), 
то в этом случае производый класс может наследовать только от класса, который имеет модификатор public.
Если класс объявлен с модификатором sealed, то от этого класса нельзя наследовать и создавать производные классы. 
Например, следующий класс не допускает создание наследников:
sealed class Admin//модификатор по умолчанию - internal
{

}
------------------------------------------
Доступ к членам базового класса из класса-наследника

class Person
    {
       
        private string name;
       
        public string Name
        {
            get...

class Employee : Person
{
    public void Display()
    {
        Console.WriteLine(_name);//не скомпирилуется тк k _name доступ имеет только класс Person
    }
}            
--------
class Employee : Person
{
    public void Display()
    {
        Console.WriteLine(Name);// общедоступное свойство Name, которое мы можем использовать
    }
}

------------------------------------------
Таким образом, производный класс может иметь доступ только к тем членам базового класса, 
которые определены с модификаторами private protected (если базовый и производный класс
 находятся в одной сборке), public, internal (если базовый и производный класс находятся в одной сборке), 
protected и protected internal.
------------------------------------------
порядок вызовов констуркторов

При вызове конструктора класса сначала отрабатывают конструкторы базовых классов и только затем конструкторы производных.

class Person
{
    string name;
    int age;
 
    public Person(string name)//сперва отработает этот конструктор 
    {
       //1
    }
    public Person(string name, int age) : this(name)//далее этот тк через this он вызывает первй конструктор
    {
    	//2
    }
}
class Employee : Person
{
    string company;
 
    public Employee(string name, int age, string company) : base(name, age)//и потом уже этот тк он вызывает через 
    //base контсркутор 2 ктороый в свою очередь через this вызывает кнстр 1
    {
      //3
    }
}

Employee tom = new Employee("Tom", 22, "Microsoft");//в случае создания обьекта Employee мы получим 
//вышенапиисаный порядок вызово конструкторов
------------------------------------------
Ключевое слово base

С помощью ключевого слова base мы можем обратиться к базовому классу. В нашем случае в конструкторе 
класса Employee нам надо установить имя и компанию. Но имя мы передаем на установку в конструктор базового класса, 
то есть в конструктор класса Person, с помощью выражения base(name).

class Person
{
    public string Name { get;  set; }
 
    public Person(string name)//вот это конструктора мы вызваем из ксласса Employee через выржаение base
    {
        Name = name;
    }
 
    public void Display()
    {
        Console.WriteLine(Name);
    }
}
 
class Employee : Person
{
    public string Company { get; set; }
 
    public Employee(string name, string company)
        : base(name)//С помощью ключевого слова base мы можем обратиться к базовому классу Person.
        //Класс Person имеет конструктор, который устанавливает свойство Name. 
        //Поскольку класс Employee наследует и устанавливает то же свойство Name, 
        //то логично было бы не писать по сто раз код установки, а вызвать соответствующий код класса Person. 
    {
        Company = company;
    }
}

Person p = new Person("Bill");
   
Employee emp = new Employee ("Tom", "Microsoft");//имя мы передаем на установку в конструктор базового класса,
// то есть в конструктор класса Person, с помощью выражения base(name)
------------------------------------------

если в базовом классе не определен конструктор по умолчанию без параметров, 
а только конструкторы с параметрами (как в случае с базовым классом Person), 
то в производном классе мы обязательно должны вызвать один из этих конструкторов через ключевое слово base.

==========================================



--преобразование типов--

------------------------------------------
Восходящие преобразования. Upcasting

восходящее преобразование от производного к базовому, перход от конкретизации к обощенности. Это позволяет работать с обьектами
имеющими один и тот же базовый класс не отвлекаясь на их индивидуальные особенности, предпологается работа с ними используя их 
общий фунционал заложеный в них через базовый класс.

пременной обьекта класса родителя Person person , присваиваешь пременную обьекта класса потомока Employee employee
и ты автоматом выполняешь некое преобразование. 
вот оно и называется как раз "восходящим" или "Upcasting" тк ты  потомка employee преобразуешь в класс предок person 
который находится вверху иерархии классов и они типа таким образом обе эих перменных те перменная потомка и перменная
родителя с присвоеной в нее переменноой потомка начинают указыать на один класс в куче, но перменной класса родителя
будет доступна только та часть кода которая в ней собтвенно есть те дополнительные функции и поля из потомка ей недоступны

В данном случае переменной person, которая представляет тип Person, присваивается ссылка на объект Employee.
 Но чтобы сохранить ссылку на объект одного класса в переменную другого класса, необходимо выполнить 
 преобразование типов - в данном случае от типа Employee к типу Person.

 class Person
    {
        public string Name { get; set; }
        public Person(string name)
        {
            Name = name;
        }
        public void Display()
        {
            Console.WriteLine($"Person {Name}");
        }
    }

    class Employee : Person
    {
        public string Company { get; set; }
        public Employee(string name, string company) : base(name)
        {
            Company = company;
        }

    }

    class Client : Person
    {
        public string Bank { get; set; }
        public Client(string name, string bank) : base(name)
        {
            Bank = bank;
        }
    }

    class Program
    {
       
        static void Main(string[] args)
        {
            Employee employee = new Employee("Tom", "Microsoft");
            
            Person person = employee;   // преобразование от Employee к Person
            // В итоге переменные employee и person будут указывать на одно и то же место в памяти(Employee),
            // но переменной person будет доступна только та часть, которая представляет функционал типа Person.
            // Это назыывается  восходящие преобразования

            if (employee is Person person)//это аналогично вышенаписаной констркуции (Person person = employee) 
            //но здесь дополнительно идет проверка на возможность преобразования выражения в указанный тип и, 
            //если это возможно, приводит переменную к переменной этого типа.
        	{
        	//varname назначается только в пределах инструкции if
            Console.WriteLine(person.Name);
            Console.WriteLine(person.Company);//это выдаст ошибку тк поле Company принадлежит к классу Employee
            //а ссылочная перменная обьект person, указывает сейчас на класс Person, те поля и методы обьекта
            //employee перменной person недоступны
        	}
			
            Person person1 = new Client("Bob", "ContosoBank");//Здесь переменная person1, которая представляет
            //тип Person, хранит ссылку на объект Client, поэтому также выполняется восходящее неявное преобразование
            //от производного класса Client к базовому типу Person.
 			
            Console.ReadKey();

            Так как тип object -базовый для всех остальных типов, то преобразование к нему будет 
            производиться автоматически.

            object person2 = new Employee("Tom", "Microsoft");  // от Employee к object
            object person3 = new Client("Bob", "ContosoBank");  // от Client к object
            object person4 = new Person("Sam"); // от Person к object
        }
    }

//это...
    Employee employee = new Employee("Tom", "Microsoft");
    Person person = employee;

//...аналогично нижеследуеще записи толоко без создание отдельной перменной employee
    Person person = new Employee("Tom", "Microsoft");
------------------------------------------
Нисходящие преобразования. Downcasting

нисходящие преобразования или downcasting - от базового типа к производному.
Но автоматически такие преобразования не проходят, ведь не каждый человек (объект Person) является сотрудником 
предприятия (объектом Employee)тк у сотрудника предприятия есть дополнительные методы свойства поля и тд. неописанные
в обьекте Person. Поэтому для нисходящего преобразования необходимо применить явное преобразования,
указав в скобках тип, к которому нужно выполнить преобразование:

Employee employee = new Employee("Tom", "Microsoft");
Person person = employee;   // преобразование от Employee к Person
//переменная person хранит ссылку на объект Employee
//сперва апкаст а потом уже даункасат 
//Потому, что объект создан и занимает в памяти 20 байт. И он никак не может кастнуться в объект который 
//должен занимать 20 Мб.

Employee employee2 = person;// так нельзя, нужно явное преобразование 

Employee employee1 = (Employee)person;//после апкаста можно уже производить явное преобразование от
// Person к Employee

Console.WriteLine(employee1.Name +" "+ employee1.Company);

object obj = new Employee("Bill", "Microsoft");
// чтобы обратиться к возможностям типа Employee,явно приводим объект к типу Employee
Employee emp = (Employee)obj;//В этом случае переменной obj присвоена ссылка на объект Employee, 
//поэтому мы можем преобразовать объект obj к любому типу который располагается в иерархии классов между 
//типом object и Employee.

Если нам надо обратиться к каким-то отдельным свойствам или методам объекта, то нам необязательно присваивать 
преобразованный объект переменной :

// Объект Employee также представляет тип object
object obj = new Employee("Bill", "Microsoft");
 
// преобразование к типу Person для вызова метода Display
((Person)obj).Display();
// либо так
((Employee)obj).Display();
 
// преобразование к типу Employee, чтобы получить свойство Company
string comp = ((Employee)obj).Company;


------------------------------------------
is 
по сути отличие is от as в том что is возращает bool, а as в случае неудачи вернет null

is в случае с апкастом

Employee employee = new Employee("Tom", "Microsoft");
            
            Person person = employee;   // преобразование от Employee к Person
            // В итоге переменные employee и person будут указывать на одно и то же место в памяти(Employee),
            // но переменной person будет доступна только та часть, которая представляет функционал типа Person.
            // Это назыывается  восходящие преобразования

            if (employee is Person person)//это аналогично вышенпаисной констркуции (Person person = employee) 
            //но здесь дополнительно идет проверка на возможность преобразования выражения в указанный тип и, 
            //если это возможно, приводит переменную к переменной этого типа. если это не возможно
            // такая проверка вернет значение false, и преобразование не сработает.
            {
            //varname назначается только в пределах инструкции if
            Console.WriteLine(person.Name);
            Console.WriteLine(person.Company);//это выдаст ошибку тк поле Company принадлежит к классу Employee
            //а ссылочная перменная обьект person, указывает сейчас на класс Person, те поля и методы обьекта
            //employee перменной person недоступны
            }


еще одна проверка допустимости преобразования с помощью ключевого слова is в случае с даункастом

class Person
    {
        public string Name { get; set; }
        public Person(string name)
        {
            Name = name;
        }
        public void Display()
        {
            Console.WriteLine($"Person {Name}");
        }
    }

    class Employee : Person
    {
        public string Company { get; set; }
        public Employee(string name, string company) : base(name)
        {
            Company = company;
        }

    }

    Person person = new Person("Tom");

    if(person is Employee)//Выражение person is Employee проверяет, является ли переменная person объектом типа Employee.
    // Но так как в данном случае явно не является, то такая проверка вернет значение false, и преобразование не сработает.
    //здесь неудачная попытка произвести даункаст если мы перед эти сделаем так  (сперва апкаст) 
    //Person person = new Employee("Mix", "Apple"); то это преобразование сработает
    {
        Employee emp = (Employee)person;
        Console.WriteLine(emp.Company);
    }
    else
    {
        Console.WriteLine("Преобразование не допустимо");
    }       

------------------------------------------
as в случае с даункастом

Структура - это тип значения(стурктура является значимым типом), ,
поэтому ее нельзя использовать с as оператором,
тк as Оператор должен иметь возможность присвоить значение NULL если терпит неудачу.
Это возможно только со ссылочным типом или типом значения, допускающим значение NULL.


as в случае с апкастом

Employee employee = new Employee("Tom", "Microsoft");

            var emp = p3 as Person; //это бесмыленно потому что никогда не станет null
            //для этого лучше исопльзовать is

            if (emp == null)
            {
                Console.WriteLine("Преобразование прошло неудачно");
            }
            else
            {
                Console.WriteLine(emp.Name);
            }


as в случае с даункастом

Person person = new Person("Tom");

Employee emp = person as Employee;//пытается преобразовать выражение к определенному типу в
// случае неудачного преобразования выражение будет содержать значение null здесь неудачная попытка произвести
// даункаст если мы перед эти сделаем так (сперва апкаст)Person person = new Employee("Mix", "Apple"); 
  //то это преобразование сработает

if (emp == null)
{
    Console.WriteLine("Преобразование прошло неудачно");
}
else
{
    Console.WriteLine(emp.Company);
}


______________________________  
class Person
    {
        public string Name { get; set; }

        public Person(string name)
        {
            Name = name;
        }

        public virtual string Display() //методы и свойства, которые мы хотим сделать доступными для переопределения,
            // в базовом классе помечается модификатором virtual. Такие методы и свойства называют виртуальными.
        {
            return Name;
        }

        public string SS()
        {
            return "SS in Person";
        }
    }

    class Employee : Person
    {
        public string Company { get; set; }

        public Employee(string name, string company) : base(name)
        {
            Company = company;
        }

        //методы можно перопрделть а можно оставлять как есть в этом случае объекты Employee будут использовать реализацию 
        //метода Display из класса Person те из базового класса, те если мы УДАЛИМ отсюда метод Display, будет исопльзован 
        //ОРИГИНАЛЬНЫЙ Display из класса Person
        public override string Display() //А чтобы переопределить метод в классе-наследнике, этот метод определяется 
            //с модификатором override. 

            //Переопределенный метод в классе-наследнике должен иметь тот же набор параметров, что и виртуальный метод в базовом классе.
        {
            if (Name == "Tom")
            {
                Name = "Max";
                return Name + $" {Company}";
            }

            return base.Display() + $" {Company}";
        }

        public string SS()
        {
            return "SS in Emplouee";
        }
    }

    class EmployeeTwo : Employee
    {
        public int Age { get; set; }

        public EmployeeTwo(string name, string company, int age) : base(name, company)
        {
            Age = age;
        }

        public override string Display() //Виртуальные методы базового класса определяют интерфейс всей иерархии, 
            //то есть в любом производном классе, который не является прямым наследником от базового класса, можно 
            //переопределить виртуальные методы.
            //Например, мы можем определить класс Manager, который будет производным от Employee, и в нем также переопределить 
            //метод Display.
        {
            return base.Display() + $" {Age}";
        }


    }

    class Program
    {
        static void Main(string[] args)
        {
            Person p1 = new Person("Bill");
            Console.WriteLine(p1.Display()); //Bill
            // вызов метода Display из класса Perso
            Employee p2 = new Employee("Tom", "Microsoft");
            Console.WriteLine(p2.Display()); //Max Microsoft
            // вызов метода Display из класса Person
            if (p2 is Person p)
            {
                Console.WriteLine(p.Display()); //"Tom", "Microsoft" тк метод виртуальный то при апкасте будет
                //исопльзоватся его верисия из класса потомка Employee p2
                Console.WriteLine(p.SS()); //это обычный метод поэтому будет исполльзоватся из класса родителя Person p1
            }


            Person pers = p2;

            Employee emp = (Employee) pers;


            Person person = new Person("Tom");
            //пытается преобразовать выражение к определенному типу в
            // случае неудачного преобразования выражение будет содержать значение null 
            EmployeeTwo p3 = new EmployeeTwo("Tommi", "Microsoftuuuss", 20);
            Console.WriteLine(p3.Display()); //Tommi Microsoftuuuss 20

            Console.ReadKey();
        }
    }




==========================================
--лоакльаные функции--
------------------------------------------
Локальные функции представляют функции, определенные внутри других методов. Определим и используем локальную функцию:

  static void Main(string[] args)
        {
            var result = GetResult(new int[] {-3, -2, -1, 0, 1, 2, 3});
            Console.WriteLine(result); // 6
            Console.Read();
        }

        static int GetResult(int[] numbers)
        {
            int limit = 0;

            // локальная функция
           

            int result = 0;
            for (int i = 0; i < numbers.Length; i++)
            {
                if (IsMoreThan(numbers[i]))// не имеет значения, определены локальные функции до своего вызова или после.
                {
                    result += numbers[i];
                }
                else if(IsStaticMoreThan(numbers[i]))
                {
                    result = 0;
                }
            }

            bool IsMoreThan(int number) //Здесь в методе GetResult определена локальная функция IsMoreThan(), которая может быть вызвана только внутри этого метода,
                // и не может имет можиффикатор доступа
            {
                if (result > 0)
                {
                    return number > limit; //Локальная функция задает еще одну область видимости, где мы можем определять переменные и выполнять над ними действия.
                    //В то же время ей доступны все переменные, которые определены в том же методе. и  вне его
                }

                return false;
            }
            static bool IsStaticMoreThan(int number)//можно определять  статические локальные функции не могут братьт перменные из тела мтеода в котором назодятся
            {
                int limit = 0;
                //if (result == 0)//вызовет ошибку потому что они не могут обращаться к переменным окружения, то есть метода, в котором статическая функция определена
                //{
                //    return number < limit;
                //}
                return number > limit;
            }

            //string IsMoreThan(string str) //нельзя определить в оном мтеоде несолкько локальных функций с одинаковы именем даже если у них отличается 
            //возрващаемое значение и список параметров
            //{
            //    return str;
            //}

            return result;
        }
==========================================


--
------------------------------------------


==========================================



--преобразование типов перегрузка--
------------------------------------------

public static implicit|explicit operator Тип_в_который_надо_преобразовать(исходный_тип param)// explicit если 
//преобразование явное и implicit если преобразование неявное
{
    // логика преобразования
}
Какие операции преобразования делать явными,а какие неявные,не столь важно, это решает разработчик по своему усмотрению.
------------------------------------------
class Counter
{
public int Seconds { get; set; }

    public static explicit operator int(Counter counter)//преобразует объект Counter к типу int, то есть получает 
    //из Counter число.
    {
        return counter.Seconds;
    }

     public static implicit operator Counter(int x)//преобразует число объект типа int к типу Counter. 

    {
        return new Counter { Seconds = x };// тут создается новый объект Counter, у которого устанавливается 
        //свойство Seconds.
    }
}


    static void Main(string[] args)
    {
        Counter counter1 = new Counter { Seconds = 23 };

        int x = (int)counter1;//преобразует объект Counter к типу int x, то есть получает из Counter число.explicit
        //и это преобразование явное
    {
        Console.WriteLine(x);   

        Counter counter2 = x;//преобразует число x объект типа int к типу Counter. implicit и это преобразование неявное
        Console.WriteLine(counter2.Seconds);  // 23
    }

если для преобразования потребуется более сложная логика, то просто так написать не получится. Например,
 во втором примере при преобразовании от типа Counter к типу Timer сложность преобразования возрастает,
 соотвественно лучше один раз определить оператор, чем по сто раз писать один и тот же набор операций. 
 А в случае преобразований с более сложной логикой это тем более актуально

class Timer
{
    public int Hours { get; set; }
    public int Minutes { get; set; }    
    public int Seconds { get; set; }
}
class Counter
{
    public int Seconds { get; set; }
 
    public static implicit operator Counter(int x)
    {
        return new Counter { Seconds = x };
    }
    public static explicit operator int(Counter counter)
    {
        return counter.Seconds;
    }
    public static explicit operator Counter(Timer timer)
    {
        int h = timer.Hours * 3600;
        int m = timer.Minutes * 60;
        return new Counter { Seconds = h + m + timer.Seconds };
    }
    public static implicit operator Timer(Counter counter)
    {
        int h = counter.Seconds / 3600;
        int m = (counter.Seconds % 3600) / 60;
        int s = counter.Seconds % 60;
        return new Timer { Hours = h, Minutes = m, Seconds = s };
    }
}

static void Main(string[] args)
{
    Counter counter1 = new Counter { Seconds = 115 };
 
    Timer timer = counter1;
    Console.WriteLine($"{timer.Hours}:{timer.Minutes}:{timer.Seconds}"); // 0:1:55
 
    Counter counter2 = (Counter)timer;
    Console.WriteLine(counter2.Seconds);  //115
     
    Console.ReadKey();
}
==========================================


--виртуальные b переопределенные (virtual, override) методы и свойства--
------------------------------------------
виратуальный метод или свойства могу находится в обычном классе родителе, могут иметь свою функциональность,
при этом могут быть (а могут и не быть, тогда их функционал будет просто использован из класса родителя)  
перпоределнными в потмках, вызыватся через экземпляр класса в котором они обьявлены.

простой пример это у класса Human есть метод Display вывода на экран поля Name , а в классе наследнике Employee 
этот метод перопределяется для вывода на экран Name из класса Human + Company из класса Employee(те приобретает 
доп функциональность)

модификатор доступа должен быть одинаковым
------------------------------------------
пример ипсользования вриитуальнных методов а так же апкаст(upcasting) и даункаст (downcasting)
class Person
{
    public string Name { get; set; }
    public Person(string name)
    {
        Name = name;
    }
    public virtual string Display()//методы и свойства, которые мы хотим сделать доступными для переопределения,
    // в базовом классе помечается модификатором virtual. Такие методы и свойства называют виртуальными.
    {
        return Name;
    }

     public string SS()
        {
            return "SS in Person";
        }
}
class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company) : base(name)
    {
        Company = company;
    }

    //методы можно перопрделть а можно оставлять как есть в этом случае объекты Employee будут использовать реализацию 
    //метода Display из класса Person те из базового класса, те если мы УДАЛИМ отсюда метод Display, будет исопльзован 
    //ОРИГИНАЛЬНЫЙ Display из класса Person
    public override string Display()//А чтобы переопределить метод в классе-наследнике, этот метод определяется 
    //с модификатором override. 

    //Переопределенный метод в классе-наследнике должен иметь тот же набор параметров, что и виртуальный метод в базовом классе.
    {
        if (Name =="Tom")
        {
            Name = "Max";
            return Name + $" {Company}";
        }
        return base.Display() + $" {Company}";
    }
    public string SS()
        {
            return "SS in Emplouee";
        }
}

class EmployeeTwo : Employee
{
    public int Age { get; set; }
    public EmployeeTwo(string name, string company, int age) : base(name, company)
    {
        Age = age;
    }

    public override string Display()//Виртуальные методы базового класса определяют интерфейс всей иерархии, 
    //то есть в любом производном классе, который не является прямым наследником от базового класса, можно 
    //переопределить виртуальные методы.
    //Например, мы можем определить класс Manager, который будет производным от Employee, и в нем также переопределить 
    //метод Display.
    {
        return base.Display() + $" {Age}";
    }
}
class Program
{
    static void Main(string[] args)
    {
        Person p1 = new Person("Bill");
        Console.WriteLine(p1.Display());//Bill
        // вызов метода Display из класса Person

        Employee p2 = new Employee("Tom", "Microsoft");
        Console.WriteLine(p2.Display());//Max Microsoft
        // вызов метода Display из класса Person

        if (p2 is Person p)
            {
                Console.WriteLine(p.Display()); //"Max", "Microsoft" тк метод виртуальный то при апкасте будет
                //исопльзоватся его верисия из класса потомка Employee p2
                Console.WriteLine(p.SS()); //это обычный метод поэтому будет исполльзоватся из класса родителя Person p1
            }

            Person pers = p2;
            Employee emp = (Employee) pers;

            Console.WriteLine(emp.Display());//"Max", "Microsoft" тк метод виртуальный то при даункасте  будет
            //исопльзоватся его верисия из класса потомка Employee p2
            Console.WriteLine(emp.SS());//это обычный метод поэтому будет исполльзоватся из класса родителя Person p1


        EmployeeTwo p3 = new EmployeeTwo("Tommi", "Microsoftuuuss", 20);
        Console.WriteLine(p3.Display());//Tommi Microsoftuuuss 20

        Console.ReadKey();
    }
}

Также можно запретить переопределение методов и свойств. В этом случае их надо объявлять с модификатором sealed

 public override sealed string Display();//производится только в произодном классе в класс родителе смысл делать 
 //нет тк проще убраьт virtual

------------------------------------------
виртуальные свойства

так же монжно перопрделть свойства, модификатор доступа должен быть одинаковым

class Credit
{
    public virtual decimal Sum { get; set; }//свойства, которые мы хотим сделать доступными для переопределения,
    // в базовом классе помечается модификатором virtual. Такие методы и свойства называют виртуальными.
}
class LongCredit : Credit
{
    private decimal sum;
    public override decimal Sum//А чтобы переопределить свойство в классе-наследнике, этот свойство определяется 
    //с модификатором override. 
    //Переопределенный свойство в классе-наследнике должен иметь тот же набор параметров, 
    //что и виртуальный свойство в базовом классе.
    {
        get
        {
            return sum;
        }
        set
        {
            if (value > 1000)
            {
                sum = value;
            }
        }
    }
}
class Program
{
    static void Main(string[] args)
    {
        LongCredit credit = new LongCredit { Sum = 6000 };
        credit.Sum = 490;
        Console.WriteLine(credit.Sum);
        Console.ReadKey();
    }
}

==========================================



--сокрытие (new void method)--
------------------------------------------
Это когда скрываем в производном классе функциноал базового класса
определение в классе-наследнике метода или свойства,которые соответствует по имени и набору параметров методу или
свойству базового класса. по сути создается еще один метод с таким же названием не взяаный с пердыдущим, используется
для разрешения конфликат имен без использования преопределения

Для сокрытия членов класса применяется ключевое слово new. 

Если вы работаете с экземпляром класса-наследника через его родительский класс, то в случае, если вы будете вызывать
 переопределенный виртуальный метод (override), то будет вызвана его реализация из наследника, а если перекрытый (new), 
 то будет вызван метод базового класса

class Main
    {
        public virtual void First()
        {
            Console.WriteLine("First from Main");
        }

        public void Second()
        {
            Console.WriteLine("Second from Main");
        }
    }

    class Child : Main
    {
        public override void First()//Модификатор override расширяет реализацию для наследуемого члена.
        {
            Console.WriteLine("First from Child");
        }

        public new void Second()//Модификатор new создает новый член с таким же именем и приводит к скрытию исходного члена. 
        {
            Console.WriteLine("Second from Child");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Main main = new Child();//Если вы работаете с экземпляром класса-наследника через его родительский класс

            main.First(); // то в случае, если вы будете вызывать
 //переопределенный виртуальный метод (override) - выведет метод First у Child
            main.Second(); // а если перекрытый (new), 
 //то будет вызван метод базового класса - выведет метод Second у Main
        }
    }

------------------------------------------
 class Person
    {

        public string FirstName { get; set; }
        public string LastName { get; set; }

        public Person(string firstName, string lastName)
        {
            FirstName = firstName;
            LastName = lastName;
        }

        public void Display()
        {
            Console.WriteLine($"{FirstName} {LastName}");
        }

        public void DisplayIs()
        {
            Console.WriteLine($"{FirstName} {LastName} AZazain");
        }
    }

    class Employee : Person
    {
        public string Company { get; set; }

        public Employee(string firstName, string lastName, string company)
            : base(firstName, lastName)
        {
            Company = company;
        }

        public new void Display() //этотт метод скрывает рализацию из класса Persone при этом неважно является ли метод
        // в классе родителя виртуальным или нет, если используется  var kek = (Employee) bob то мы получаем на выходе 
        //метод из Employee а не методж из класса Person это полезно использовать когжа нпример метод Display в 
        //базовом классе не является виртуальным,мы не можем его переопределить, и тут нам поможет именно такая
        // конструкция какnew void Display()
        {
            Console.WriteLine($"{FirstName} {LastName} работает в {Company}");
        }

        public void DisplayCompany()
        {
            Console.WriteLine($"{Company}");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Person bob = new Person("Bob", "Robertson");
            bob.Display(); // Bob Robertson

            bob = new Employee("Max", "Robertson", "okla"); //сперва апкаст а потом уже даункасат 
            //Потому, что объект создан и занимает в памяти 20 байт. И о не как не может кастнуться в объект
            // который должен занимать 20 .переменной bob будет доступна только та часть, которая представляет 
            //функционал типа Person.Это назыывается  восходящие преобразования
            bob.Display(); //Max Robertson 
            bob.DisplayIs();//Max Robertson AZazain

            bob.DisplayCompany(); // выдаст ошибку оптому что Person недоступен функционал типа Employee.

            var kek = (Employee) bob; //здесь происходит даункаст 
            kek.Display(); //Max Robertson работает в okla здесь используется сокрытый метод Display тк кек 
            //это обьект класса Employee 

            Employee tom = new Employee("Tom", "Smith", "Microsoft");//используется сокрытый метод Display 
            //тк кек это обьект класса Employee 
            tom.Display(); // Tom Smith работает в Microsoft
            Console.ReadKey();
        }
    }

------------------------------------------
аналогично можно реализовтаь сокрытие свойств 
class Person
{
    protected string name;
    public string Name
    {
        get { return name; }
        set { name = value; }
    }
}
class Employee : Person
{
    public new string Name
    {
        get { return "Employee " + base.Name; }
        set { name = value; }
    }
}
------------------------------------------
а так же переменные и константы
class ExampleBase
{
    public readonly int x = 10;
    public const int G = 5;
}
class ExampleDerived : ExampleBase
{
    public new readonly int x = 20;
    public new const int G = 15;
}

==========================================



--Абстрактные классы и члены классов--
------------------------------------------
а вот абстрактные класс может иметь как обыкновенные переменные и методы и конструкторы (со стандартным наполнением 
и объявлением) так и абстрактные методы и переменные (но тогда у них не должно  быть тела функциональности, 
они должны быть обязательно переопределены в потомках, а так же класс в которм есть хоть один абстрактный член 
должен быть сам абстрактным), и вот  эти абстракты не могут быть вызваны в отличии от вируталов через экземпляры. 
Аабстрактные классы как бы обьеднияют классы наследники какимито общими свойствами.

например есть фигура геометрическая по сути она без оперделения круга там или квадрат она не может сущетсвовать, 
и вот только когда мы преопределяем класс фигуры с полями типа Площадь и Периметр в какомнибудь там круге или 
треугольнике только там она начинает сущетсовать как бы

 при определении абстрактных классов используется ключевое слово abstractb и мы не можем использовать конструктор
  абстрактного класса для создания его объекта
abstract class Human
{
	...

Human h = new Human();//выдсат ошибку

эти классы используются для того чтобы определять общую функциональность например, имя и метод вывода на консоль имени

abstract class Person
{
    public string Name { get; set; }
 
    public Person(string name)
    {
        Name = name;//тут инициализировать некоторые общие для производных классов 
        //переменные и свойства, как в случае со свойством Name
    }
 
    public void Display()
    {
        Console.WriteLine(Name);
    }
    public abstract void DisplayIs();//определим абстрактный класс 
}
 
class Client : Person
{
    public int Sum { get; set; }    // сумма на счету
 
    public Client(string name, int sum)
        : base(name)
    {
        Sum = sum;
    }

     public override void DisplayIs()//переопреедлим асбтакртный класс из родителя, 
     //если этого не сделать компилятор выдаст ошибку 
        {
            Console.WriteLine($"{Name} имеет счет на сумму {Sum}");
        }
}
 
class Employee : Person
{
    public string Position { get; set; } // должность
 
    public Employee(string name, string position) 
        : base(name)
    {
            Position = position;
    }

     public override void DisplayIs()//переопреедлим асбтакртный класс из родителя, 
     //если этого не сделать компилятор выдаст ошибку 
        {
            Console.WriteLine($"{Position} {Name}");
        }
}

//И хотя в примере конструктор класса Person не вызывается, тем не менее производные классы Client и Employee 
//могут обращаться к нему.
 Client client = new Client("Tom", 500);
Employee employee = new Employee("Bob", "Apple");
client.Display();//Tom
employee.Display();//Bob
Person person = new Person ("Bill");//выдсат ошибку
------------------------------------------
абстрактные члены классов не имеют никакого функционала

Методы
Свойства
Индексаторы
События

abstract class Person
{
    public string Name { get; set; }
 
    public Person(string name)
    {
        Name = name;
    }
}

class Client : Person
{
    public int Sum { get; set; }    // сумма на счету
 
    public Client(string name, int sum)
        : base(name)
    {
        Sum = sum;
    }
    public override void Display()
    {
        Console.WriteLine($"{Name} имеет счет на сумму {Sum}");
    }
}

------------------------------------------
Следует отметить использование абстрактных свойств. Их определение похоже на определение автосвойств

abstract class Person
{
    public abstract string Name { get; set; }
}

class Client : Person
{
    private string name;
 
    public override string Name
    {
        get { return "Mr/Ms. " + name; }
        set { name = value; }
    }

    //или

    public override string Name { get; set; }
}
------------------------------------------
если нужно отказаться от реализации абстрактных членов в классе потомке нужно сделать его тоже абстрактным
abstract class Person
{
    public abstract string Name { get; set; }
}
 
abstract class Manager : Person
{

}
------------------------------------------
Xрестоматийным примером является система геометрических фигур. В реальности не существует геометрической фигуры как 
таковой.
 Есть круг, прямоугольник, квадрат, но просто фигуры нет. Однако же и круг, и прямоугольник имеют 
 что-то общее и являются фигурами
// абстрактный класс фигуры
abstract class Figure
{
    // абстрактный метод для получения периметра
    public abstract float Perimeter();
    // абстрактный метод для получения площади
    public abstract float Area();
}
// производный класс прямоугольника
class Rectangle : Figure
{
    public float Width { get; set; }
    public float Height { get; set; }
 
    public Rectangle(float width, float height)
    {
        this.Width = width;
        this.Height = height;
    }
    // переопределение получения периметра
    public override float Perimeter()
    {
        return Width * 2 + Height * 2;
    }
    // переопрелеление получения площади
    public override float Area()
    {
        return Width * Height;
    }
}

==========================================



--System.Object и его методы--
------------------------------------------
 мы можем переопределить метод ToString()

(string)obj производит явное преобразование obj в string. obj должен уже быть, string чтобы это удалось.

obj.ToString()получает строковое представление obj путем вызова ToString() метода. 
Это в отличии от явного приведения никогда не вызывовет исключения (если obj != null).

class Clock
    {
        public int Hours { get; set; }
        public int Minutes { get; set; }
        public int Seconds { get; set; }

        public override string ToString()//используется ключевое слово override для перопределения ToString
        {
            return $"{Hours}:{Minutes}:{Seconds}";
        }
    }
class Program
    {
        private static void Main(string[] args)
        {
            Clock clock = new Clock { Hours = 15, Minutes = 34, Seconds = 53 };
            Console.WriteLine(clock.ToString()); // выведет 15:34:53
             
            Console.Read();
        }
    }

------------------------------------------
Метод GetHashCode позволяет возвратить некоторое числовое значение(уникальное для каждого обекта), которое будет 
соответствовать данному объекту или его хэш-код. По данному числу, например, можно сравнивать объекты. 

 public string Name { get; set; }
 
    public override int GetHashCode()
    {
        return Name.GetHashCode();
    }

перопределние GetHashCode
 class human
    {
        public string Name { get; }

        public human(string name)
        {
            Name = name;
        }

        public override int GetHashCode()//перопределяем получение хашкода на проеку хешкода только имени 
        {
            return Name.GetHashCode();
        }
    }

human h = new human("Max");
human g = new human("Max");
Console.WriteLine($"client {h.GetHashCode()} ,clientone {g.GetHashCode()}" );//client 1627628113, 
//clientone 1627628113 hash коды одинаковые 

//тк мы проверяе хеш только имени
------------------------------------------
Метод GetType позволяет получить тип данного объекта

Person person = new Person { Name = "Tom" };
Console.WriteLine(person.GetType());   
В отличие от методов ToString, Equals, GetHashCode метод GetType не переопределяется.;
------------------------------------------
С помощью ключевого слова typeof мы получаем тип класса и сравниваем его с типом объекта. 
И если этот объект представляет тип Client, то выполняем определенные действия.

object person = new Person { Name = "Tom" };
if (person.GetType() == typeof(Person))
    Console.WriteLine("Это реально класс Person");

------------------------------------------
Метод Equals позволяет сравнить два объекта ПО ЗНАЧЕНИЮ а НЕ поссылке на равенство:

class Person
{
    public string Name { get; set; }
    public override bool Equals(object obj)
    {
        if (obj.GetType() != this.GetType()) return false;
 
        Person person = (Person)obj;
        return (this.Name == person.Name);
    }
}
Метод Equals принимает в качестве параметра объект любого типа, который мы затем приводим к текущему, 
если они являются объектами одного класса. Затем сравниваем по именам. Если имена равны, возвращаем true, что будет говорить,
 что объекты равны. Однако при необходимости реализацию метода можно сделать более сложной, например, сравнивать
 по нескольким свойствам при их наличии.
 ------------------------------------------
Equals(переопределенный) принимает в качестве параметра объект любого типа, который мы затем приводим к текущему, 
если они являются объектами одного класса.
 Затем сравниваем по именам. Если имена равны, возвращаем true, что будет говорить, что объекты равны. 
 Однако при необходимости реализацию метода можно сделать более сложной, например, 
 сравнивать по нескольким свойствам при их наличии.

Person person1 = new Person { Name = "Tom" };
Person person2 = new Person { Name = "Bob" };
Person person3 = new Person { Name = "Tom" };
bool p1Ep2 = person1.Equals(person2);   // false
bool p1Ep3 = person1.Equals(person3);   // true

Для типов значений == и Equals не имеет разницы, отличается ReferenceEquals, выдающий false, к примеру, для двух
 переменных типа int, равных 0 (потому, что сравнивает не значения, а ссылки). Для ссылочных типов эквивалентны 
 все три способа ==, Equals и ReferenceEquals,сравнивать значения аналогично типам значений возможно только с
 помощью переопределения, как и описано в примере

 public class Money
{
   public decimal Amount { get; set; }
   public string Unit { get; set; }

   public Money(decimal amount, string unit)
   {
     Amount = amount;
     Unit = unit;
   }

  public override bool Equals(object obj)
   {
     if (obj == null)
       return false;
     Money m = obj as Money; // возвращает null если объект нельзя привести к типу Money
     if (m as Money == null)
       return false;

     return m.Amount == this.Amount && m.Unit == this.Unit;//сравнивает значения Amoun и Unit
     //из новосодданного нами обьекта класса моне и из сществуюещего обьека в ктором находися
     //переопреледяемый метод Equals
   }
}
class Program
{
   static void Main(string[] args)
   {
     Money m1 = new Money(100, "RUR");
     Money m2 = new Money(100, "RUR");
     Money m3 = new Money(100, "USD");
     Money m4 = m1;
     Console.WriteLine(m1.Equals(m2)); // true
     Console.WriteLine(m1.Equals(m3)); // false
     Console.WriteLine(m1 == m2); // false
     Console.WriteLine(m1 == m4); // true
     Console.ReadLine();
   }
}
==========================================

--generics обобщения (--упаковка распкаовка boxing unboxing--)--
------------------------------------------
упаковка распкаовка

 class Account
    {
        public object Id { get; set; }
        public int Sum { get; set; }
    }

    Account acc1 = new Account();
    Account acc2 = new Account();
            
            //упкаовка и распкаовка ведут к снижению производительностьи и нарушению безопасности типа если
            // обьекты изменяются извне и мы можем не знать какие значения хранятся в этом обьекте если не те
            //к торым мы распаковываем происходит System.InvalidCastException

            acc1.Id = 45;// происходит упаковка boxing, int упакаютеся в тип object
            int intID = (int)acc1.Id;//обратный процесс распокавка unboxing

            string intID = (string)acc1.Id;//выдаст ошибку изза нессотвтествия типов

            acc2.Id = "55";// происходит упаковка boxing, int упакаютеся в тип object
            string str = (string)acc2.Id;//обратный процесс распокавка unboxing

            Console.WriteLine(str + intID);
            Console.Read();


------------------------------------------
generics
 //чтобы решить проблему упаковки распкаовки и проблему безопасноти типов исопльзу.тся обощения
    class Account<T>//это универсальный парметр всемто него можно пердать любой тип
    {
        public T Id { get; set; }
        public int Sum { get; set; }
    }
    class Program
    {
        static void Main(string[] args)
        {
            //после создания обьектов не происходит не упаковки не распкаовки
            Account<int> acc1 = new Account<int>();//тк класс теперь обобщенный нужно прри создани экземпляра 
            //указать какой типа экземпляр будет исопльзовать
            Account<string> acc2 = new Account<string>();//тк класс теперь обобщенный нужно прри создани экземпляра
            //указать какой типа экземпляр будет исопльзовать

            acc1.Id = 11;
            Console.WriteLine(acc1.Id);
            Console.Read();
        }
    }
------------------------------------------
так же можно использовать класс с несоклькими генериками и генерик с включенным в него классом с генериком

class Instantiator<U,V>
    {
        public U FromInstance { get; set; }
        public U ToInstance { get; set; }
        public V Code { get; set; }

    }
    class Account<T>
    {
        public T Id { get; set; }
        public int Sum { get; set; }
    }

class Program
    {
        static void Main(string[] args)
        {
            Account<int> acc1  = new Account<int>();
            //присваиваем значения для будущего их использования в генерике Instantiator<Account<int>,...
            acc1.Id = 10;
            acc1.Sum = 20;
            Account<int> acc2 = new Account<int>();
            //присваиваем значения для будущего их испольхования в генерике Instantiator<Account<int>,...
            acc2.Id = 30;
            acc2.Sum = 60;
            Account<string> acc3 = new Account<string>();

            Instantiator<Account<int>,string> i = new Instantiator<Account<int>, string>//кладев в обьект i наш класс 
            //Action с генериком int, а вторым генриком кладем простую строку
            {
                FromInstance = acc1,//кладем сюда экземпляр Acction<int>acc1 с вложеиями ввиде acc1.Id = 10 и
                // acc1.Sum = 20
                ToInstance = acc2,//кладем сюда экземпляр Acction<int>acc2 с вложеиями ввиде acc1.Id = 30 и
                // acc1.Sum = 60
                Code = "2520"//кладем сюда строку
            };

Console.WriteLine($"{i.FromInstance.Id} {i.FromInstance.Sum} {i.ToInstance.Id} {i.ToInstance.Sum} { i.Code}");

            Instantiator<int, string> j = new Instantiator<int, string>//здесь просто тандартный рпимер с двумя 
            //генериками ввиде инт и стринг
            {
                FromInstance = 20,
                ToInstance = 10,
                Code = "2010"
            };


------------------------------------------
Мы не можем использовать конструктор для создания объекта типа T. Если нам нужно создать значение по умолчанию,
 то для этого необходимо использовать оператор default
 
 class Instantiator<T>
    {
        public T instance;
        public Instantiator()
        {
            instance = default(T);//здесь используется дефаулт
        }
    }

        static void Main(string[] args)
        {
            Instantiator<int> i = new Instantiator<int> {instance = 10};
            Console.WriteLine(i.instance);
        }

------------------------------------------ 
так же можно использовать геенрик методы 

            int x = 10;
            int y = 30;
            Swap(ref x, ref y);//ref используется чтобы наш метод поменял значение непосрдсвтенно в перменны а,
            // не только внутри себя 

            //int x = 30; после работы метода в перменных выше будет так
            //int y = 10; после работы метода в перменных выше будет так

            string xx = "x";
            string yy = "y";
            Swap(ref xx, ref yy);
             // string xx = "y"; после работы метода в перменных выше будет так
            // string xx = "x"; после работы метода в перменных выше будет так

            void Swap<T>(ref T x, ref T y)
            {
                T temp = x;
                x = y;
                y = temp;
                Console.WriteLine($"x = {x},y = {y}");
            }

==========================================



--generic where ограничения обощений--
------------------------------------------
С помощью универсальных параметров мы можем типизировать обобщенные классы любым типом. 
Однако иногда возникает необходимость оргриничить генерик определенным типом и его наследниками.

делается это все потому что в этом случае будет идти преобразование типов. 
Параметризация generic <T> where : class позволяет избежать преобразований типов

В качестве ограничений мы можем использовать следующие типы:

Классы

Интерфейсы

class - универсальный параметр должен представлять класс

struct - универсальный параметр должен представлять структуру при этом использовать в качестве ограничения конкретные 
структуры в отличие от классов нельзя.

new() - универсальный параметр должен представлять тип, который имеет общедоступный (public) конструктор без параметров

------------------------------------------
class Account
{
    public int Id { get; private set; } // номер счета
    public int Sum { get; set; }

    public Account(int _id)
    {
        Id = _id;
    }
}

class Persone : Account
{
    public string Name { get; set; }
    public Persone(int id, string name): base(id)
    {
        Name = name;
    }
}

Следует учитывать, что только один класс может использоваться в качестве ограничения
Параметризация generic <T> where : class позволяет избежать преобразований типов

class Transaction<T> where T : Account// с помощью выражения where T : Account мы указываем,
// что используемый тип T обязательно должен быть классом Account или его наследником
{
    // Благодаря подобному ограничению мы можем использовать внутри класса Transaction
    // все объекты типа T именно как объекты Account и соответственно обращаться к их свойствам и методам.
    public T FromAccount { get; set; } // с какого счета перевод
    public T ToAccount { get; set; } // на какой счет перевод
    public T NameAccount { get; set; }

    public int Sum { get; set; } // сумма перевода

    public void Execute()
    {
        if (FromAccount.Sum > Sum)
        {
            FromAccount.Sum -= Sum;
            ToAccount.Sum += Sum;
            Console.WriteLine($"Счет {FromAccount.Id}: {FromAccount.Sum}$ \nСчет {ToAccount.Id}: {ToAccount.Sum},");//
            //благодаря where в перменные можно записать поля и методы относящиеся к классу которым ограничен данный генерик

            //Console.WriteLine($"Name{NameAccount.Name}");//вызовет ошибку тк это поле из наследника класса Account
        }
        else
        {
            Console.WriteLine($"Недостаточно денег на счете {FromAccount.Id}");
        }
    }
}

 class DemandAcc : Account
    {
        public DemandAcc(int id) : base(id)
        {
            
        }
    }

class Program
{
    static void Main(string[] args)
    {

        Account acc1 = new Account(1) {Sum = 4500};
        Account acc2 = new Account(2) {Sum = 5000};


        DemandAcc acc3 = new DemandAcc(3){Sum = 10000};
        DemandAcc acc4 = new DemandAcc(4){Sum = 3000};

        Transaction<Account> transaction1 = new Transaction<Account>//использумем указанный в  where T : Account класс
        {
            FromAccount = acc1,  
            ToAccount = acc2,
            Sum = 300
        };
        transaction1.Execute();


        Transaction<DemandAcc> transaction2 = new Transaction<DemandAcc>//использумем наследника указанного 
        //в where T : Account класса Account
           {
               FromAccount = acc3,//если бы в классе Transaction мы вместо типа T FromAccount, использовали бы тип Account
               // FromAccount, в это сткрочке мы получили бы апкаст тк как acc3 чтобы присовится в перменную FromAccaunt 
               //которая в наешму слуаае является Account, те классом родителем, нам пришлоь бы произвести апкаст 
               //преобразовангие от производнолго к базовому классу

               ToAccount = acc4,//если бы в классе Transaction мы вместо типа T FromAccount, использовали бы тип Account
               // FromAccount, в это сткрочке мы получили бы апкаст тк как acc3 чтобы присовится в перменную FromAccaunt 
               //которая в наешму слуаае является Account, те классом родителем, нам пришлоь бы произвести апкаст 
               //преобразовангие от производнолго к базовому классу
               Sum = 6900
           };
           DemandAcc acc5 = (DemandAcc)transaction2.FromAccount;//и если бы мны захотели бы полчуить обрантно данный обьект в 
           //перепенную DemandAcc нам пришлось бы произсодить даункаст,но в случаее если бы мы использволи where T : Account 
           //этоыго бы делать не пришлось -> DemandAcc acc5 = transaction2.FromAccount;
             DemandAcc acc6 = (DemandAcc)transaction2.ToAccount;//и если бы мны захотели бы полчуить обрантно данный обьект в 
           //перепенную DemandAcc нам пришлось бы произсодить даункаст,но в случаее если бы мы использволи where T : Account 
           //этоыго бы делать не пришлось -> DemandAcc acc5 = transaction2.ToAccount;
        ransaction2.Execute();

        Console.ReadLine();
    }
}
}

------------------------------------------
В качестве ограничения также может выступать и обобщенный класс

class Account<T>//Класс Account же может быть типизирован абсолютно любым типом
   {
       public T Id { get; private set; } // номер счета
       public int Sum { get; set; }
       public Account(T _id)
       {
           Id = _id;
       }
   }
   class Transaction<T> where T : Account<int>//В данном случае класс Transaction типизирован классом Account<int>
       // класс Transaction может использовать только объекты класса Account<int> или его наследников
   {
       public T FromAccount { get; set; }  // с какого счета перевод
       public T ToAccount { get; set; }    // на какой счет перевод
       public int Sum { get; set; }        // сумма перевода

       public void Execute()
       {
           if (FromAccount.Sum > Sum)
           {
               FromAccount.Sum -= Sum;
               ToAccount.Sum += Sum;
               Console.WriteLine($"Счет {FromAccount.Id}: {FromAccount.Sum}$ \nСчет {ToAccount.Id}: {ToAccount.Sum}$");
           }
           else
           {
               Console.WriteLine($"Недостаточно денег на счете {FromAccount.Id}");
           }
       }
   }

   class Program
   {
       static void Main(string[] args)
       {
           Account<int> acc1 = new Account<int>(1857) { Sum = 4500 };
           Account<int> acc2 = new Account<int>(3453) { Sum = 5000 };

           Transaction<Account<int>> transaction1 = new Transaction<Account<int>>
           {
               FromAccount = acc1,
               ToAccount = acc2,
               Sum = 300
           };

            transaction1.Execute();

           Account<string> acc1 = new Account<string>("34") { Sum = 4500 };
           Account<string> acc2 = new Account<string>("45") { Sum = 5000 };
          
           //Transaction<Account<string>> transaction2 = new Transaction<Account<string>>// так нельзя написать, 
           //так как Bank должен быть типизирован классом Account<int> или его наследником
           {
              FromAccount = acc1,
               ToAccount = acc2,
               Sum = 900
           };

           Console.Read();
       }
   }

------------------------------------------
Есть ряд стандартных ограничений, которые мы можем использовать. можно задать в качестве ограничения ссылочные типы:
частности, можно указать ограничение, чтобы использовались только структуры или другие типы значений 

------------------------------------------
ограничение структуой

 class Transaction<T>  where T : struct
{
    public T FromAccount { get; set; } // с какого счета перевод
    public T ToAccount { get; set; } // на какой счет перевод
}


 Transaction<int> transaction3 = new Transaction<int>//тк int предстявляет обой сткрутктуру
            //мы можем сделать так
            {
                //соответвенно теперь нужно предостаивть FromAccount и ToAccount числовые значения
                FromAccount = 123,
                ToAccount = 321,  
            };

НО при этом использовать в качестве ограничения конкретные те (имена структур) структуры в отличие от классов нельзя!

------------------------------------------
ограничение классом

class Transaction<T> where T : class
{}

------------------------------------------
ограничение new()

А также можно задать с помощью слова new в качестве ограничения класс или структуру, которые имеют общедоступный 
конструктор без параметров

class Transaction<T> where T : new()//это значит что ограничивающеи генерик 
//тип дожен поределять констуктор по умолчанию без парметров 
{
    ...
}
class Account//такой обьект впишется в ограничение генерика сверху
    {
        public int Id { get;  set; } 
        public int Sum { get; set; }
        public Account(int _id)
        {
            Id = _id;
        }
        public Account()//для этого нужно просто опеределить вот такой констурктор по умолчанию
        {
            
        }
    }

------------------------------------------
Если для универсального параметра задано несколько ограничений, то они должны идти в определенном порядке
1 Название класса, class, struct. Причем мы можем одновременно определить только одно из этих ограничений. 

2Название интерфейса.

3 new()

interface IAccount
{
    int CurrentSum { get; set;}
}
class Person
{
    public string Name { get; set; }
}
 
class Transaction<T> where T: Person, IAccount, new()//1 Название класса, class, struct
//2Название интерфейса
//3 new()
{
 ...
}

------------------------------------------
Использование нескольких универсальных параметров

class Transaction<U, V>
        where U : Account<int>//Если класс использует несколько универсальных параметров,
        // то последовательно можно задать ограничения к каждому из них
        where V : struct//Если класс использует несколько универсальных параметров, 
        //то последовательно можно задать ограничения к каждому из них

------------------------------------------
Ограничения методов

Подобным образом можно использовать и ограничения методов

private static void Main(string[] args)
{
    Account<int> acc1 = new Account<int>(1857) { Sum = 4500 };
    Account<int> acc2 = new Account<int>(3453) { Sum = 5000 };
 
    Transact<Account<int>>(acc1, acc2, 900);
 
    Console.Read();
}
 
public static void Transact<T>(T acc1, T acc2, int sum) where T : Account<int>//Метод Transact в качестве ограничения
// принимает тип Account<int>.
    if (acc1.Sum > sum)
    {
        acc1.Sum -= sum;
        acc2.Sum += sum;
    }
    Console.WriteLine($"acc1: {acc1.Sum}   acc2: {acc2.Sum}");
}
==========================================


--generic наследование--
------------------------------------------
Один обобщенный класс может быть унаследован от другого обобщенного. При этом можно использовать различные 
варианты наследования.

class Account<T>//Допустим, у нас есть следующий базовый обощенный класс Account
    {
        public T Id { get; private set; }
        public Account(T _id)
        {
            
            Id = _id;
        }
    }
    
    
    class UniversalAccount<T> : Account<T>//создание класса-наследника,
        //который типизирован тем же типом, что и базовый
    {
        private T ss;
        
    public UniversalAccount(T id) : base(id)
        {
             
        }
    }

    class StringAccount : Account<string>//в случае создание обычного
        //необобщенного класса-наследника у базового класса надо явным
        //образом определить используемый тип
    {
        public StringAccount(string id) : base(id)
        {
        }
    }

    class IntAccount<T> : Account<int>//Третий вариант представляет типизацию
        //производного класса параметром совсем другого типа, отличного от
        //универсального параметра в базовом классе. В этом случае для
        //базового класса также надо указать используемый тип:
    {
        public T Code { get; set; }
        public IntAccount(int id) : base(id)
        {
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Account<string> acc1 = new Account<string>("34");//реализация базвого класса 
            Account<int> acc3 = new UniversalAccount<int>(45);//апкаст класса наследника
            UniversalAccount<int> acc2 = new UniversalAccount<int>(33);//реализщация
            //класса наследника типизированого тем же типмо что и рожител
            Console.WriteLine(acc1.Id);
            Console.WriteLine(acc2.Id);
            Console.WriteLine(acc3.Id);
            
            //Теперь в производном классе в качестве типа будет использоваться тип string
            StringAccount acc4 = new StringAccount("43876");//реалищзация наследника 
            //без обощения тк оно уже опредено на этапео создания этого класа
            Account<string> acc5 = new StringAccount("43875");//при апкасте следует
            //у класса родителя указывать испольлзуемый тип
            Console.WriteLine(acc4.Id);
            Console.WriteLine(acc5.Id);
            
            IntAccount<string> acc7 = new IntAccount<string>(5) { Code = "r4556" };//реалищзация 
            //наследникаc с отличным от родителя генериком
            //тип в родительнсом классе  может не совпадать с типом, который
            // используется базовым классом
            
            Account<int> acc8 = new IntAccount<long>(7) { Code = 4587 };//при апкасте
            // тип в родительнсом классе  может не совпадать с типом, который
            // используется базовым классом
            Console.WriteLine(acc7.Id + " " + acc7.Code);
            Console.WriteLine(acc8.Id);
              
        }
    }
==========================================



--Исключения(Exception)--
------------------------------------------
 вначале выполняются все инструкции в блоке try если в этом блоке не возникло исключений, 
 то после его выполнения начинает выполняться блок finally

 Если же в блоке try возникает исключение, порядок выполнения останавливается,
 и среда CLR начинает искать блок catch, который может обработать данное исключение. 
 Если нужный блок catch найден, то он выполняется, и после его завершения выполняется блок finally.

 try
{
     
}
catch
{
     
}
finally//выполнится в любом члуче елси возникет исключение или если не возникнет
//При наличии блока catch мы можем опустить блок finally
{
     
}

InnerException: хранит информацию об исключении, которое послужило причиной текущего исключения

Message: хранит сообщение об исключении, текст ошибки

Source: хранит имя объекта или сборки, которое вызвало исключение

StackTrace: возвращает строковое представление стека вызывов, которые привели к возникновению исключения

TargetSite: возвращает метод, в котором и было вызвано исключение

------------------------------------------
типы исключений

Exception общий или стандартный тип исключений

            catch (Exception e)
            {
                 Console.WriteLine(ex.Message);//Message: хранит сообщение об исключении, текст ошибки
                 //в этом члучае на консоль будет выведено сообщение исключения
            }
остальные типы сиключений исплюзуются когода мы хотим обработтаь только лишь сиключение этого типа 
можно использзовать несоклькок блоков catch чтобы обработать несоклько разных исключений и чтобы 
обработатть их по разному 


IndexOutOfRangeException возмникает при присовению по индексу вне границ массива

            catch (IndexOutOfRangeException ex)
            {
                Console.WriteLine(ex.Message);
            }

DivideByZeroException возмникает при попытке деления на 0 
            catch (DivideByZeroException ex)
            {
                Console.WriteLine(ex.Message);
            }

НО если мы получим какоето иное от этих исключений исключение программа арварийно завершится 
для этого следует в коенце записать стандартный тип исключений;

НО если мы испобьзуем стандратныый тип исключений в купе с нестандартными типами нам необходим помещать 
стандартный в самый конец иначе он будет брать на себя обработку специализированых типа DivideByZeroException
и смысла в них тогда не будет

            catch (Exception e)
            {
                 Console.WriteLine(ex.Message);//в эом члучае на консоль будет выведено сообщение исключения
            }
------------------------------------------
собтвенные исключения 

  try
            {
                Console.WriteLine("write string");
                var mes = Console.ReadLine();

                if (mes.Length > 6)//определим условие для нашего и исключения тру попытается выполнить уловие в ифе
                //если выолпнит выоброится наше ичключение
                {
                    throw new Exception("длина строки больше 6 символов"); //этот оператор используется для
                     //генерации созданного нами исключения,после этого оператора указывается обьект 
                     //исключения например new Exception("сюда можно записать собобщение которое будет 
                     //показываатся при исключении");а посколькку здесь указано исключение типа Exception 
                     //то обрабатываться оно будет в соотвтетвующем блоке catch
                }

                //в случае выпадения исключения дльнейший код НЕ выполняется
                Console.WriteLine("End of try block");
            }

            catch (DivideByZeroException e)
            {
                Console.WriteLine(e);
            }
            catch (Exception e
            ) //обрабатыватся это исключение (throw new Exception("длина строки больше 6 символов")) будет здесь
            {
                Console.WriteLine($"Ошибка строки: {e.Message}"); // Ошибка строки: длина строки больше 6 символов
            }

            finally
            {
                Console.WriteLine("Finally block");
            }
            Console.ReadLine();
------------------------------------------
собтвенные исключения класс

 class MyExtention : Exception//так же можно создавать собтвенные
        //КЛАССЫ наследованые от исключения Exception или можно 
        //взять какой-нибудь другой производный тип нпмриер  или ArgumentException

    {
        public MyExtention(string mes) : base(mes)//По сути класс кроме пустого конструктора ничего не имеет,
        // и то в конструкторе мы просто обращаемся к конструктору базового класса Exception, 
        //передавая в него строку message
        {
            
        }
    }

 static void Main(string[] args)
        {

            try
            {
                
                if (mes.Length < 4)//определим условие для нашего и исключения тру попытается выполнить уловие в ифе
                //если выолпнит выбросится наше икслючение кторое мы записали ниже
                {
                    throw new MyExtention("длина строки меньше 4 символов");//этот оператор используется для 
                    //генерации исключения, после этого оператора указывается обьект исключения в данном 
                    //случае это наш собственный класс текст из скобок подставиться в Extention.Message 
                    //при выбрасывании исключения
                }

                //в случае выпадения исключения дльнейший код НЕ выполняется
                 Console.WriteLine("End of try block");

            }
            catch (MyExtention myExtention)//в случае если мы определим наш класс отдельным исключением при вызове 
            //нешго исключения сработает ьело данного кетча если же ммы не определим наш класс сработает 
            //стандарный Exception если он есть 
            {
                Console.WriteLine($"Ошибка: {myExtention.Message} (собственный класс)");//Ошибка: 
                //длина строки меньше 4 символов (собственный класс)

            }

            catch (Exception e)//если мы не определим собственное исключение как сделано выше сработает 
            //стандарный Exception если он есть 
            {
                Console.WriteLine($"Ошибка строки: {e.Message}"); // Ошибка строки: длина строки меньше 4 символов
            }
------------------------------------------
собственные исключения класс допольнительные свойства 

class PersonException : Exception
   {
       //доавляем поля для допольнительной информации о нашем исключеннии
       public int Value { get; } 
       public string Name { get; }
       public PersonException(string message, int val, string name)
           : base(message)//также мы можнм определять в конутркторе
       //нашего исключения дополнительные свойства val и name
       {
           Value = val;
           Name = name;
       }
   }

class Person
    {
        public string Name { get; set; }
        private int age;
        public int Age
        {
            get { return age; }
            set
            {
                if (value < 18)
                    throw new PersonException(
                        "Лицам до 18 регистрация запрещена", value, Name);//добавляем наши
                //довольнительнгые свойства для вывода при выбросе исключения 
                else
                    age = value;
            }
        }
    }

 static void Main(string[] args)
        {

            try
            {
                Person p = new Person { Name = "Tom", Age = 13 };
            }
            catch (PersonException ex)
            {
                Console.WriteLine($"Ошибка: {ex.Message}");//Лицам до 18 регистрация запрещена

                //при выброске наешго исключения помимо сообщения из свойства Message мы получим и наши дпольнительные свойства
                Console.WriteLine($"Некорректное значение: {ex.Value}");//Некорректное значение: 13
                Console.WriteLine($"Имя субъекта: {ex.Name}");// Имя субъекта: Tom
            }
        }   
------------------------------------------
Поиск блока catch при обработке исключений

 данном случае стек вызовов выглядит следующим образом: метод Main вызывает метод Method1, который, 
 в свою очередь, вызывает метод Method2. И в методе Method2 генерируется исключение 
 DivideByZeroException. 

    class TestClass
    {
        public static void Method1()
        {
            try
            {
2               Method2();//2. тот вызывает метод Method2
            }
5           //5. Система также ищет в этой конструкции блок catch, который обрабатывает
            //исключение DivideByZeroException. Однако здесь также подобный блок catch отсутствует.

            //catch (DivideByZeroException ex) // Однако такого блока catch так же нет
            //{
            //}
            catch (IndexOutOfRangeException ex)
            {
                Console.WriteLine($"Catch в Method1 : {ex.Message}");
            }
10           finally//10. Далее система возвращается по стеку вызовов вниз в метод Method1
                   //и выполняет в нем блок finally
            {
                Console.WriteLine("Блок finally в Method1");
            }
            Console.WriteLine("Конец метода Method1");
        }
        static void Method2()
        {
            //Система видит, что код, который вызывал исключение, помещен в конструкцию try..catch
            try
            {
                int x = 8;
3               int y = x / 0; //3. в метод Method2 генерируется исключение DivideByZeroException

4               
            }
            //4. Система ищет в этой конструкции блок catch, который обрабатывает исключение
            //DivideByZeroException. Однако такого блока catch нет.

            //catch(DivideByZeroException ex)// Однако такого блока catch нет
            //{
            //}

9           finally//9. Система поднимается обратно по стеку вызовов в самый верх в метод Method2
                   //и выполняет в нем блок finally
            {
                Console.WriteLine("Блок finally в Method2");
            }
            Console.WriteLine("Конец метода Method2");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            try
            {
1               TestClass.Method1();//1. Метод Main вызывает метод Method1
            }
6           //6. Система далее опускается в стеке вызовов в метод Main, который вызывал Method1.
            //Здесь вызов Method1 помещен в конструкцию try..catch

7           //7. Система снова ищет в этой конструкции блок
            //catch, который обрабатывает исключение DivideByZeroException. И в
            //данном случае ткой блок найден.

8           //8. Система наконец нашла нужный блок catch в методе Main, для обработки
            //исключения, которое возникло в методе Method2 - то есть к начальному методу,
            //где непосредственно возникло исключение. Но пока данный блок catch НЕ выполняется.

11          catch (DivideByZeroException ex) //11. Затем система переходит по стеку вызовов вниз в
                //метод Main и выполняет в нем найденный блок catch
            {
                Console.WriteLine($"Catch в Main : {ex.Message}");
            }
12          finally//12. и последующий блок finally
            {
                Console.WriteLine("Блок finally в Main");
            }
13          //13. Далее выполняется код, который идет в методе Main после конструкции try..catch
            Console.WriteLine("Конец метода Main");
            Console.Read();
        }
    }

------------------------------------------
try//внешний блок тру
{
    try//внутренний блолк тру
    {
        Console.Write("Введите строку: ");
        string message = Console.ReadLine();
        if (message.Length > 6)
        {
            throw new Exception("Длина строки больше 6 символов");//В данном случае при вводе 
            //строки с длиной больше 6 символов возникнет исключение
        }
    }
    catch//внутренний блок кетч,сперва исключение обрабывтвается здесь 
    {
        Console.WriteLine("Возникло исключение");//выодится на консокл сообщение "Возникло исключение"
        throw;//если пристувутет этот оператор то иклюлчение передается дальше внешнему блоку кетч, 
        //если его нет то програма аварийно завершится так как исключению негде буде обратбатыватся
    }
}
catch (Exception ex)//внешний блолк кетч, сюда передатся исключение при отрабатвании оператора throw
{
    Console.WriteLine(ex.Message);
}
------------------------------------------
фильтры исключений

В этом случае обработка исключения в блоке catch производится только в том случае, если условие в выражении when 
истинно.
catch when(условие)
{    

}

например 

int x = 1;
int y = 0;
 
try
{
    int result = x / y;
}
catch(DivideByZeroException) when (y==0 && x == 0)// если y =! 0 и x != 0 то оно не будет обрабатывать
//исключение так как условие, указанное после оператора when возвращает false
//Поэтому CLR будет дальше искать соответствующие блоки catch далее и для обработки исключения выберет 
//второй блок catch. 
{
    Console.WriteLine("y не должен быть равен 0");
}
catch(DivideByZeroException ex) //вот этот блок будет выбран если условие первого не будет соблюдено
{
    Console.WriteLine(ex.Message);
}
------------------------------------------
условные конструкции

С точки зрения производительности использование блоков try..catch более накладно,
чем применение условных конструкций. Поэтому по возможности вместо try..catch лучше 
использовать условные конструкции на проверку исключительных ситуаций.

чаще всего гораздо оптимальнее было бы проверить допустимость преобразования

 if (Int32.TryParse(input, out x))//птыается преобразовать строковое представление числа input
 //в эквивалентное 32-битовое знаковое целое число x, и возрващает его в тело условной контрукции,
 //если преобразование успешно, если преобзрахоавние не удалосчь прграмма идт дальше без 
 //выполнения тела условной констуркции
    {
        x *= x;
        Console.WriteLine("Квадрат числа: " + x);
    }
    else
    {
        Console.WriteLine("Некорректный ввод");
    }

------------------------------------------
циклический вызов try...catch просто применив рекурсию, обернув блок в функцию:

public int GetInput()
{
try
{
int input = Int32.Parse(Console.ReadLine());
return input;
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
return GetInput();
}
}

var gg = Num(Console.ReadLine());

static int Num(string num)
        {

            int ss = 20;
            var gg = int.Parse(num);

            try
            {
                ss = ss / gg;
            }
            catch (DivideByZeroException ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine("число не должно быть 0");
                return Num(Console.ReadLine());//нужно сделать возрващение
                // чтобы код не возрващал оригиальное значение ss
            }


            return ss;
        }

------------------------------------------
К слову сказать, лучше юзать throw ex только в самом начале стека вызова, а во всех последующих throw, 
так как throw ex резетит Stack Trace, и отследить начальную функцию, в которой было вызвано исключение
 уже намного сложнее.

==========================================



--Интерфейсы--
------------------------------------------
Интерфейс представляет ссылочный тип, который может определять некоторый функционал - 
набор методов и свойств без реализации

разница между интерфейсом и абстарктным классом в том что Абстрактный класс — это класс,
 у которого не реализован один или больше методов (некоторые языки требуют такие методы помечать специальными ключевыми словами).
Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.

Что может определять интерфейс? В целом интерфейсы могут определять следующие сущности:
Методы
Свойства
Индексаторы
События
Статические поля и константы (начиная с версии C# 8.0)

НО интерфейсы НЕ могут определять нестатические переменные!

Интерфейсы так же не могут иметь модификатор abstract.

интерфейсы по умолчанию имеют уровень доступа internal
с помощью модификатора public мы можем сделать интерфейс общедоступным:

public interface IMovable
{
    void Move();
}
по умолчанию все методы, свойства и перменные имеют модификатор доступа public 
так как цель интерфейса - определение функционала для реализации его классом.

При этом класс ДОЛЖЕН реализовать ВСЕ методы и свойства применяемых интерфейсов, 
ТОЛЬКО если эти методы и свойства НЕ ИМЕЮТ реализации по умолчанию.

Как и классы, интерфейсы по умолчанию имеют уровень доступа internal
если мы подключаем к классу интерфейс то необходимо реализовать все поля и методы интерфейса

  interface IFoo
    {
        void Execute();
    }
    interface IBar
    {
        void Execute();
    }
    class Tester : IFoo, IBar//вызовет ошибку тк  нужно реализовтаь метод Execute 
    //из интереффейса IBar
    {
        void IFoo.Execute()
        {
            Console.WriteLine("IFoo Executes");
        }
    }

Но также, начиная с версии C# 8.0, мы можем явно указывать модификаторы доступа у компонентов интерфейса:

interface IMovable
{
    public const int minSpeed = 0;     // минимальная скорость
    private static int maxSpeed = 60;   // максимальная скорость
    public void Move();
    protected internal string Name { get; set; }    // название
    public delegate void MoveHandler(string message);  // определение делегата для события
    public event MoveHandler MoveEvent;    // событие движения

------------------------------------------
Применение интерфейсов

В данной программе определен метод Action(), который в качестве параметра принимает объект интерфейса 
IMovable. На момент написания кода мы можем не знать, что это будет за объект -
какой-то класс или структура. Единственное, в чем мы можем быть уверены, 
что этот объект обязательно реализует метод Move и мы можем вызвать этот метод.

 interface IMovable
    {
        void SS();
    }
    class Person : IMovable//обьект интерфейса IMovable
    {
        public int I;
        public Person(int i)
        {
            I = i;
        }
        
        public void SS() //этот объект обязательно должен реализовать метод Move и мы можем вызвать этот метод.
        {
            
            if (I < 5)
            {
                Console.WriteLine("челове идет");
            }
            else
            {
                Console.WriteLine("челове плющися");
            }
        }
    }
    struct Car : IMovable//обьект интерфейса IMovable
    {
        public void SS() //этот объект обязательно должен реализовать метод Move и мы можем вызвать этот метод.
        {
            Console.WriteLine("Машина едет");
        }
    }
    class Program
    {
        static void Action(IMovable movable)//это метод в качестве параметра принимает объект интерфейса IMovable
                                            //мы можем не знать, что это будет за объект - какой-то класс или структура.
                                            //этот объект обязательно должен реализовать метод SS и мы можем вызвать этот метод.
        {
            movable.SS();//вызваем метод SS можем и не вызывать
        }
        static void Main(string[] args)
        {
            Person person = new Person(3);
            Car car = new Car();
            
            Action(car);// Move и мы можем вызвать этот метод вывод: Машина едет
            Console.Read();
        }
    }
   интерфейс это контракт, что какой-то определенный тип обязательно реализует некоторый функционал

------------------------------------------
реализация методов и свойств интерфейсов по умолчанию

Начиная с версии C# 8.0 интерфейсы поддерживают реализацию методов и свойств по умолчанию. 
Зачем это нужно? Допустим, у нас есть куча классов, которые реализуют некоторый интерфейс. 
Если мы добавим в этот интерфейс новый метод, то мы будем обязаны реализовать этот метод во всех классах,
применяющих данный интерфейс. Иначе подобные классы просто не будут компилироваться.
НО в 8.0 вместо реализации метода во всех классах нам достаточно определить его реализацию по умолчанию в интерфейсе.
Если класс НЕ РЕАЛИЗУЕТ метод, будет применяться реализация ПО УМОЛЧАНИЮ.

 class Program
    {
        static void Main(string[] args)
        {
            IMovable tom = new Person();//для объекта класса Person мы можем вызвать метод Move -
            //ведь класс Person применяет интерфейс IMovable
            tom.Move();     // Walking

            Car tesla = new Car();
            tesla.Move();   // Driving

            Person tom2 = new Person();
            tom2.Move();// Ошибка - метод Move не определен в классе Person
        }
    }

    interface IMovable
    {
        void Move()
        {
            Console.WriteLine("Walking");
        }
    }
    class Person : IMovable { }//используется реализация метода Move по муолманию те вывод на консоль Walking
    class Car : IMovable
    {
        public void Move()//перопределение метода вывод на консоль Driving
        {
            Console.WriteLine("Driving");
        }
    }
} 

С реализацией свойств по умолчанию в интерфейсах дело обстоит несколько сложнее, 
поскольку мы не можем определять в интерфейсах нестатические переменные, соответственно
 в свойствах интерфейса мы не можем манипулировать состоянием объекта. Тем не менее реализацию 
 по умолчанию для свойств мы тоже можем определять

 interface IMovable
{
    public const int minSpeed = 0;     // минимальная скорость

    //перменная с модифиаткором private
    private static int maxSpeed = 60;   // максимальная скорость
        // находим время, за которое надо пройти расстояние distance со скоростью speed

    static double GetTime(double distance, double speed) => distance / speed;
    static int MaxSpeed
    {
        get { return maxSpeed; }
        set
        {
            if (value > 0) maxSpeed = value;
        }
    }
}
Стоит отметить, что если интерфейс имеет приватные методы и свойства (то есть с модификатором private),
то они должны иметь реализацию по умолчанию. То же самое относится к любым статическим методам
и свойствам (не обязательно приватным)

 
------------------------------------------
Множественная реализация интерфейсов

к классу можно полдключать сразу несоклько интрефейсов

interface IFoo
{
    void Execute();
}
interface IBar
{
    void Execute();
}
class Tester : IFoo, IBar
{
    public void Execute()
    {
        Console.WriteLine("Tester Executes");
    }
}

или так 

 interface IAccount
    {
        int CurrentSum { get; } // CurrentSum похож на автосвойство, но это не автосвойство. 
        //При реализации мы можем развернуть его в полноценное свойство, либо же сделать автосвойством

        void Put(int sum); // Положить деньги на счет
        void Withdraw(int sum); // Взять со счета


    }

    interface IClient
    {
        string Name { get; set; }//Name похож на автосвойство, но это не автосвойство. 
        //При реализации мы можем развернуть его в полноценное свойство, либо же сделать автосвойством
    }

    class Client : IAccount, IClient
    {
        int _sum; // Переменная для хранения суммы
        public string Name { get; set; }

        public Client(string name, int sum)
        {
            Name = name;
            _sum = sum;
        }

        public int CurrentSum
        {
            get { return _sum; }
        }

        public void Put(int sum)
        {
            _sum += sum;
        }

        public void Withdraw(int sum)
        {
            if (_sum >= sum)
            {
                _sum -= sum;
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Client client = new Client("Tom", 200);
            client.Put(30);
            Console.WriteLine(client.CurrentSum); //230
            client.Withdraw(100);
            Console.WriteLine(client.CurrentSum); //130

//  Необходимо явно указать, реализацию какого интерфейса мы хотим использовать, например, 
 //с помощью операции приведения типов:

            // Все объекты Client являются объектами IAccount 
            IAccount account = new Client("Том", 200);
            account.Put(200);
            Console.WriteLine(account.CurrentSum); // 400
            // Не все объекты IAccount являются объектами Client, необходимо явное приведение
            Client client2 = (Client)account;
            // Интерфейс IAccount не имеет свойства Name, необходимо явное приведение
            string clientName = ((Client)account).Name;
            Console.Read();
        }
    }
еще один пример 

 interface IFoo
    {
        void Execute();
    }
    interface IBar
    {
        void Execute();
    }
    class Tester : IFoo, IBar
    {
        void IFoo.Execute()
        {
            Console.WriteLine("IFoo Executes");
        }
        void IBar.Execute()
        {
            Console.WriteLine("IBar Executes");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Tester t = new Tester();
            (t as IFoo).Execute();
        }
    }
}

------------------------------------------
Интерфейсы в преобразованиях типов (upcasting downcasting)

Преобразование от класса к его интерфейсу, как и преобразование от производного типа к
 базовому, выполняется автоматически. Так как любой объект Client реализует интерфейс IAccount.

Необходимо явно указать, реализацию какого интерфейса мы хотим использовать, например, 
 с помощью операции приведения типов:

            // Все объекты Client являются объектами IAccount 
            IAccount account = new Client("Том", 200);//Поскольку класс Client реализует интерфейс 
            //IAccount, то переменная типа IAccount может хранить ссылку на объект типа Client

            account.Put(200);

            Console.WriteLine(account.CurrentSum); // 400
            // Не все объекты IAccount являются объектами Client, необходимо явное приведение

            Client client2 = (Client)account;

            //И если мы хотим обратиться к методам класса Client, которые не определены в интерфейсе IAccount, 
            //но являются частью класса Client, 
            // Интерфейс IAccount не имеет свойства Name, необходимо явное приведение

            string clientName = ((Client)account).Name;
            Console.Read();

Необходимо явно указать, реализацию какого интерфейса мы хотим использовать, например, с помощью операции приведения типов:

 interface IFoo
        {
            void Execute();
        }
        interface IBar
        {
            void Execute();
        }
        class Tester : IFoo, IBar //Класс Tester реализует интерфейсы IFoo и IBar:
        {
            void IFoo.Execute()//При явной реализации указывается название метода или свойства вместе с названием интерфейса,
 //при этом мы не можем использовать модификатор public, то есть методы являются закрытыми
            {
                Console.WriteLine("IFoo Executes");
            }

            void IBar.Execute()//При явной реализации указывается название метода или свойства вместе с названием интерфейса,
 //при этом мы не можем использовать модификатор public, то есть методы являются закрытыми
            {
                Console.WriteLine("IFoo Executes");
            }

        }
        class Program
        {
            static void Main(string[] args)
            {
                Tester t = new Tester();

                //придетс иполовать даункастинг чтобы вытащить метод Execute

                //или так
                if (t is IFoo e)
                {
                    e.Execute();
                }

                //или так
                (t as IFoo).Execute();
            }
        }   

------------------------------------------
пример интерфейса

Данный интерфейс содержит различные компоненты, которые описывают возможности движущегося объекта.
То есть интерфейс описывает некоторый функционал, который должен быть у движущегося объекта.


interface IMovable
{
    // константа
    const int minSpeed = 0;     // минимальная скорость
    // статическая переменная
    static int maxSpeed = 60;   // максимальная скорость
    // метод
    void Move();                // движение
    // свойство
    string Name { get; set; }   // название
     
    delegate void MoveHandler(string message);  // определение делегата для события
    // событие
    event MoveHandler MoveEvent;    // событие движения
}

Методы и свойства интерфейса могут не иметь реализации, в этом они сближаются с абстрактными 
методами и свойствами абстрактных классов. В данном случае интерфейс определяет метод Move, 
который будет представлять некоторое передвижение. Он не имеет реализации, не принимает никаких 
параметров и ничего не возвращает.

И, собственно, мы не можем создавать объекты интерфейса напрямую с помощью конструктора,
 как например, в классах

IMovable m = new IMovable(); // ! Ошибка, так сделать нельзя

Но также, начиная с версии C# 8.0, мы можем явно указывать модификаторы доступа у
 компонентов интерфейса:
interface IMovable
{
    public const int minSpeed = 0;     // минимальная скорость
    private static int maxSpeed = 60;   // максимальная скорость
    protected internal void Move();
    ...


==========================================



--Явная реализация интерфейсов--
------------------------------------------
При явной реализации указывается название метода или свойства вместе с названием интерфейса,
 при этом мы не можем использовать модификатор public, то есть методы являются закрытыми

interface IAction
{
    void Move();
}
class BaseAction : IAction
{
    void IAction.Move()
    {
        Console.WriteLine("Move in Base Class");
    }
}

Следует учитывать, что при явной реализации интерфейса его методы и свойства не являются 
частью интерфейса класса. Поэтому напрямую через объект класса мы к ним обратиться не сможем

interface IAction
{
    void Move();
}
class BaseAction : IAction
{
    void IAction.Move()
    {
        Console.WriteLine("Move in Base Class");
    }
}

static void Main(string[] args)
{
    BaseAction action = new BaseAction();
    ((IAction)action).Move();   // необходимо приведение к типу IAction
 
    // или так
    IAction action2 = new BaseAction();
    action2.Move();
     
    Console.ReadKey();
}
------------------------------------------
почему исопльзуется явная реализация 

В какой ситуации может действительно понадобиться явная реализация интерфейса? 
Например, когда класс применяет несколько интерфейсов, но они имеют один и тот же метод 
с одним и тем же возвращаемым результатом и одним и тем же набором параметров:


 interface ISchool
    {
        void Study() //одинавковые имена 
        {
            Console.WriteLine("School Learning");
        }
    }

    interface IUniversity
    {
        void Study() //одинавковые имена
        {
            Console.WriteLine("University Learning");
        }
    }

 class Person : ISchool, IUniversity
    {
        public void Study() //Класс Person определяет один метод Study(),
            //создавая одну общую реализацию для обоих примененных интерфейсов.

            //И вне зависимости от того, будем ли мы рассматривать объект Person
            //как объект типа ISchool или IUniversity, результат метода будет один и тот же.
        {
            Console.WriteLine("Учеба в школе или в университете"); //сейчас класс
            //Person реализует методы обоих интерфейсов одинково, тк как их имена совпадают, чтобы этого избежать
            //и производится разграничение 
        }

        
            void ISchool.Study()//Чтобы разграничить реализуемые интерфейсы, надо явным образом применить интерфейс
        {
                Console.WriteLine("Учеба в школе");//теперь в каждом из реализумеых методов будет разный результат
            }

            void IUniversity.Study()//Чтобы разграничить реализуемые интерфейсы, надо явным образом применить интерфейс
        {
                Console.WriteLine("Учеба в университете");//теперь в каждом из реализумеых методов будет разный результат
        }
        

    }

   
    class Program
    {
        static void Main(string[] args)
        {
            Person p = new Person();

            p.Study();
            Console.Read();

            Person per = new Person();

            ((ISchool)per).Study();//но в таком случае необходим будет использовать даункаст
            //тк эти методы больше не являются частью интерфейса наследуемого класса Person
            ((IUniversity)per).Study();//но в таком случае необходим будет использовать даункаст
            //тк эти методы больше не являются частью интерфейса наследуемого класса Person
            Console.Read();
        }
------------------------------------------
 явная реализация в случае реализации инерфейса в классе родителе

Другая ситуация, когда в базовом классе уже реализован интерфейс,
но необходимо в производном классе по-своему реализовать интерфейс

interface IAction
{
    void Move();
}
class BaseAction : IAction
{
    public void Move()//чтобы не получить результат мтоеда интерфейса из класса родителя...
    {
        Console.WriteLine("Move in BaseAction");
    }
}
class HeroAction : BaseAction, IAction
{
    void IAction.Move()// ...необходимо явно реализовать 
        //метод интерефейса в классе потомке
    {
        Console.WriteLine("Move in HeroAction");
    }
}
static void Main(string[] args)
        {
            HeroAction action1 = new HeroAction();
            action1.Move();// Move in BaseAction//этот метод идет от класса родителя
            // тк в нем он все еще является публичным

            ((IAction)action1).Move(); // Move in HeroAction//а вот этот метод уже идет от потомка
            // с даункастом к интерфейсу

            IAction action2 = new HeroAction();//а здесь от родительсокго интерфейса апкаст к
            //классу потомку HeroAction
            action2.Move();// Move in HeroAction

            Console.Read();

------------------------------------------
явная реализация в случае модификторов доступа не public

Члены интерфейса могут иметь разные модификаторы доступа. Если модификатор доступа не public, 
а какой-то другой, то для реализации метода, свойства или события интерфейса в классах и
 структурах также необходимо использовать явную реализацию интерфейса

 interface IMovable
{
    protected internal void Move();
    protected internal string Name { get; set; }
    delegate void MoveHandler();
    protected internal event MoveHandler MoveEvent;
}
class Person : IMovable
{
    // явная реализация свойства - в виде автосвойства
    string IMovable.Name { get; set; }//явное потому что не паблик
 
    // явная реализация события - дополнительно создается переменная
    IMovable.MoveHandler _moveEvent;//в случае делегат тк это указатели на методы и с помощью делегатов
     //мы можем вызвать данные методы, то нам необходимо указать что этот делегат ринадлежит к интерфейсу 
    //иначе программа решит что мы создали новый делегат, а если мыф не убдем его создавать то программа 
    //заругается на отутвие реализации делегает из интрефейса

    event IMovable.MoveHandler IMovable.MoveEvent//явное потому что не паблик
    {
        add => _moveEvent += value;
        remove => _moveEvent -= value;
    }
 
    // явная реализация метода потому что не паблик
    void IMovable.Move()
    {
        Console.WriteLine("Person is walking"); 
        _moveEvent();
    }
}
class Program
{
    static void Main(string[] args)
    {
        IMovable mov = new Person();
        // подписываемся на событие
        mov.MoveEvent += () => Console.WriteLine("IMovable is moving");
        mov.Move();
    }
}       
==========================================


--Интерфейсы и наследование
------------------------------------------
Если класс применяет интерфейс, то этот класс должен реализовать все методы и свойства интерфейса, 
которые не имеют реализации по умолчанию. Однако также можно и не реализовать методы, 
сделав их абстрактными, переложив право их реализации на производные классы

interface IMovable
    {
        void Move();
    }
    abstract class Person : IMovable
    {
        public abstract void Move();//сделав метод асбтсрактным мы переносим его
        //реализацию в класс потомок
    }
    class Driver : Person
    {
        public override void Move()//сдесь мы и реализуем этот класс
        {
            Console.WriteLine("Шофер ведет машину");
        }
    }

     static void Main(string[] args)
        {
            Driver p = new Driver();

            p.Move();//Шофер ведет машину
        }

------------------------------------------
поведление метододв и свойств интерфейса без реализации их в классе наследнике, но с рализацией в 
родительском.
При реализации интерфейса учитываются также методы и свойства, унаследованные от базового класса

interface IAction
    {
        void Move();
    }
    class BaseAction
    {
        public void Move()//в случае если в классе потомке HeroAction метод Move не будет определен, 
        //тогда будет исопльзоватся эта реализация
        {
            Console.WriteLine("Move in BaseAction");
        }
    }
    class HeroAction : BaseAction, IAction//название базового класса ВСЕГДА должно быть указано до 
    //реализуемых интерфейсов
    {
        //Move может быть не определен,но тогда используется реализация из класса родителя
    }

static void Main(string[] args)
        {
            BaseAction ba = new BaseAction();
            ba.Move(); //Move in BaseAction
             HeroAction ha = new HeroAction();
            ha.Move(); //Move in BaseAction
        }
Здесь класс HeroAction реализует интерфейс IAction, однако для реализации метода Move из интерфейса 
применяется метод Move, унаследованный от базового класса BaseAction. Таким образом, 
класс HeroAction может не реализовать метод Move, так как этот метод уже определен в базовом классе BaseAction;        
------------------------------------------
Изменение реализации интерфейсов в производных классах

Может сложиться ситуация, что базовый класс реализовал интерфейс, но в классе-наследнике
необходимо изменить реализацию этого интерфейса. 

 --1 вариант  переопределение виртуальных/абстрактных методов

  interface IAction
    {
        void Move();
    }
    class BaseAction : IAction
    {
        public virtual void Move()//В базовом классе BaseAction реализованный метод интерфейса определен как виртуальный
                                  //(можно было бы также сделать его абстрактным)
        {
            Console.WriteLine("Move in BaseAction");
        }
    }
    class HeroAction : BaseAction//наследуем только от BaseAction
    {
        public override void Move()//а в производном классе мы его переопределяем.
        {
            Console.WriteLine("Move in HeroAction");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            BaseAction action = new BaseAction();
            action.Move();//Move in BaseAction
            BaseAction action1 = new HeroAction();
            action1.Move();// Move in HeroAction

            IAction action2 = new HeroAction();//При вызове метода через переменную интерфейса, если она ссылается
            //на объект производного класса, будет использоваться реализация из производного класса
            action2.Move(); // Move in HeroAction
            IAction action3 = new BaseAction();//При вызове метода через переменную интерфейса, если она ссылается
            //на объект производного класса, будет использоваться реализация из производного класса
            action3.Move();//Move in BaseAction
        }
    }

--2 вариант - сокрытие метода в производном классе

Так как интерфейс реализован именно в классе BaseAction, то через переменную action2 можно обратиться 
только к реализации метода Move из базового класса BaseAction.

interface IAction
{
    void Move();
}
class BaseAction : IAction
{
    public void Move()//реализуем метод из интерфейса 
    {
        Console.WriteLine("Move in BaseAction");
    }
}
class HeroAction : BaseAction//наследуем только от BaseAction
{
    public new void Move()// сокрытием метода в производном классе мы переопредлделяем метод из базовго класса
    {
        Console.WriteLine("Move in HeroAction");
    }
}

BaseAction action1 = new HeroAction();
action1.Move();            // Move in BaseAction
 
IAction action2 = new HeroAction();
action2.Move();             // Move in BaseAction

--3 варинат повторная реализация интерфейса в классе-наследнике

interface IAction
    {
        void Move();
    }
    class BaseAction : IAction
    {
        public void Move()
        {
            Console.WriteLine("Move in BaseAction");
        }
    }
    class HeroAction : BaseAction, IAction//повторная реализуем интерфейс в классе-наследнике, 
//и за одно наследуемся от класса родителя
    {
        public new void Move()//еще один метод с таким же названием не взяаный с пердыдущим,
            //используется для разрешения конфликат имен без использования преопределения
        {
            Console.WriteLine("Move in HeroAction");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            BaseAction action1 = new HeroAction();//Если вы работаете с экземпляром класса-наследника 
            //HeroAction, через его родительский класс BaseAction...
            action1.Move(); //...то если исопльзовать тут перекрытый(new) метод, 
            //то будет вызван метод Move из базового класса BaseAction те - выведется Move in BaseAction          

            IAction action2 = new HeroAction();//При вызове метода Move через переменную интерфейса action2, 
            //если она ссылается на объект производного класса new HeroAction(), 
            //будет использоваться реализация из производного класса...
            action2.Move();             //...вот эта реализация - выведется Move in HeroAction

            HeroAction action3 = new HeroAction();
            action3.Move();             // Move in HeroAction
        }
    }
==========================================



--наследование интерфесйсов--
------------------------------------------
интерфейсы как и классы могут наследоваться

interface IAction
{
    void Move();
}
interface IRunAction : IAction
{
    void Run();
}
class BaseAction : IRunAction
{
    public void Move()
    {
        Console.WriteLine("Move");
    }
    public void Run()
    {
        Console.WriteLine("Run");
    }
}
Однако в отличие от классов мы не можем применять к интерфейсам модификатор sealed, чтобы запретить наследование 
интерфейсов.
Также мы не можем применять к интерфейсам модификатор abstract, поскольку интерфейс фактически итак, 
как правило, предоставляет абстрактный функционал, который должен быть реализован в классе или 
структуре (за исключением методов и свойств с реализацией по умолчанию).
------------------------------------------
сокрытия методов из базового интерфейса

Однако методы интерфейсов могут использовать ключевое слово new для сокрытия методов из базового интерфейса

interface IAction
{
    void Move();
}
interface IRunAction : IAction
{
    new void Move();//Здесь метод Move из IRunAction скрывает метод Move из базового интерфейса IAction
    // Большого смысла в этом нет, так как в данном случае нечего скрывать 
}

class RunAction : IRunAction
{
    public void Move()
    {
        Console.WriteLine("I am running");//А класс RunAction реализует метод Move сразу для обоих интерфейсов.
    }
}
------------------------------------------
При наследовании интерфейсов следует учитывать, что, как и при наследовании классов, 
производный интерфейс должен иметь тот же уровень доступа или более строгий, чем базовый интерфейс.

public interface IAction
{
    void Move();
}
internal interface IRunAction : IAction
{
    void Run();
}


в этом случап получим ошибку тк родтельский интерфейс имеет более строий уровень доступа чем интерфейс наследник

internal interface IAction
{
    void Move();
}
public interface IRunAction : IAction   // ошибка IRunAction может быть только internal
{
    void Run();
}
==========================================

--Интерфейсы в обобщениях--
------------------------------------------
Интерфейсы могут выступать в качестве ограничений обобщений. При этом если в качестве ограничения можно указаь 
только один класс, то интерфейсов можно указать несколько.

 interface IAccount
    {
        int CurrentSum { get; } // Текущая сумма на счету
        void Put(int sum);      // Положить деньги на счет
        void Withdraw(int sum); // Взять со счета
    }
    interface IClient
    {
        string Name { get; set; }
    }
    class Client : IAccount, IClient //здесь определен класс Client, который реализует оба интерфейса, 
    //таким образом мы можем им типизировать обьекты классов типизация которых  же интерфейсами

        int _sum; // Переменная для хранения суммы
        public Client(string name, int sum)
        {
            Name = name;
            _sum = sum;
        }

        public string Name { get; set; }
        public int CurrentSum
        {
            get { return _sum; }
        }
        public void Put(int sum)
        {
            _sum += sum;
        }
        public void Withdraw(int sum)
        {
            if (sum <= _sum)
            {
                _sum -= sum;
            }
        }
    }

    class Transaction<T> where T : IAccount, IClient//T представляет тип, который
    //который реализует сразу два интерфейса IAccount и IClient
    {
        public void Operate(T acc1, T acc2, int sum)
        {
            if (acc1.CurrentSum >= sum)
            {
                acc1.Withdraw(sum);
                acc2.Put(sum);
                Console.WriteLine($"{acc1.Name} : {acc1.CurrentSum}\n{acc2.Name} : {acc2.CurrentSum}");
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Client account1 = new Client("Tom", 200);
            Client account2 = new Client("Bob", 300);

            Transaction<Client> transaction = new Transaction<Client>();// Например,
            // выше определен класс Client, который реализует оба интерфейса,
            // поэтому мы можем данным типом типизировать объекты Transaction

            transaction.Operate(account1, account2, 150);
        }
    }

------------------------------------------
 interface IAccount
    {
        int CurrentSum { get; }
        void Put(int sum);
        void Withdraw(int sum);

        interface IClient
        {
            string Name { get; set; }
        }

        interface IClientAccount : IAccount, IClient //этот интерфейс
            //наследуется от обоих интерфейсов 
        {

        }

        class ClientAccount : IClientAccount
        {
            int _sum;

            public ClientAccount(string name, int sum)
            {
                _sum = sum;
                Name = name;
            }

            public int CurrentSum
            {
                get { return _sum; }
            }

            public string Name { get; set; }

            public void Put(int sum)
            {
                _sum += sum;
            }

            public void Withdraw(int sum)
            {
                if (_sum >= sum) _sum -= sum;
            }
        }

        class Transaction<T> where T : IAccount, IClient //Также параметр T может представлять
        //интерфейс, который наследуется от обоих интерфейсов
        {
            public void Operate(T acc1, T acc2, int sum)
            {
                if (acc1.CurrentSum >= sum)
                {
                    acc1.Withdraw(sum);
                    acc2.Put(sum);
                    Console.WriteLine($"{acc1.Name} : {acc1.CurrentSum}\n{acc2.Name} : {acc2.CurrentSum}");
                }
            }
        }

        class Program
        {
            static void Main(string[] args)
            {
                ClientAccount account3 = new ClientAccount("Alice", 400);
                ClientAccount account4 = new ClientAccount("Kate", 500);
                Transaction<IClientAccount> operation = new Transaction<IClientAccount>(); //В этом
                //случае объекты Transaction мы можем типизировать типом IClientAccount
                operation.Operate(account3, account4, 200);
            }
        }

------------------------------------------
Обобщенные интерфейсы

Как и классы, интерфейсы могут быть обобщенными

          interface IUser<T> //Интерфейс IUser типизирован параметром T, 
    {
        T Id { get; }
    }

    class User<T> : IUser<T> //памретр Т при реализации интерфейса используется в классе User
    {
        T _id; // переменная _id определена как T, что позволяет нам использовать

        // для id различные типы.
        public User(T id)
        {
            _id = id;
        }

        public T Id
        {
            get { return _id; }
        }
    }

    class IntUser : IUser<int> //Также при реализации интерфейса мы можем явным
        //образом указать, какой тип будет использоваться для параметра T
    {
        int _id;

        public IntUser(int id)
        {
            _id = id;
        }

        public int Id
        {
            get { return _id; }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            //Определим две реализации:
            IUser<int> user1 = new User<int>(6789); //одна в качестве параметра будет использовать тип int
            Console.WriteLine(user1.Id); // 6789

            IUser<string> user2 = new User<string>("12345"); //а другая - тип string
            Console.WriteLine(user2.Id); // 12345

            IntUser iu = new IntUser(200);
            Console.WriteLine(iu.Id);

            IUser<int> iui = new IntUser(500);
            Console.WriteLine(iui.Id);

        }
    }
==========================================



--Копирование объектов. Интерфейс ICloneable--
------------------------------------------
использование клонирвания

Чтобы переменная p2 указывала на новый объект, но со значениями из p1,
 мы можем применить клонирование с помощью реализации интерфейса ICloneable:

public interface ICloneable
{
    object Clone();
}

Поскольку классы представляют ссылочные типы, то это накладывает некоторые ограничения на их использование. В частности

        static void Main(string[] args)
        {
            Person p1 = new Person { Name = "Tom", Age = 23 };
            Person p2 = p1;//p2.Name = "Tom" В данном случае объекты p1 и p2 будут указывать на один и тот же объект в памяти,
                           //поэтому изменения свойств в переменной p2 затронут также и переменную p1.
            p2.Name = "Alice";//как толлько имя запишется по ссылке в оьект р2 оно запишется так же и в обьект р1 тк у них сейчас один адрес
            //чтобы этого избежать может исопльзоватся копирование оьектов ссылочного типа (с сохранением всех даннных первоначального обьекта)
            Console.WriteLine(p1.Name); // Alice
//неглубокое (поверхсностоне копировние)
            SurfacePerson p3 = new SurfacePerson { Name = "Tom", Age = 23, Work = new Company { Name = "Microsoft" } };
            SurfacePerson p4 = (SurfacePerson)p3.Clone();
            p4.Work.Name = "Google";
            p4.Name = "Alice";
            Console.WriteLine(p3.Name); //здес MemberwiseClone СРАБОТАЛ тк name это простой тип -> Tom 
            Console.WriteLine(p3.Work.Name); //здес MemberwiseClone НЕ сработал тк name это сложный тип -> Google - а должно быть Microsoft
//глубоуоке копирование
            DeepPerson p5 = new DeepPerson { Name = "Tom", Age = 23, Work = new Company { Name = "Microsoft" } };
            DeepPerson p6 = (DeepPerson)p5.Clone();
            p6.Work.Name = "Google";
            p6.Name = "Alice";
            Console.WriteLine(p5.Name); // Tom
            Console.WriteLine(p5.Work.Name); //Microsoft

            Console.Read();
        }
    }
    
    public interface ICloneable //Чтобы переменная p2 указывала на новый объект, но со значениями из p1, мы можем применить клонирование
                                //с помощью реализации интерфейса ICloneable
    {
        object Clone();
    }

    class Person
    {

        public string Name { get; set; }
        public int Age { get; set; }
    }
//неглубокое копирование
    class SurfacePerson : ICloneable//реализуем интерфейс 
    {
        
        public string Name { get; set; }//Поверхностное копирование работает только для свойств, представляющих примитивные типы
        public int Age { get; set; }

        public Company Work { get; set; }//в случае если реализуетсся неглубокое копирвание В этом случае при копировании новая
        //копия будет указывать на тот же объект Company

        public object Clone()
        {
            return this.MemberwiseClone();//добавляем специальный метод MemberwiseClone(), который возвращает копию объекта,
                                          //но этот метод реализует неглубокое копирование 
        }

        
    }
//глубокое копирование
    class DeepPerson : ICloneable//реализуем интерфейс 
    {
        public string Name { get; set; }
        public int Age { get; set; }
        public Company Work { get; set; }

        public object Clone()//пр использовании метода клон мы...
        {
            
            Company company = new Company { Name = this.Work.Name };//...вмемсто использоваания метода MemberwiseClone мы при создании
            //DeepPerson экземмпляраа создаем новый экземпляр сложного типа и копируем туда название поля из DeepPerson.Work...


            return new DeepPerson
            {//.. далее мы при создании экземмпляраа DeepPerson создаем новый экземпляр DeepPerson со СКОПИРИОВАНЫМИ туда значениями из
                //этого экземпляра,далее в Work мы записываем КОПИЮ из первоначального экземпляра, чтобы потом ее эту КОПИЮ можно было
                //поменят не за рагивая ОРИГИНАЛ
                Name = this.Name,
                Age = this.Age,
                Work = company
            };
        }
    }

    class Company
    {
        public string Name { get; set; }
    }

==========================================


--IComparable сортировка обьектов и IComparer Применение компаратора--
------------------------------------------
IComparable сортировка обьектов 
Большинство встроенных в .NET классов коллекций и массивы поддерживают сортировку.
С помощью одного метода, который, как правило, называется в Sort() можно сразу отсортировать по возрастанию весь набор данных. Например:

    class Program
    {
        static void Main(string[] args)
        {
            int[] numbers = new int[] {97, 45, 32, 65, 83, 23, 15};
            Array.Sort(numbers); //для простых типов типа int или string существует метод сортировки по возрвастанию через Sort 
            foreach (int n in numbers)
                Console.WriteLine(n);

            Person p1 = new Person {Name = "Bill", Age = 34};
            Person p2 = new Person {Name = "Tom", Age = 23};

            Person p3 = new Person {Name = "Alice", Age = 21};
            Person p4 = new Person {Name = "Max", Age = 21};
            Person[] people = new Person[] {p1, p2, p4, p3};
            Array.Sort(people); //здес будет исоплльзоваатсся CompareTo тк это сложный тип


            foreach (Person p in people)
            {
                Console.WriteLine($"{p.Name} - {p.Age}");
            }
        }
    }

    //public interface IComparable //это являетсся устаревшим и нее используемым интерффейсом
    //{
    //    int CompareTo(object o);
    //}

    class
        Person : IComparable<Person> //но для сложных типов это не сработает необходим интерфейс IComparable с обощением
    {
        public string Name { get; set; }
        public int Age { get; set; }

        public int CompareTo(Person o) //онн имеет всего один метод CompareTo предназначен для сравнения текущего объекта Person с объектом,
            //который передается в качестве параметра Person o. На выходе он возвращает целое число, которое может иметь одно из трех значений
            //Меньше нуля. Значит, текущий объект должен находиться перед объектом, который передается в качестве параметра
            //Равен нулю.Значит, оба объекта равны
            //Больше нуля.Значит, текущий объект должен находиться после объекта, передаваемого в качестве параметра
        {
            return this.Age.CompareTo(o.Age); //производим сортировку по возрасту сравнивая возраст текущегго обьекта и обьекта который передается в качестве параметра
            //какой куда передается зависит от алгоритмов сортировки
            //далее если обьект который this < Person o то будет -1 и this должен находится до Person o,  this > Person o то будет 1 и this должен находится после Person o,
            // this == Person o то будет 0 и this будет находится относително Person o соответвенно порядку в котором они были в первоначальном списке
            // Person[] people = new Person[] {p1, p2, p4, p3}; те в данном случае спервма p4 а потом p3 тк их сравнение венет 0
        }
    }
}

------------------------------------------
 IComparer Применение компаратора 

Метод Compare предназначен для сравнения двух объектов o1 и o2. Он также возвращает три значения, в зависимости от результата сравнения: если первый объект больше 
второго, то возвращается число больше 0, если меньше - то число меньше нуля; если оба объекта равны, возвращается ноль.

class Program
    {
        static void Main(string[] args)
        {
          
            Person p1 = new Person {Name = "Bill", Age = 34};
            Person p2 = new Person {Name = "Tom", Age = 23};
            Person p3 = new Person {Name = "Alice", Age = 21};
            Person p4 = new Person {Name = "Maximmer", Age = 21};

            Person[] people = new Person[] {p1, p2, p4, p3};

            Person[] peopleLenght = new Person[] { p1, p2, p4, p3 };

            Array.Sort(peopleLenght, new PeopleComparer());//Объект компаратора указывается в качестве второго параметра метода Array.Sort(). 
            //При этом не важно, реализует ли класс Person интерфейс IComparable или нет. Правила сортировки, установленные компаратором, 
            //будут иметь больший приоритет. В начале будут идти объекты Person, у которых имена меньше, а в конце - у которых имена длиннее:

            foreach (Person p in peopleLenght)
            {
                Console.WriteLine($"{p.Name} - {p.Age}");
            }
        }
    }

   

    class Person : IComparable<Person> 
    {
        public string Name { get; set; }
        public int Age { get; set; }

        public int CompareTo(Person o)
        {
            return this.Age.CompareTo(o.Age); 
        }
    }

    class PeopleComparer : IComparer<Person>//В данном случае используется обобщенная версия интерфейса IComparer, чтобы не делать излишних преобразований типов.
    {
        public int Compare(Person p1, Person p2)//Метод Compare предназначен для сравнения двух объектов o1 и o2. Он также возвращает три значения,
            //в зависимости от результата сравнения: если первый объект больше второго, то возвращается число больше 0, если меньше
            //- то число меньше нуля; если оба объекта равны, возвращается ноль.
        {
            if (p1.Name.Length > p2.Name.Length)//он сравнивает объекты в зависимости от длины строки - значения свойства Name 
                return 1;
            else if (p1.Name.Length < p2.Name.Length)
                return -1;
            else
                return 0;
        }
    }
}class Program
    {
        static void Main(string[] args)
        {
          
            Person p1 = new Person {Name = "Bill", Age = 34};
            Person p2 = new Person {Name = "Tom", Age = 23};
            Person p3 = new Person {Name = "Alice", Age = 21};
            Person p4 = new Person {Name = "Maximmer", Age = 21};
            
            Person[] peopleLenght = new Person[] { p1, p2, p4, p3 };

            Array.Sort(peopleLenght, new PeopleComparer());

            foreach (Person p in peopleLenght)
            {
                Console.WriteLine($"{p.Name} - {p.Age}");
            }
        }
    }

    class Person : IComparable<Person> 
    {
        public string Name { get; set; }
        public int Age { get; set; }

        public int CompareTo(Person o)
        {
            return this.Age.CompareTo(o.Age); 
        }
    }

    class PeopleComparer : IComparer<Person>//В данном случае используется обобщенная версия интерфейса IComparer, чтобы не делать излишних преобразований типов.
    {
        public int Compare(Person p1, Person p2)//Метод Compare предназначен для сравнения двух объектов o1 и o2. Он также возвращает три значения,
            //в зависимости от результата сравнения: если первый объект больше второго, то возвращается число больше 0, если меньше
            //- то число меньше нуля; если оба объекта равны, возвращается ноль.
        {
            if (p1.Name.Length > p2.Name.Length)//он сравнивает объекты в зависимости от длины строки - значения свойства Name
            //если первый объект больше второго, то возвращается число больше 0, если меньше
            //- то число меньше нуля; если оба объекта равны, возвращается ноль. 
                return 1;
            else if (p1.Name.Length < p2.Name.Length)
                return -1;
            else
                return 0;
        }
    }
}

==========================================

--Методы расширения--
------------------------------------------
Методы расширения (extension methods) позволяют добавлять новые методы в уже существующие типы без создания нового производного класса. 
Эта функциональность бывает особенно полезна, когда нам хочется добавить в некоторый тип новый метод, но сам тип (класс или структуру) 
мы изменить не можем, поскольку у нас нет доступа к исходному коду. Либо если мы не можем использовать стандартный механизм наследования, 
например, если классы определенны с модификатором sealed.


public static class StringExtension//вначале надо создать статический класс, который и будет содержать этот метод. 
{
    public static int CharCount(this string str, char c)// добавив перед первым свойстваством this мы создаем метод расширения
    //this имя_типа название_параметра, то есть в нашем случае this string str так можно добваит к типу string новый метод, 
    //который будет подсчитыват количество char c в строке string str, Причем нам уже не надо указывать первый параметр.
    {
        int counter = 0;
        for (int i = 0; i<str.Length; i++)
        {
            if (str[i] == c)
                counter++;
        }
        return counter;
    }
} 

class Program
{
    static void Main(string[] args)
    {
        string s = "Привет мир";
        char c = 'и';
        int i = s.CharCount(c);//Затем у всех строк мы можем вызвать данный метод: int i = s.CharCount(c);. 
        //Причем нам уже не надо указывать первый параметр. Значения для остальных параметров передаются в обычном порядке.

        Console.WriteLine(i);
 
        Console.Read();
    }
}
 
 public static class StringExtension
    {
        public static int CharCount(this DbSet<User> users, char c)//можно исопльзоват сложные типы и типы с обощением
        {
            int counter = 0;
            foreach (var user in users)
            {
                for (int i = 0; i < user.login.Length; i++)
                {
                    if (user.login[i] == c)
                        counter++;
                }
            }

            return counter;
        }
    }

            DbSet<User>  users = db.Users;
            users.CharCount('c');

Применение методов расширения очень удобно, но при этом надо помнить, что метод расширения никогда не будет вызван, 
если он имеет ту же сигнатуру, что и метод, изначально определенный в типе.

 о есть, если добавить в проект другое пространство имен, то метод не будет применяться к строкам, и в этом случае надо будет 
 подключить пространство имен метода через директиву using.
==========================================

--Deconstruct--
------------------------------------------
C# не предоставляет встроенную поддержку для деконструкции типов, не являющихся кортежами, кроме типов record и DictionaryEntry. 
Тем не менее, если вы являетесь создателем класса, структуры или интерфейса, вы можете разрешить деконструкцию экземпляров определенного типа, 
реализовав один или несколько методов Deconstruct. 
 
    class Person
    {
        public string Name { get; set; }
        public int Age { get; set; } 
        public int Height { get; set; }

        //public void Deconstruct(out string name)//метод Deconstruct должен принимать как минимум два выходных параметра, те так метод не сработает как надо

        //{
        //    name = this.Name;

        //}

        public void Deconstruct(out string name, out int age)//Метод возвращает "void", и каждое деконструируемое значение обозначается параметром out в сигнатуре метода.
            //Например, следующий метод  Deconstruct класса Person возвращает name и age
       
        {
            name = Name;
            age = Age;
        }

        public void Deconstruct(out string name, out int age, out int height)//так же можно реализовывать пергрузки меоду деконструкт

        {
            name = Name;
            age = Age;
            height = Height;
        }


        public void Deconstruct1(out string name, out int age)//обычный метод который реализован в примере без исопльзования функционала Deconstruct
        {
            name = Name;
            age = Age;
        }

    }

    public static class Strings
    {
        public static void Deconstruct(this String str, out int length, out int getHashCode)//Если вы не являетесь создателем класса, структуры или интерфейса,
            //вы все равно можете выполнять деконструкцию объектов этого типа, реализовав один или несколько Deconstruct методов расширения,
            //которые будут возвращать интересующие вас значения.
        {
            length = str.Length;
            getHashCode = str.GetHashCode();
        }
    }

        class Program
    {
        static void Main(string[] args)
        {
            Person person = new Person { Name = "Tom", Age = 33, Height = 180};

            (string names, int ages) = person;// В этом случае мы могли бы выполнить декомпозицию объекта Person так
            //создаем две перменные и через деконстурктор предаем в них значния по ссылке которые берем из полей класса Person - Name и Age  
            //string names, int ages, int heights имена перменных необзательно дожны сопвадать с именами перменных в методе  Deconstruct(out string name, out int age, out int height)

            Console.WriteLine(names);    // Tom
            Console.WriteLine(ages);     // 33


            var ( name1,  age1,  height) = person;//можно так же обьявить в начал var  и тогда все перенные в деконструкторе примут нужные типы в зависимости от типов в классе
            Console.WriteLine(name1);    // Tom
            Console.WriteLine(age1);     // 33
            Console.WriteLine(height);    // 180

            var (name2, _, height2) = person;//пустые переменные можно применять с пользовательскими типами, чтобы игнорировать определенные элементы, возвращаемые методом Deconstruct
            Console.WriteLine(name2);    // Tom
            Console.WriteLine(height2);    // 180

            //этот код аналлгичен вышенаписаному но без исопльзования функционала Deconstruct
            Person person2 = new Person { Name = "Max", Age = 20 };

            string name3; 
            int age3;
            person.Deconstruct1(out name3, out age3);
            Console.WriteLine(name3);    // Max
            Console.WriteLine(age3);     // 20


            String ss = "Hello";//можно например сделать так
            (int length,int getHashCode) = ss;
            Console.WriteLine(length);//длина строки 5
            Console.WriteLine(getHashCode);//хешкод строки -1454575212
        }
}
==========================================

--пусстые перменные--
------------------------------------------
переменные-заполнители (_), которые намеренно не используются в коде приложения, онни эквивалентны переменным, которым не присвоены значения;
 пустые переменные не имеют значений, оии указывают это свое намерениие (игнорироват результат выражения) комплиятору и рахзрабочикам

Так как пустая переменная по сути всего одна, этой переменной может даже не выделяться память.

------------------------------------------
_ также является допустимым идентификатором. При использовании вне поддерживаемого контекста _ считается не пустой, а действительной переменной. 

private static void ShowValue(int _)
{
   byte[] arr = { 0, 0, 1, 2 };
   _ = BitConverter.ToInt32(arr, 0);
   Console.WriteLine(_);//_ теер обычная перменная, но в таком случае не стоит использовать ее в текущем контескте в качетве обчной пустой перменной
}
 // The example displays the following output:
 //       33619968

------------------------------------------
в деконструкторе Deconstruct
public void Deconstruct(out string name, out int age, out int height)...//из этого деконструктора нам нужно только name и height, а age мы игнорируем
//как раз используя пустую перменную

var (name2, _, height2) = person;//пустые переменные можно применять с пользовательскими типами, чтобы игнорировать определенные элементы,
// возвращаемые методом Deconstruct

------------------------------------------
в свичах switch
Шаблон пустой переменной можно использовать при сопоставлении шаблонов с выражением switch. Каждое выражение, включая null, 
всегда соответствует шаблону пустой переменной.

static int Select(int op, int a, int b) => op switch
{
    1 => a + b,
    2 => a - b,
    3 => a * b,
    _ => throw new ArgumentException("Недопустимый код операции")//здесь исопльзуется пустая перменная вместоо оператора default 
};

------------------------------------------
при вызове метода с параметром out вы также можете сделать пустыми значения аргументов out.

В следующем примере вызывается метод DateTime.TryParse(String, out DateTime), который определяет, является ли строковое представление
 даты допустимым для текущего языка и региональных параметров. Так как этот пример связан только с проверкой строки даты и не включает
  анализ этой строки для получения самой даты, аргумент out метода является пустым.

string[] dateStrings = {"05/01/2018 14:57:32.8", "2018-05-01 14:57:32.8",
                      "2018-05-01T14:57:32.8375298-04:00", "5/01/2018",
                      "5/01/2018 14:57:32.80 -07:00",
                      "1 May 2018 2:57:32.8 PM", "16-05-2018 1:00:32 PM",
                      "Fri, 15 May 2018 20:10:57 GMT" };
foreach (string dateString in dateStrings)
{
    if (DateTime.TryParse(dateString, out _))//ннас не интересует выход данных сстроки, а только ее пригодоность нашему паттерну
        Console.WriteLine($"'{dateString}': valid");
    else
        Console.WriteLine($"'{dateString}': invalid");
}
// The example displays output like the following:
//       '05/01/2018 14:57:32.8': valid
//       '2018-05-01 14:57:32.8': valid
//       '2018-05-01T14:57:32.8375298-04:00': valid
//       '5/01/2018': valid
//       '5/01/2018 14:57:32.80 -07:00': valid
//       '1 May 2018 2:57:32.8 PM': valid
//       '16-05-2018 1:00:32 PM': invalid
//       'Fri, 15 May 2018 20:10:57 GMT': invalid

------------------------------------------
Вы можете использовать отдельную пустую переменную, чтобы указать, что переменную необходимо игнорировать

public static void Method(string arg)
{
    _ = arg ?? throw new ArgumentNullException(paramName: nameof(arg), message: "arg can't be null");//так можно организоват проверку на null
    //в случе если arg  не null мтеодд ничего не веррнет, а вслучае если null то высскочит исключение
    // Коду не требуется результат присваивания, поэтому используется пустая переменная. 

    // Do work with arg.

}
------------------------------------------

В следующем примере отдельная пустая переменная используется, чтобы игнорировать объект Task, возвращаемый асинхронной операцией.
 Назначение задачи приводит к подавлению исключения, созданного операцией перед завершением. Это делает ваше намерение явным:
  Вам нужно назначить Task пустой переменной и пропустить все ошибки, созданные в этой асинхронной операции.

private static async Task ExecuteAsyncMethods()
{
    Console.WriteLine("About to launch a task...");
    _ = Task.Run(() =>
      //если убратьт отсюда _ = то появится предупреждение CS4014: Because this call is not awaited, 
      //execution of the current method continues before the call is completed.
    // Consider applying the 'await' operator to the result of the call.
    {
        var iterations = 0;
        for (int ctr = 0; ctr < int.MaxValue; ctr++)
            iterations++;
        Console.WriteLine("Completed looping operation...");
        throw new InvalidOperationException();
    });
    await Task.Delay(5000);
    Console.WriteLine("Exiting after 5 second delay");
}
// The example displays output like the following:
//       About to launch a task...
//       Completed looping operation...
//       Exiting after 5 second delay

==========================================
--await timer--
------------------------------------------
await CommandToFormSupply("Output", "0"); программа дожидается выполнения и только потом перскакивает на следующий 
оператор CommandToFormSupply("Output", "0"); программа не дожидается выполнения и сразу  перскакивает на следующий 
оператор

==========================================




------------------------------------------
--WinForm--
------------------------------------------
 this.Tag.ToString(); получение тега кнопки

 Debug.WriteLine(cmd); так мождно проследить за выполнением команды в окне output например при нажатии кнопки

==========================================

 --Reflection--

------------------------------------------



 создание словаря с определенгными элементами из класса
------------------------------------------
Type to = typeof(String);//дляклассов 
Type t = ss.GetType();//для переменных

     private void DictionaryAdd()
        {
          
            var type1 = typeof(Form1)//рефлексим класс по названию
            var type2 = type1.GetFields();// получаем все поля из него

            foreach (var types in type2)
            {
                
                if (types.FieldType.Name == "Button")// если имя типа элеменат == кнопке ... 
                {
                    elems.Add(types.Name, types.GetValue(this));//... то добаляем в словарь
                }
               
            }

            SafeGetComponent<Button>("CalcDelta").BackColor = Color.Red;

        }

         public T SafeGetComponent<T>(string name) where T : Component//присваивание типа определенному элменту 
         //тк рефлекшн возрващает обджекты 
        {
            return elems[name] as T;//.FirstOrDefault(e => e is T component && component.name == name ) as T;
        }

получение данных из приватной (private) перменной через рефлексию
------------------------------------------
  class Point
     {
         private int x;
 
         public void SetX(int x)
         {
             this.x = x;
         }
     }

  static void Main(string[] args)
        {
            Point p = new Point();
            p.SetX(3);

            var str = GetInstanceField(typeof(Point), p, "x");
            var ss = (int) str;
            Console.WriteLine(ss);
            Console.ReadLine();
        }

        //Type type -  для имени класса (typeof(имя класса),  object instance для экземпляраа класса object 
        //экз. класса, string fieldName - для имени перменной
        internal static object GetInstanceField(Type type, object instance, string fieldName)
        {
            //задаем параметр поиска 
            BindingFlags bindFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic
                                     | BindingFlags.Static;
            FieldInfo field = type.GetField(fieldName, bindFlags);
            //возвращаем значение искомой пермененной в виде object
            return field.GetValue(instance);
        }
    }


==========================================


--Циклы--
------------------------------------------

пример switch

  return key switch
            {
                "c" => new ChatClient(),
                "s" => new ChatServer(),
                _ => null
            };


public StopBits ConvertStopBits(int stopBit)
        {
            return stopBit switch
            {
                1 => StopBits.One,
                2 => StopBits.Two,
                _ => StopBits.One
            };
        }

        
==========================================




--Делегаты--
------------------------------------------
Делегаты представляют такие объекты, которые указывают на методы. 
То есть делегаты - это указатели на методы и с помощью делегатов мы можем вызвать данные методы.

Если делегат принимает параметры, то в метод Invoke передаются значения для этих параметров.

Другой пример анонимных методов - передача в качестве аргумента для параметра, который представляет делегат
о в одной используется ?
------------------------------------------
delegate void MessageHandler(string message);


    static void ShowMessage(string mes, MessageHandler handler) //handler теперь указывает на анонимный метод 
    //и по сути является им
    {
        handler(mes); Отсюда вызывается сообщение на консоль!
    }

     static void Main(string[] args)
    {
        ShowMessage("hello!", delegate(string mes)
        { 
        Console.WriteLine(mes); 
        });//Здесь всего лишь передаем параметры 
        //для функции
    }


------------------------------------------
использование делегатов в качестве парметров анонимного метода;
 int[] integers = { 2, 7, 3, 6, 5, 4, 7, 8, 9 };

            // найдем сумму чисел больше 5
            int result = Sum(integers, ss => ss > 5);//эта записаь аналогична нижеследующей...
            Console.WriteLine(result);

            // найдем сумму четных чисел
            int result2 = Sum(integers, delegate(int ss)//...эта записаь аналогична вышеследующей
            {
                if (ss % 2 == 0)
                {
                    return true;
                }

                return false;
            });
            Console.WriteLine(result2);
        }

        private static int Sum(int[] numbers, IsEqual funcx)
        {
            int result = 0;
            foreach (int i in numbers)
            {
                if (funcx(i))
                    result += i;
            }
            return result;
        }
------------------------------------------
Делегаты и метода со скобками и без скобок
 // Объявить тип делегата. 
    delegate string StrMod(string str);
    class StringOps
    {
        // Заменить пробелы дефисами. 
        public string ReplaceSpaces(string s)
        {
            Console.WriteLine("Замена пробелов дефисами.");
            return s.Replace(' ', '-');
        }
        // Удалить пробелы. 
        public string RemoveSpaces(string s)
        {
            string temp = "";
            int i;
            Console.WriteLine("Удаление пробелов.");
            for (i = 0; i < s.Length; i++)
                if (s[i] != ' ') temp += s[i];
            return temp;
        }
    }

    delegate int CountIt(int end);

    class VarCapture
    {
        public static CountIt Counter()//в том методе явно создавался новый анонимный
            //делегат, который потом возвращался этим методом
        {
           
            
            CountIt ctObj = delegate(int end)//создание ананоимного делегата
            {
                int sum = 0;
                for (int i = 0; i <= end; i++)
                {
                    Console.WriteLine(i);
                    sum += i;
                }

                return sum;
            };
            return ctObj;//возвращение анонимного делегата
        }
    }

    class DelegateTest
    {
        static void Main()
        {
            StringOps so = new StringOps(); // создать экземпляр 
            // объекта класса StringOps 
            string str;

            // Инициализировать делегат. 
            StrMod strOp = so.ReplaceSpaces;//Вот в этой строчке инициализируется делегат
            //ссылкой на метод, потому тут скобки не нужны.
            str = strOp("Это простой тест");// Вызвать методы с помощью делегатов. 
            Console.WriteLine("Результирующая строка: " + str);
            

            strOp = so.RemoveSpaces;//Вот в этой строчке инициализируется делегат
            //ссылкой на метод, потому тут скобки не нужны.
            str = strOp("Это простой тест");// Вызвать методы с помощью делегатов. 
            Console.WriteLine("Результирующая строка: " + str);
            
            CountIt count = VarCapture.Counter();//здесь вызывается метод, который создает
            //делегат, а не создается делегат, а если мы вызываем метод, то обязательно нужны скобки.

            int result;
            result = count(3);
            Console.WriteLine("Сумма 3 равна " + result);
            Console.WriteLine();
            result = count(5);
            Console.WriteLine("Сумма 5 равна " + result);
        }
    }
------------------------------------------
 обобщённый делегат;

delegate возвращаемый_тип имя_делегата<список_параметров_типа>(список_аргументов);
delegate T 				  Operation	  <T, K ,J>				  (K val, J value);

        class Program
        {
            static void Main(string[] args)
            {
                Operation<decimal, int, string> op = Square;

                Console.WriteLine(op(5, "2"));
                Console.Read();
            }

            static decimal Square(int n, string ss)
            {
                n += int.Parse(ss);
                return n * n;
            }
        }

------------------------------------------    
    View.OpenSettings += () => OpenSettings(); //так можно избежать требований сигнатуры метода при вызове экшана,
    но при этом -= отключит анонимный метод но не OpenSettings()


------------------------------------------
Ковариантность делегатов

Ковариантность позволяет возвращать из метода объект, тип которого является производным от типа, возвращаемого делегатом
(предпологается upcasting).

Ковариантность - выходящие из банка могут быть не просто людьми, но и клиентами банка.
Ковариантностью называется сохранение иерархии наследования исходных типов в производных типах в том же порядке.
 Так, если класс Cat наследуется от класса Animal, то естественно полагать, что перечисление IEnumerable<Cat> 
 будет потомком перечисления IEnumerable<Animal>. Действительно, «список из пяти кошек» — это частный случай «списка из 
 пяти животных». 
 В таком случае говорят, что тип (в данном случае обобщённый интерфейс) IEnumerable<T> ковариантен своему 
 параметру-типу T.


 class Person
    {
        public string Name { get; set; }
    }

    class Client : Person
    {
        public string LastName { get; set; }
    }

    delegate Person PersonFactory(string name);//делегат возвращает тип Person
    //который является базовым типом для производного типа Client


    class Programm
    {
        private static Person BuildPerson(string name)//этот метод у нас возвращает обьект 
        //Person что соотвтетвует делегату PersonFactory здесь нет необходимости  использовать
        //ковариантность делегатов
        {
            return new Person
            {
                Name = name
            };
        }

        private static Client BuildClient(string name) // этот метод возрващает
        //обьект класса Client, что недолжно бы соответовать делегату PersonFactory,
        //НО КОВАРИАНТНОСТЬ позволяет вставить этот метод в этот делегат и вернуть из метода
        //объект Client - тип который является ПРОИЗВОДНЫМ от типа  который возвращает делегат
        //PersonFactory (делегат Person PersonFactory(string name) возвращает тип Person 
        //который является базовым для Client)
        {
            return new Client//возвращаем из метода объект Client
            {
                Name = name
            };
        }
        static void Main(string[] args)
        {
            PersonFactory personDel; //создаем перменную делегата она предназначена для методов возвращающих 
            //обьекты класса Person

            personDel = BuildPerson;// инициализируем перменную делегата методом который возварщает
            //обьект Person те используем делегат стандартно без использованиря апкастов 
            Person p = personDel("Tom");
            Console.WriteLine($"{p.Name} {p.GetType()}");// Tom ExperementNetCore.Person
            
            personDel = BuildClient; // инициализируем перменную делегата методом который возварщает
            //обьект Client те используем делегат конвариантно
            Person p2 = personDel("Max"); // То есть здесь делегат возвращает объект Client и
            //апкастит его к обьекту класса Person 
            Console.WriteLine(p2.Name + " " + p2.GetType());//Max ExperementNetCore.Client

            Console.Read();
        }
    }


Ковариантность - выходящие из банка могут быть не просто людьми, но и клиентами банка.
Ковариантностью называется сохранение иерархии наследования исходных типов в производных типах в том же порядке.
 Так, если класс Cat наследуется от класса Animal, то естественно полагать, что перечисление IEnumerable<Cat> 
 будет потомком перечисления IEnumerable<Animal>. Действительно, «список из пяти кошек» — это частный случай «списка из 
 пяти животных». 
 В таком случае говорят, что тип (в данном случае обобщённый интерфейс) IEnumerable<T> ковариантен своему 
 параметру-типу T.


  class Car
    {
        public void Drive()
        {

        }
    }

    class Mersedes : Car
    {
        public string ClassName;//расширяем базовый функционалл класса Car
    }


    class Uaz : Car
    {
        public string MaxSpeed;//расширяем базовый функционалл класса Car
    }

    delegate T MyDelegate<out T>(); //указывает на то что тут будет использоватсяя ковариантность,
    //позволяет возвращать из метода обьект тип которого является производным от типа возращаемого делегатом
    //
    
    class Programm
    {
        static Mersedes MersedesBuilder()
        {
            return new Mersedes();
        }
        static Mersedes MersedesBuilderTwo()
        {
            return new Mersedes();
        }


        static Uaz UazBuilder()
        {
            return new Uaz();
        }


        static void Main(string[] args)
        {
            MyDelegate<Mersedes> mers = MersedesBuilder;//создаем делегат типизированный классом Mersedes,
            //ссвязываем этот делегат с методом MersedesBuilder  
            MyDelegate<Car> car = mers;//здесь происходит апкаст, тк мы присваеваем делегату car
            //типизированолму классом Car, делегат типизировный классом Mersedes, те произзводим
            //апкаст делегата

            mers().Drive();
            mers().ClassName = "S-class";

            car().Drive();
            //car().ClassName = "S-class"; это выдаст ошибку тк поле ClassName принадлежит к классу
            //Mersedes.И хотя теперь car и mers указывают на одно и то же место в памяти(MyDelegate<Mersedes>),
            // переменной car будет доступна только та часть, которая представляет функционал типа MyDelegate<Car>.
            // Это назыывается  восходящие преобразования или апкаст

            Console.WriteLine(mers.GetType() + " " + car().GetType());//mers.GetType() в этом примере делегат
            //инициализируется ссылкой на метод, потому тут скобки нет.
            //А здесь car().GetType() здесь через делегат вызываем метод static Mersedes MersedesBuilder(),
            //на который ссылается данный делегат, а не создаем делегат как в примере выше,
            //а если мы вызываем метод, то обязательно нужны скобки.

            MyDelegate<Uaz> uaz = UazBuilder;
            MyDelegate<Car> car2 = uaz;

            //car.Invoke().MaxSpeed = "15";//это выдаст ошибку тк поле MaxSpeed принадлежит к классу Uaz
            //а ссылочная перменная обьект car указывает сейчас на на клсасс в   

            Console.WriteLine();

        }
    }

------------------------------------------ 
Контрвариантность делегата 
Контрвариантность делегата предполагает, что типом параметра может быть более универсальный тип.(предпологается downcasting)
Контрвариантность - в банк могут входить люди. 

Так, если класс String наследуется от класса Object, а делегат Action<T> определён как метод, принимающий объект типа T, 
то Action<Object> наследуется от делегата Action<String>, а не наоборот. Действительно, если «все строки — объекты», 
то «всякий метод, оперирующий произвольными объектами, может выполнить операцию над строкой», но не наоборот.

Как и в случае с обобщенными интерфейсами параметр ковариантного типа применяется только к типу значения,
 которые возвращается делегатом. 
А параметр контравариантного типа применяется только к ВХОДНЫМ АРГУМЕНТАМ делегата.


class Person
{
    public string Name
    { 
      get; set;
    }
}
class Client : Person 
{
}


delegate void ClientInfo(Client client); //Несмотря на то, что делегат в качестве параметра принимает объект Client...


static void Main(string[] args)
{
    ClientInfo clientInfo = GetPersonInfo; //используем контравариантность
    Client client = new Client{Name = "Alice"};
    clientInfo(client);
    Console.Read();
}
private static void GetPersonInfo(Person p)//...ему можно присвоить метод, принимающий в качестве параметра объект базового типа Person.
{
    Console.WriteLine(p.Name);
}

Может показаться на первый взгляд, что здесь есть некоторое противоречие, то есть использование более универсального тип вместо более
производного. Однако в реальности в делегат при его вызове мы все равно можем передать только объекты типа Client,
а любой объект типа Client является объектом типа Person, который используется в методе

------------------------------------------
Делегаты Action, Predicate и Func

Делегат Action является обобщенным, принимает параметры и возвращает значение void:
------------------------------------------
public delegate void Action<T>(T obj);
 можно передать до 16 значений в метод.
public delegate void Action<T,T2,...T16>(T obj,T2 obj2,...T16 obj16);

Как правило, этот делегат передается в качестве параметра метода и предусматривает вызов определенных действий 
в ответ на произошедшие действия

static void Main(string[] args)
            {
                Action<int, int> op;
                op = Add;
                Operation(10, 6, op);//Оператион через экщен ор делает сумму 10 и 6
                op = Substract;
                Operation(10, 6, op);//Оператион через экщен ор делает умножение 10 и 6
            }

            static void Operation(int x1, int x2, Action<int, int> op)//один и тот же метод делает 
            //разные вещи в зависимости от значения экшена ор
            {
                if (x1 > x2)
                    op(x1, x2);
            }

            static void Add(int x1, int x2)
            {
                Console.WriteLine("Сумма чисел: " + (x1 + x2));
            }

            static void Substract(int x1, int x2)
            {
                Console.WriteLine("Разность чисел: " + (x1 - x2));
            }

         
------------------------------------------
Predicate

Predicate<int> isPositive = x => x > 0;

                Console.WriteLine(isPositive(20));
                Console.WriteLine(isPositive(-20));


------------------------------------------
Func

возвращает результат действия и может принимать 
параметры. Он также имеет различные формы: от Func<out T>(), где T - тип возвращаемого значения, 
до Func<in T1, in T2,...in T16, out TResult>(), то есть может принимать до 16 параметров.

TResult Func<out TResult>()
TResult Func<in T, out TResult>(T arg)
TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2)
TResult Func<in T1, in T2, in T3, out TResult>(T1 arg1, T2 arg2, T3 arg3)
TResult Func<in T1, in T2, in T3, in T4, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4)

Метод GetInt() в качестве параметра принимает делегат Func<int, int>, то есть ссылку на метод,
 который принимает число int и возвращает также значение int.
static void Main(string[] args)
          {
              Func<int, int> retFunc = Factorial;
              int n1 = GetInt(6, retFunc);
          }
static int GetInt(int x1, Func<int, int> retF)
  			{
  			    int result = 0;
  			    if (x1 > 0)
 			         result = retF(x1);
  			    return result;
  			}
 static int Factorial(int x)//функц в качестве парметра принимает именно этот метод
            {
                int result = 1;
                for (int i = 1; i <= x; i++)
                {
                    result *= i;
                }

                return result;
            }

------------------------------------------
пример реализации делегатов

delegate void AccountStateHandler(string message);//создаем делегат
 class Person
    {
        private AccountStateHandler _del;//создаем перменную делегата

        private string name;
        public void RegisterHandler(AccountStateHandler del)//создаем регистратор перменной делегата 
        //чтобы потом записать в него метод который будет вызватся при произведении нашего действия
        {
            _del = del;
        }

        public string Name
        {
            get
            {
                return name;
            }
            set => name = value;
        }

        public void DisplayTo()//наше действие 
        {
            _del(name);//когда вызывается это метод происходит вызов делегата те вставленого туда в 
            //процессе регистрации метода и вставляем в аргумент этого метода перменную name
        }

    }
    class Employee : Person
    {

    }
    class Program
    {
        static void Main(string[] args)
        {

            Person p = new Person{Name = "Tomm"};
            p.RegisterHandler(new AccountStateHandler(Display));//регистарция и присвоение в делегат 
            //того мтоеда Display кторый будет вызватся при вызове делегата
            p.DisplayTo();//вызываем наш делегат 
            p = new Employee { Name = "Sam" };
            p.RegisterHandler(new AccountStateHandler(Display));
            p.DisplayTo();
           
           
            Console.Read();
        }

        static void Display(string name)//этот метод будет вызыватся при использовании делегата
        {
            Console.WriteLine(name);
        }
    }


------------------------------------------
пример реализации ивентов
delegate void AccountHandler(string message);
    class Person
    {
        public event AccountHandler _notify;
        private string name;
        string tempName;
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value != name)
                {
                    name = value;
                    DisplayTo();
                }
                
            }
        }

        public void DisplayTo()
        {
            _notify?.Invoke(name);
        }

    }
    class Employee : Person//этот класс будет реализовывать тот же функционал, что и класс Person
                           //Таким образом, наследование реализует отношение is-a (является),
                           //объект класса Employee также является объектом класса Person:
    {

    }
    class Program
    {
        static void Main(string[] args)
        {

            Person p = new Person();
            p._notify += Display;
            p.Name = "flfl";
            p = new Employee();//И поскольку объект Employee является также и объектом Person,
                               //то мы можем так определить переменную: Person p = new Employee().

            p._notify += Display;//но так как новый экземпляр всегода
            //создается с дефолтными значениями
            //нам нажно переподключится к ивенту
            p.Name = "Josh";
            Console.Read();
        }

        static void Display(string name)
        {
            Console.WriteLine(name);
        }
    }

==========================================





--Linq--

------------------------------------------
пример использования Linq Select
------------------------------------------
 var equalsToFive = integers.Select(delegate(int ss)//эта записаь аналогична нижеследующей
            {
                if (ss ==5)
                {
                    return true;
                }

                return false;
            }).ToArray();

var NotEqualsToFive = integers.Select(element => element != 5).ToArray();//эта записаь аналогична вышеследующей



==========================================




--Частичные классы partial--
------------------------------------------


 public partial class Person//частичный класс
{
    public void Move()
    {
        Console.WriteLine("I am moving");
    }
    partial void DoSomethingElse();//частичный метод
}
А в другом файле определим следующий класс
а так же частичные классы могут содержать частичные методы

public partial class Person//частичный класс
{
    public void Eat()
    {
        Console.WriteLine("I am eating");
    }
     partial void DoSomethingElse()//частичный метод
    {
        Console.WriteLine("I am reading a book");
    }
}

 static void Main(string[] args)
    {
        Person tom = new Person();
        tom.Move();//I am moving
        tom.Eat();//I am eating
 
        Console.ReadKey();
    }
Таким образом, два файла в проекте содержит определение одного и того же класса Person, 
которые содержат два разных метода. И оба определенных здесь класса являются частичными. 
Для этого они определяются с ключевым словом partial.
==========================================

<--WPF-->
------------------------------------------
--xalm

язык для описания дизайна фпа приложения

--события WPF
------------------------------------------
WPF в отличие от других технологий, например, от Windows Forms, предлагает новую концепцию событий - маршрутизированные события (routed events).

Для элементов управления в WPF определено большое количество событий, которые условно можно разделить на несколько групп:

События клавиатуры

События мыши

События стилуса

События сенсорного экрана/мультитач

События жизненного цикла

Подключить обработчики событий можно декларативно в файле xaml-кода,:
<Button x:Name="Button1" Content="Click" Click="Button_Click" />

а можно и в самом коде используя например такой вот перебор всех кнопок в сетке MainRoot

 public MainWindow()
        {
            InitializeComponent();
            foreach (UIElement elem in MainRoot.Children)//через UIElement мы перебираем все обьекты
                //которые находятся в нашей сетке MainRoot.Children обьекты оотносящиеся
                //к нашему Grid x:Name="MainRoot"
            {
                if (elem is Button)//теперь нужно прверить относится ли дочерний обьект к классу Button
                {
                    ((Button) elem).Click += Button_Click;//тк Button это производный класс от класса 
                    //UIElement необходимо произвести явное приведение (downcast), да
                }
            }
          
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show("Hi from Button_Click");
        }

Все маршрутизируемые события используют класс RoutedEventArgs (или его наследников), который представляет доступ к следующим свойствам:
Source: элемент логического дерева, являющийся источником события.
OriginalSource: элемент визуального дерева, являющийся источником события. Обычно то же самое, что и Source
RoutedEvent: представляет имя события
Handled: если это свойство установлено в True, событие не будет подниматься и опускаться, а ограничится непосредственным источником.


------------------------------------------
пример работы с xaml

    <Grid x:Name="MainRoot" Background="White">
        <!--grid здесь это основноая сетка, x:Name="" тут мы указываем название 
        через которое сможем в дальейшем обращатся к этому элеменрту и вытащит 
        из него все конпки и тд, Background отвечает за цвет фона-->
        <Grid.RowDefinitions>
            <!--создаем конструктор рядов -->
            <RowDefinition />
            <!--создаем 5 рядов -->
            <RowDefinition />
            <RowDefinition />
            <RowDefinition />
            <RowDefinition />
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <!--создаем конструктор столбцов -->
            <ColumnDefinition/>
            <!--создаем 4 стлбцов -->
            <ColumnDefinition/>
            <ColumnDefinition/>
            <ColumnDefinition/>

        </Grid.ColumnDefinitions>
        <TextBlock Grid.Row="0" Grid.Column="0" Text="" Grid.ColumnSpan="4" x:Name="textLabel" FontSize="48" FontFamily="Arial" Background="#FF999999" TextAlignment="Left" FontStretch="Normal" FontStyle="Normal" FontWeight="Normal" TextWrapping="NoWrap"/>
        <!--создаем тектовое поле в полях Grid.Row="0" Grid.Column="0" те в  адрес в ряде и в столбце соответсвенно 
        те верхний правый, Grid.ColumnSpan="4 обьединяем 4 столбца(Grid.RowSpan="4" так бы мы обьеденили 4 ряда)-->
        <Button x:Name="button1" Grid.Column="0" Grid.Row="1" Background="#FF191B17" Foreground="White" FontSize="16" FontFamily="Arial" >1</Button>
        <!--Background="#FF191B17" цвет кнопки, Foreground цвет текста, 1 это текст кнопки который будет отображатсня на ней, Grid.Column="0" Grid.Row="1" как уже показано 
        -->
        <Button x:Name="button2" Grid.Column="1" Grid.Row="1" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">2</Button>
        <Button x:Name="button3" Grid.Column="2" Grid.Row="1" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">3</Button>
        <Button x:Name="button4" Grid.Column="0" Grid.Row="2" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">4</Button>
        <Button x:Name="button5" Grid.Column="1" Grid.Row="2" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">5</Button>
        <Button x:Name="button6" Grid.Column="2" Grid.Row="2" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">6</Button>
        <Button x:Name="button7" Grid.Column="0" Grid.Row="3" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">7</Button>
        <Button x:Name="button8" Grid.Column="1" Grid.Row="3" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">8</Button>
        <Button x:Name="button9" Grid.Column="2" Grid.Row="3" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">9</Button>
        <Button x:Name="button0" Grid.Column="0" Grid.Row="4" Background="#FF191B17" FontSize="16" FontFamily="Arial" Foreground="White">0</Button>

        <Button x:Name="buttonAdd" Grid.Column="4" Grid.Row="1" Background="#FF464646" FontSize="16" FontFamily="Arial" Foreground="White">+</Button>
        <Button x:Name="buttonSubtraction" Grid.Column="4" Grid.Row="2" Background="#FF464646" FontSize="16" FontFamily="Arial" Foreground="White">-</Button>
        <Button x:Name="buttonMultiply" Grid.Column="4" Grid.Row="3" Background="#FF464646" FontSize="16" FontFamily="Arial" Foreground="White">*</Button>
        <Button x:Name="buttonDivide" Grid.Column="4" Grid.Row="4" Background="#FF464646" FontSize="16" FontFamily="Arial" Foreground="White">/</Button>
        <Button x:Name="buttonEqually" Grid.Column="1" Grid.Row="4" Background="#FF464646" FontSize="16" FontFamily="Arial" Foreground="White" >=</Button>
        <Button x:Name="buttonAC" Grid.Column="2" Grid.Row="4" Background="#FF464646" FontSize="16" FontFamily="Arial" Foreground="White">AC</Button>
    </Grid>
</Window>

------------------------------------------
в отличии от win form здесь мы использумем вот такой способ добычи элесентов из формы или сетки
 public MainWindow()
        {
            InitializeComponent();
            foreach (UIElement elem in MainRoot.Children) //через UIElement мы перебираем все обьекты
                //которые находятся в нашей сетке MainRoot.Children обьекты оотносящиеся
                //к нашему Grid x:Name="MainRoot"
            {
                if (elem is Button btn) //теперь нужно прверить относится ли дочерний обьект к классу Button
                {
                    btn.Click += Button_Click; //тк Button это производный класс от класса 
                    //UIElement необходимо произвести явное приведение (downcast), далее добалвем обрабочтик события к этому элементу
                }
            }

        }

        private void Button_Click(object sender, RoutedEventArgs e) //Все маршрутизируемые события используют класс
            //RoutedEventArgs (или его наследников), который представляет доступ к следующим свойствам:

            //Source: элемент логического дерева, являющийся источником события.

            //OriginalSource: элемент визуального дерева, являющийся источником события. Обычно то же самое, что и Source
            //OriginalSource У элемента управления могут быть другие элементы управления в качестве дочерних элементов. 
            //Когда вы подписываетесь на событие от элемента управления, родительский элемент, на который вы подписались,
            //скорее всего, будет тем, что, e.Source однако, если у элемента управления есть дочерние элементы,
            //а дочерний элемент - тот, который вызвал событие, то это OriginalSourceбудет дочерний элемент,
            //который вызвал событие.

            //RoutedEvent: представляет имя события

            //Handled: если это свойство установлено в True, событие не будет подниматься и опускаться, а ограничится непосредственным источником.
        {

получение данных из элементов реализовано так
            string str =
                ((Button) e.OriginalSource).Content.ToString(); // преборазовываем инвент к классу кнопки, и получаем
            //значение контента из кнопки <Button>1</Button> - 1 это и естть контент этой кнопки, и преобразуем его в строку

            if (temp == "=")
            {
                ss = true;
            }

            if (ss)
            {
                if (temp != "+" || temp != "-" || temp != "/" || temp != "*" || temp != "=")
                {
                    textLabel.Text = String.Empty;
                    temp = "";
                }
            }

            if (str == "AC")
            {
                textLabel.Text = String.Empty;
            }
            else if (str == "=")
            {
здесь используется сложение чисел строки
                string value = new DataTable().Compute(textLabel.Text, null)
                    .ToString(); //Compute повзволят нам выситвать значение праметра в качетве входного 
                //значения можно испольовать строку
                if (!string.IsNullOrWhiteSpace(value))
                {
                    textLabel.Text = value;
                }


            }

            else
            {
                textLabel.Text += str;
                temp = str;
            }


        }

        string temp;
        private bool ss = false;
    }
}


------------------------------------------
подключение внешник библилоттек порядок деействий:
solutioon manager=> Project right click => mannagger NuGet=> выбратть интересующую библиотеку=> 
а App.xalm нужно добавить чотто подобное 

<Application.Resources>
<ResourceDictionary>
            <ResourceDictionary.MergedDictionaries><!--при подключении библиотек через нуге нужно зайти на сайт производителя и добавитт оттуда код ресурсов вот сюда-->
                <ResourceDictionary Source="pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Light.xaml" />
                <ResourceDictionary Source="pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Defaults.xaml" />
                <ResourceDictionary Source="pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Primary/MaterialDesignColor.DeepPurple.xaml" />
                <ResourceDictionary Source="pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Accent/MaterialDesignColor.Lime.xaml" />
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>

    => в xalm файл разрабатываемого окна так же необходимо добавит ссылку не ресурсы xmlns:materialDesign="http://materialdesigninxaml.net/winfx/xaml/themes"

------------------------------------------ 
создание 
 <Grid x:Name="MainRoot" Background="#ffdadada">
        <Border MinWidth="40" MaxWidth="550" Background="White" Margin="15"  VerticalAlignment="Center" Padding="30"  CornerRadius="20">
        <!--создаем пллашку бордер, MinWidth и MaxWidth - минималльная и максималная ширина плашки (благодаря этому ширна будем менятся в зависомостти отт ширины окна),
        Margin растояние между элементом и его сосденими элменетами(внешние отсутпы),Padding внутринние отступы()VerticalAlignment расположение плашки
        по вертикали - в даном случае в центре,Padding устанавливает внутрение отступы - от внутреннего содержимого элемента до его границ,  -->
        <Border.Effect><!--тут можно создавать эффекты для нашего бордера-->
                <DropShadowEffect BlurRadius="30" Color="LightGray" ShadowDepth="1"/><!--создаем тень BlurRadius размер рассеивания теени,Color цвет тени 
            ,ShadowDepth то насолькьок далеко тенб будет отставатьт от обьека кторый ее оттбрасывает-->
        </Border.Effect>
        <StackPanel>
            <TextBlock Text="Hello Us" FontSize="30" FontWeight="Bold" Margin="0 0 0 20"></TextBlock>
            <Grid Margin=" 0 0 0 0">
                    <Button HorizontalAlignment ="Left" Content="Registration"/>
                    <!--HorizontalAlignment означает располложение кнопки чтобы она прилегала к левой стороне Grid,-->
                    <!-- эта записьь аналогична верхней (запись в Conttent аналогичен записи внутри тела обьектта)
                    <Button HorizontalAlignment ="Left">Registration</Button>-->

                    <Button HorizontalAlignment="Right" Content="Sign in" Style="{StaticResource MaterialDesignFlatButton}"/>
                    <!--Style позволяет подключить внешшние стили, через StaticResource MaterialDesignFlatButton-->
                </Grid>
                <TextBox materialDesign:HintAssist.Hint="Enter login" Style="{StaticResource MaterialDesignFloatingHintTextBox}"/><!--создание текстбокса с внешним материаал стилем-->
                <PasswordBox materialDesign:HintAssist.Hint="Enter password" Style="{StaticResource MaterialDesignFloatingHintPasswordBox}"/>
                <PasswordBox materialDesign:HintAssist.Hint="Repeat password" Style="{StaticResource MaterialDesignFloatingHintPasswordBox}"/><!--создание специплного текстбокса 
            для паролейт с внешним материаал стилем-->
                <TextBox materialDesign:HintAssist.Hint="Email" Style="{StaticResource MaterialDesignFloatingHintTextBox}"/><!--создание текстбокса с внешним материаал стилем-->
</StackPanel>
        </Border>
        
    </Grid>


==========================================


sql базы данных
------------------------------------------
утановить через nuget пакет  system.data.sqlite в проект, скачать https://sqlitebrowser.org/ с сайта
программу баз.
------------------------------------------
или ииспользоватьт Entity Framework Core 
добавить в проект пакет Entity Framework Core, using Microsoft.EntityFrameworkCore;





НП хзапрещает создание пустых строк,ПК первычный ключ ключ который при удалении не удаляется , АИ автоматически нумерует строки, У уникальное поле

базы данных принято называть во мнножественном числе наприм. Users, Systems и тд


==========================================


--Общая информация--

------------------------------------------
*sql, *базы данных, *кортежи
Для представления одного набора данных. Например, кортеж может представлять запись базы данных, 
а ее компоненты могут представлять отдельные поля записи.

*рефакторинг - это контролируемый процесс улучшения кода, без написания новой функциональности. 
Результат рефакторинга — это чистый код и простой дизайн.

*структруы, *list
если создаешь структуру, и в ней есть List то копируя структуры ты не копируешь List а копируешь ССЫЛКУ на 
ТОТ же List.

*list, *сравнение *SequenceEqual
сравнение списков по муолчанию (именно содержимого а не ссылок)ListName1.SequenceEqual(ListName2);

public static bool SequenceEqual<T>( 
       this IEnumerable<T> first, 
       IEnumerable<T> second);
Эта операция перечисляет каждую входную последовательность параллельно, сравнивая элементы с помощью метода
 System.Object.Equals. Если элементы эквивалентны, и последовательности содержат одинаковое количество элементов, 
 операция возвращает true. Иначе она возвращает false.

*List, *сравнение *IEqualityComparer *Linq *SequenceEqual
static void Main(string[] args)
        {
            string[] strArr1 = {"0012", "130", "0000019", "4"};
            string[] strArr2 = {"12", "0130", "019", "0004"};
            
            bool eq = strArr1.SequenceEqual(strArr2, new MyStringifiedNumberComparer());//используем наш класс в качесвте опции сравнения

            Console.WriteLine(eq);
        }

        public class MyStringifiedNumberComparer : IEqualityComparer<string>//в генерик пишем знаение кторое идет в сравниаемых обьектах
        {
            public bool Equals(string x, string y)//переопределяем метод Equals взятый из IEqualityComparer
            {
                return (Int32.Parse(x) == Int32.Parse(y));//очищаем от лишних 00 впрееди наши строки преобразовоывая из в int 
                //тк 0012 нитов не бывает есть тольо 12 и тд
            }

            public int GetHashCode(string obj)//это необходимо для того чтобы сравнивать хеши обьектов те например хеш инта
                                              //12 и еще одного инта 12 будут равны
            {
                return Int32.Parse(obj).ToString().GetHashCode();
            }

        }

*Linq *Skip
filter = filter.Skip(page * PageSize).Take(PageSize);//Метод Skip() пропускает определенное количество элементов,
// а метод Take() извлекает определенное число элементов. Нередко данные методы применяются вместе для создания постраничного вывода.

==========================================

--Изучить позже--
------------------------------------------

фнукция this делает полезную работу и потом говорит пулу потоков: 
вызови вот эту вот вторую асинхронную функцию invike, но сделай это в основном потоке. 
Вторая функция обновляет индикатор процесса, и, поскольку пул потоков вызывает её в основном потоке, 
никаких конфликтов не происходит.
Типа вызываем например нашу  асинхронную функцию this в случае каогото дествия в программе,
 например нажатие кнопки (это делается как раз в асинхролнном потоке) и наша this делает
скажем settext = "AOAOAAO" в textbox(это делается в оснвном потоке). а такак  settext = "AOAOAAO"в textbox
 делается в основном потоке, при налиции нескольких потоков(таких вот функций по типу this), напрмиер есть 
 еще одна скаежм кнопка ктороая вызывает еще одну асинхронную функцию которая джаелет чтот подобное  
 settext = "blabla"в том же textbox по нажатию кнопки. 
 И чтобы асинхронные функции для входа в оснвной поток друг друга не ждали и не конфликтовали. 
 наши фунции асинхронная разбиваеттся на две  части первая делает полезную работу обработку события 
 нажатия кнопки и говрит вызови вторую часть(которая собтсвенно делает gettext в textbox) в оснвном 
 потоке да обновление происходит послдовательно но и  потому у нас не происходит конфликта с очередностью 
 мы как раз и спользуем invoke ктороый явлется как бы окном в основной поток из асинхроного потка нашей
  функции this те invoke попросту используется для синхронного вызова каждого из первоч части нашей this 
  ва которой выолппняется обработка нажатия, это означает, что вызывающий код(основной поток) должен ожидать
  завершения вызова через invoke, прежде чем продолжить свою работувобщем скажи мне правильно ли я поял 
  прдназначение invoke

типа пул потков это как бы списко чтли потоков для выполнения в фновм режиме
типа чтобы выполниьт какойто метод из потока надо его в пул потока поместить и тогда пул сам будет 
извелкать методы и выполноять их при вызове  и вот чтобы эти асинхронные потоки не конфликтовали и существует invoke

присваивание в  object value = 50; это боксинг


using System;

namespace ExperementNetCore
{
    delegate void AccountHandler<in T>(T message) where T : AccounArgs;//in T это когд вы не можете 

    class AccounArgs
    {
        public string Name;
    }

    class CompanyArg : AccounArgs
    {
        public string Company;
    }


    class Person<T> where T : AccounArgs
    {

        public Person(string name)
        {
            Name = name;
        }


        public event AccountHandler<T> _notify;
        private string name;

        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value != name)
                {
                    name = value;
                    DisplayTo();
                }

            }
        }

        public virtual void DisplayTo()
        {
            OnNotify((T)new AccounArgs() { Name = name });
        }

        protected void OnNotify(T message)
        {
            _notify?.Invoke(message);
        }
    }
    class Employee : Person<CompanyArg>
    {
        public string Company { get; set; }

        public Employee(string name, string company)
            : base(name)
        {
            Company = company;
        }

        public override void DisplayTo()
        {
            OnNotify(new CompanyArg() { Name = Name, Company = Company });
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            var p = new Person<AccounArgs>("Max");
            p._notify += Display;
            p.DisplayTo();

            var e = new Employee("Mixa", "KEK");
            e._notify += Display;
            e.DisplayTo();

            e = new Employee("Lexa", "LLOOOL");
            e._notify += Display;
            e.DisplayTo();

            Console.Read();
        }

        static void Display(AccounArgs name)
        {
            Console.WriteLine(name.Name);
        }
        static void Display(CompanyArg name)
        {
            Console.WriteLine($"{name.Name} {name.Company}");
        }
    }
}


использование _  пустых переменных, в out и прочем.


==========================================


вопросы
------------------------------------------
уточнить про строки как они там копируются и что будет если пердвать строку по ref

как мне сделать в классе  
    class Instantiator<U,V>
    {
        public U FromInstance { get; set; }
        public U ToInstance { get; set; }
        public V Code { get; set; }

    }

            Instantiator<Account<int>,string> i = new Instantiator<Account<int>, string>
            {
                FromInstance = acc1,
                ToInstance = acc2,
                Code = "2520"
            };

    генерик метод который будет выводить значения его полей в виде строки 10 20 30 60 2520, может использзовать делегаты?

почему не раобтает
------------------------------------------ 
как мне правильнол организваоть рекрусию чтобы после ухода в кетч я могг ввести ичло != 0 и не получить на выходе 20

var gg = Num(Console.ReadLine());

static int Num(string num)
        {

            int ss = 20;
            var gg = int.Parse(num);

            try
            {
                ss = ss / gg;
            }
            catch (DivideByZeroException ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine("число не должно быть 0");
                return Num(Console.ReadLine());
            }


            return ss;
        }

==========================================
 delegate void Operations<T>(int i, T acc1, T acc2) where T : IAccount, IClient;
    interface IAccount
    {
      
        int CurrentSum { get; } // Текущая сумма на счету
        void Put(int sum); // Положить деньги на счет
        void Withdraw(int sum); // Взять со счета
    }

    interface IClient
    {
        string Name { get; set; }
    }
   
    class Client : IAccount, IClient
    {
     
        int _sum; // Переменная для хранения суммы
        public Client(string name, int sum)
        {
            Name = name;
            _sum = sum;
          
        }

        public string Name { get; set; }

        public int CurrentSum
        {
            get { return _sum; }
        }

        public void Put(int sum)
        {
            _sum += sum;
        }

        public void Withdraw(int sum)
        {
            if (sum <= _sum)
            {
                _sum -= sum;
            }
        }
    }

    

    class Transaction<T> where T : IAccount, IClient
    {
        
        public void Operate(int sum, T acc1, T acc2, Operations<T> op)
        {
           op.Invoke(sum, acc1, acc2);

            Console.WriteLine($"{acc1.Name} : {acc1.CurrentSum}\n{acc2.Name} : {acc2.CurrentSum}");
        }

        public static void Withdraw(int sum, T acc1, T acc2) 
        {
            if (acc1.CurrentSum >= sum)
            {
                acc1.Withdraw(sum);
                acc2.Put(sum);

            }
        }
        public static void Put(int sum, T acc1, T acc2)
        {
            if (acc1.CurrentSum >= sum)
            {
                acc1.Put(sum);
                acc2.Withdraw(sum);

            }
        }

    }

    class Program
    {
        static void Main(string[] args)
        {

            Client account1 = new Client("Tom", 200);
            Client account2 = new Client("Bob", 300);

            Transaction<Client> transaction = new Transaction<Client>();


            transaction.Operate(150, account1, account2, Transaction<Client>.Put);
            transaction.Operate(150, account1, account2, Transaction<Client>.Withdraw);

        }

    }
}